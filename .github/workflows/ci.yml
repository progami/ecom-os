name: CI

on:
  pull_request:
    branches:
      - dev
      - main

concurrency:
  group: ci-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Enable pnpm via corepack
        run: corepack enable && corepack prepare pnpm@9.0.0 --activate
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      - name: Lint website
        run: pnpm --filter @ecom-os/website lint
      - name: Type-check website
        run: pnpm --filter @ecom-os/website type-check
      - name: Build website
        run: pnpm --filter @ecom-os/website build
      - name: Lint WMS
        run: pnpm --filter @ecom-os/wms lint
      - name: Type-check WMS
        run: pnpm --filter @ecom-os/wms type-check
      - name: Build WMS
        run: pnpm --filter @ecom-os/wms build

  auto-merge-dev:
    needs: build-test
    if: >-
      ${{ github.event_name == 'pull_request' &&
          github.event.pull_request.base.ref == 'dev' }}
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
    steps:
      - name: Merge PR into dev when ready
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo
            const prNumber = context.payload.pull_request.number

            const { data: pr } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber,
            })

            if (pr.state !== 'open') {
              core.info(`PR #${prNumber} is not open; skipping auto-merge`)
              return
            }

            if (pr.draft) {
              core.info(`PR #${prNumber} is still a draft; skipping auto-merge`)
              return
            }

            if (pr.mergeable_state === 'blocked' || pr.mergeable_state === 'dirty') {
              core.info(`PR #${prNumber} mergeable_state is '${pr.mergeable_state}'; waiting for checks/reviews/conflicts to resolve`)
              return
            }

            if (pr.mergeable_state === 'unknown') {
              core.info(`PR #${prNumber} mergeable_state is 'unknown'; GitHub has not computed mergeability yet`)
              return
            }

            if (pr.mergeable_state !== 'clean') {
              core.info(`PR #${prNumber} mergeable_state is '${pr.mergeable_state}'; skipping auto-merge`)
              return
            }

            core.info(`Squash merging PR #${prNumber} into dev`)
            try {
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: prNumber,
                merge_method: 'squash',
              })
            } catch (error) {
              core.setFailed(`Failed to merge PR #${prNumber}: ${error.message}`)
              return
            }

            if (pr.head.repo?.full_name !== `${owner}/${repo}`) {
              core.info(`PR branch ${pr.head.ref} belongs to a fork; skipping branch deletion`)
              return
            }

            const ref = `heads/${pr.head.ref}`
            try {
              await github.rest.git.deleteRef({ owner, repo, ref })
              core.info(`Deleted remote branch ${pr.head.ref}`)
            } catch (error) {
              core.warning(`Unable to delete branch ${pr.head.ref}: ${error.message}`)
            }

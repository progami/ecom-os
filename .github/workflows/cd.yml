name: CD

on:
  push:
    branches:
      - dev
      - main
  workflow_dispatch:
    inputs:
      app:
        description: 'App to deploy (leave empty for auto-detect)'
        required: false
        type: choice
        options:
          - ''
          - ecomos
          - wms
          - website
          - xplan
          - chronos
          - hrms
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - main

env:
  ECOM_OS_DEV_DIR: /Users/jarraramjad/ecom-os-dev
  ECOM_OS_MAIN_DIR: /Users/jarraramjad/ecom-os-main

permissions:
  contents: read

concurrency:
  group: cd-${{ github.workflow }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.ref_name }}
  cancel-in-progress: false

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      ecomos: ${{ steps.changes.outputs.ecomos }}
      wms: ${{ steps.changes.outputs.wms }}
      website: ${{ steps.changes.outputs.website }}
      xplan: ${{ steps.changes.outputs.xplan }}
      chronos: ${{ steps.changes.outputs.chronos }}
      hrms: ${{ steps.changes.outputs.hrms }}
      packages: ${{ steps.changes.outputs.packages }}
      any_app: ${{ steps.changes.outputs.any_app }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed apps
        id: changes
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.app }}" ]]; then
            echo "${{ inputs.app }}=true" >> "$GITHUB_OUTPUT"
            echo "any_app=true" >> "$GITHUB_OUTPUT"
          else
            if [[ "${{ github.event_name }}" == "push" ]]; then
              # For pushes, compare the entire range included in the event payload.
              BASE="${{ github.event.before }}"
              HEAD="${{ github.sha }}"

              if [[ -z "$BASE" || "$BASE" == "0000000000000000000000000000000000000000" ]]; then
                CHANGED_FILES="$(git ls-files)"
              else
                CHANGED_FILES="$(git diff --name-only "$BASE" "$HEAD")"
              fi
            else
              # For workflow_dispatch, fall back to "latest commit vs previous commit" on the selected branch.
              CHANGED_FILES="$(git diff --name-only HEAD^ HEAD 2>/dev/null || git diff --name-only HEAD)"
            fi

            echo "Changed files:"
            echo "$CHANGED_FILES"

            ANY_APP=false

            if echo "$CHANGED_FILES" | grep -q "^apps/ecomos/"; then
              echo "ecomos=true" >> "$GITHUB_OUTPUT"
              ANY_APP=true
            fi
            if echo "$CHANGED_FILES" | grep -q "^apps/wms/"; then
              echo "wms=true" >> "$GITHUB_OUTPUT"
              ANY_APP=true
            fi
            if echo "$CHANGED_FILES" | grep -q "^apps/website/"; then
              echo "website=true" >> "$GITHUB_OUTPUT"
              ANY_APP=true
            fi
            if echo "$CHANGED_FILES" | grep -q "^apps/x-plan/"; then
              echo "xplan=true" >> "$GITHUB_OUTPUT"
              ANY_APP=true
            fi
            if echo "$CHANGED_FILES" | grep -q "^apps/chronos/"; then
              echo "chronos=true" >> "$GITHUB_OUTPUT"
              ANY_APP=true
            fi
            if echo "$CHANGED_FILES" | grep -q "^apps/hrms/"; then
              echo "hrms=true" >> "$GITHUB_OUTPUT"
              ANY_APP=true
            fi
            if echo "$CHANGED_FILES" | grep -q "^packages/"; then
              echo "packages=true" >> "$GITHUB_OUTPUT"
              ANY_APP=true
            fi

            echo "any_app=$ANY_APP" >> "$GITHUB_OUTPUT"
          fi

  build-metadata:
    needs: detect-changes
    if: (github.event_name == 'push' && needs.detect-changes.outputs.any_app == 'true') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.ref_name }}
    outputs:
      version: ${{ steps.meta.outputs.version }}
      version_url: ${{ steps.meta.outputs.version_url }}
      commit_sha: ${{ steps.meta.outputs.commit_sha }}
      build_time: ${{ steps.meta.outputs.build_time }}
      tag: ${{ steps.meta.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.ref_name }}

      - name: Compute build metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          build_time="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          head_sha="$(git rev-parse HEAD)"
          commit_sha="$(git rev-parse --short=8 HEAD)"

          # NOTE:
          # - `git describe` picks the *nearest* tag by commit distance, not the highest semver tag.
          # - We want a monotonically increasing version on `main`, even when tags are not on the first-parent path.
          # Fetch tags from the remote directly so versioning stays correct even when tags are missing locally.
          # (GitHub Actions checkout can omit tags depending on fetch configuration and history shape.)
          remote_semver_tags="$(
            git ls-remote --tags origin | awk '
              {
                sha=$1
                ref=$2
                sub("^refs/tags/","",ref)
                peeled=0
                if (ref ~ /\^\{\}$/) { peeled=1; sub(/\^\{\}$/,"",ref) }
                tag=ref

                if (tag ~ /^v[0-9]+\.[0-9]+\.[0-9]+$/) {
                  if (peeled) { sha_by_tag[tag]=sha; peeled_by_tag[tag]=1 }
                  else if (!(tag in peeled_by_tag)) { sha_by_tag[tag]=sha }
                }
              }
              END { for (tag in sha_by_tag) print tag "\t" sha_by_tag[tag] }
            ' | tr -d '\r'
          )"

          is_release_run="false"
          if [[ "$TARGET_ENV" == "main" && "${GITHUB_EVENT_NAME}" == "push" ]]; then
            is_release_run="true"
          fi

          if [[ "$is_release_run" == "true" ]] && [[ -z "${remote_semver_tags//[[:space:]]/}" ]]; then
            echo "::error::No remote semver tags discovered; refusing to create a v0.0.x release."
            exit 1
          fi

          exact_tag="$(printf '%s\n' "$remote_semver_tags" | awk -v sha="$head_sha" '$2==sha {print $1}' | LC_ALL=C sort -V | tail -n 1 || true)"
          base_tag_line="$(printf '%s\n' "$remote_semver_tags" | LC_ALL=C sort -V -k1,1 | tail -n 1 || true)"
          base_tag=""
          base_sha=""
          if [[ -n "$base_tag_line" ]]; then
            base_tag="${base_tag_line%%$'\t'*}"
            base_sha="${base_tag_line#*$'\t'}"
          fi
          create_release="false"

          if [[ -n "$exact_tag" ]]; then
            version="${exact_tag#v}"
            tag="$exact_tag"
          else
            if [[ -n "$base_tag" ]]; then
              base_version="${base_tag#v}"
              if [[ -z "$base_sha" ]]; then
                echo "::warning::Could not resolve base_tag '$base_tag' to a commit SHA; using full history for bump detection"
                range="HEAD"
              elif git merge-base --is-ancestor "$base_sha" HEAD; then
                range="${base_sha}..HEAD"
              else
                merge_base="$(git merge-base "$base_sha" HEAD)"
                range="${merge_base}..HEAD"
              fi
            else
              range="HEAD"
              base_version="0.0.0"
            fi

            bump="patch"
            commit_messages="$(git log "$range" --pretty=%s%n%b)"

            if grep -qE 'BREAKING CHANGE|^[a-zA-Z]+(\(.+\))?!:' <<< "$commit_messages"; then
              bump="major"
            elif grep -qE '^feat(\(.+\))?:' <<< "$commit_messages"; then
              bump="minor"
            elif grep -qE '^fix(\(.+\))?:' <<< "$commit_messages"; then
              bump="patch"
            fi

            base_version="$(printf '%s' "$base_version" | tr -d '\r\n\t ')"
            if ! [[ "$base_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "::error::Expected base_version to be strict semver, got '$base_version' from base_tag '$base_tag'"
              exit 1
            fi

            IFS='.' read -r major minor patch <<< "$base_version"
            major="${major:-0}"
            minor="${minor:-0}"
            patch="${patch:-0}"

            case "$bump" in
              major)
                major=$((major + 1))
                minor=0
                patch=0
                ;;
              minor)
                minor=$((minor + 1))
                patch=0
                ;;
              patch)
                patch=$((patch + 1))
                ;;
            esac

            version="${major}.${minor}.${patch}"
            tag="v${version}"

            # Ensure we never reuse an existing tag (e.g., if older tags are off the mainline history).
            tag_exists() {
              git ls-remote --tags --refs origin "refs/tags/${1}" | grep -q .
            }

            while tag_exists "$tag"; do
              patch=$((patch + 1))
              version="${major}.${minor}.${patch}"
              tag="v${version}"
            done

            if [[ "$is_release_run" == "true" ]]; then
              create_release="true"
            fi
          fi

          use_release_url="false"
          if [[ "$TARGET_ENV" == "main" ]] && [[ -n "$exact_tag" || "$create_release" == "true" ]]; then
            use_release_url="true"
          fi

          if [[ "$use_release_url" == "true" ]]; then
            version_url="https://github.com/${GITHUB_REPOSITORY}/releases/tag/${tag}"
          else
            version_url="https://github.com/${GITHUB_REPOSITORY}/commit/${head_sha}"
          fi

          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "version_url=$version_url" >> "$GITHUB_OUTPUT"
          echo "commit_sha=$commit_sha" >> "$GITHUB_OUTPUT"
          echo "build_time=$build_time" >> "$GITHUB_OUTPUT"
          echo "create_release=$create_release" >> "$GITHUB_OUTPUT"

      - name: Create GitHub release (main only)
        if: github.event_name == 'push' && github.ref_name == 'main' && steps.meta.outputs.create_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.meta.outputs.tag }}
          name: Release ${{ steps.meta.outputs.tag }}
          # Repo default branch is `dev`, so explicitly tag the commit that triggered this workflow on `main`.
          target_commitish: ${{ github.sha }}
          generate_release_notes: true

  # ===========================================
  # DEPLOY - Only runs on push to dev/main
  # ===========================================
  deploy:
    needs: [detect-changes, build-metadata]
    if: github.event_name == 'push' && needs.detect-changes.outputs.any_app == 'true'
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
      - name: Setup pnpm
        shell: bash
        run: corepack enable && corepack prepare pnpm@10.21.0 --activate

      - name: Deploy changed apps
        shell: bash
        env:
          NEXT_PUBLIC_VERSION: ${{ needs.build-metadata.outputs.version }}
          NEXT_PUBLIC_RELEASE_URL: ${{ needs.build-metadata.outputs.version_url }}
          NEXT_PUBLIC_COMMIT_SHA: ${{ needs.build-metadata.outputs.commit_sha }}
          BUILD_TIME: ${{ needs.build-metadata.outputs.build_time }}
        run: |
          set -euo pipefail
          if command -v caffeinate >/dev/null 2>&1; then
            caffeinate -dimsu &
            caffeinate_pid="$!"
            trap 'kill "$caffeinate_pid" >/dev/null 2>&1 || true' EXIT
          fi

          TARGET_ENV="${{ github.ref_name }}"

          declare -a apps=()
          if [[ "$TARGET_ENV" == "main" ]]; then
            apps=(ecomos wms website xplan chronos hrms)
          elif [[ "${{ needs.detect-changes.outputs.packages }}" == "true" ]]; then
            apps=(ecomos wms website xplan chronos hrms)
          else
            [[ "${{ needs.detect-changes.outputs.ecomos }}" == "true" ]] && apps+=(ecomos)
            [[ "${{ needs.detect-changes.outputs.wms }}" == "true" ]] && apps+=(wms)
            [[ "${{ needs.detect-changes.outputs.website }}" == "true" ]] && apps+=(website)
            [[ "${{ needs.detect-changes.outputs.xplan }}" == "true" ]] && apps+=(xplan)
            [[ "${{ needs.detect-changes.outputs.chronos }}" == "true" ]] && apps+=(chronos)
            [[ "${{ needs.detect-changes.outputs.hrms }}" == "true" ]] && apps+=(hrms)
          fi

          if [[ ${#apps[@]} -eq 0 ]]; then
            echo "No deployable apps detected; exiting."
            exit 0
          fi

          echo "Deploying to $TARGET_ENV: ${apps[*]}"

          first=true
          for app in "${apps[@]}"; do
            if [[ "$first" == "true" ]]; then
              DEPLOY_GIT_SHA="${{ github.sha }}" DEPLOY_SKIP_GIT=false DEPLOY_SKIP_INSTALL=false DEPLOY_SKIP_PM2_SAVE=true \
                bash "${{ github.workspace }}/scripts/deploy-app.sh" "$app" "$TARGET_ENV"
              first=false
            else
              DEPLOY_SKIP_GIT=true DEPLOY_SKIP_INSTALL=true DEPLOY_SKIP_PM2_SAVE=true \
                bash "${{ github.workspace }}/scripts/deploy-app.sh" "$app" "$TARGET_ENV"
            fi
          done

          echo "Saving PM2 state once"
          pm2 save

  # ===========================================
  # MANUAL DEPLOY - For workflow_dispatch
  # ===========================================
  manual-deploy:
    needs: [detect-changes, build-metadata]
    if: github.event_name == 'workflow_dispatch'
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
      - name: Setup pnpm
        shell: bash
        run: corepack enable && corepack prepare pnpm@10.21.0 --activate

      - name: Deploy selected app(s)
        shell: bash
        env:
          NEXT_PUBLIC_VERSION: ${{ needs.build-metadata.outputs.version }}
          NEXT_PUBLIC_RELEASE_URL: ${{ needs.build-metadata.outputs.version_url }}
          NEXT_PUBLIC_COMMIT_SHA: ${{ needs.build-metadata.outputs.commit_sha }}
          BUILD_TIME: ${{ needs.build-metadata.outputs.build_time }}
        run: |
          set -euo pipefail
          if command -v caffeinate >/dev/null 2>&1; then
            caffeinate -dimsu &
            caffeinate_pid="$!"
            trap 'kill "$caffeinate_pid" >/dev/null 2>&1 || true' EXIT
          fi

          requested_app="${{ inputs.app }}"
          target_env="${{ inputs.environment }}"

          declare -a apps=()
          if [[ "$target_env" == "main" ]]; then
            apps=(ecomos wms website xplan chronos hrms)
          elif [[ -n "$requested_app" ]]; then
            apps=("$requested_app")
          elif [[ "${{ needs.detect-changes.outputs.packages }}" == "true" ]]; then
            apps=(ecomos wms website xplan chronos hrms)
          else
            [[ "${{ needs.detect-changes.outputs.ecomos }}" == "true" ]] && apps+=(ecomos)
            [[ "${{ needs.detect-changes.outputs.wms }}" == "true" ]] && apps+=(wms)
            [[ "${{ needs.detect-changes.outputs.website }}" == "true" ]] && apps+=(website)
            [[ "${{ needs.detect-changes.outputs.xplan }}" == "true" ]] && apps+=(xplan)
            [[ "${{ needs.detect-changes.outputs.chronos }}" == "true" ]] && apps+=(chronos)
            [[ "${{ needs.detect-changes.outputs.hrms }}" == "true" ]] && apps+=(hrms)
          fi

          if [[ ${#apps[@]} -eq 0 ]]; then
            echo "No deployable apps detected; exiting."
            exit 0
          fi

          echo "Manual deploy to $target_env: ${apps[*]}"

          first=true
          for app in "${apps[@]}"; do
            if [[ "$first" == "true" ]]; then
              DEPLOY_SKIP_GIT=false DEPLOY_SKIP_INSTALL=false DEPLOY_SKIP_PM2_SAVE=true \
                bash "${{ github.workspace }}/scripts/deploy-app.sh" "$app" "$target_env"
              first=false
            else
              DEPLOY_SKIP_GIT=true DEPLOY_SKIP_INSTALL=true DEPLOY_SKIP_PM2_SAVE=true \
                bash "${{ github.workspace }}/scripts/deploy-app.sh" "$app" "$target_env"
            fi
          done

          echo "Saving PM2 state once"
          pm2 save

name: CD

on:
  pull_request_target:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: >-
      ${{ github.event_name == 'workflow_dispatch' ||
          (github.event_name == 'pull_request_target' &&
           github.event.pull_request.head.ref == 'dev') }}
    permissions:
      id-token: write
      contents: read
    env:
      # expose secrets as env; avoid using `secrets.*` in `if:` expressions
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      AWS_ROLE_TO_ASSUME: ${{ secrets.AWS_ROLE_TO_ASSUME }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      EC2_HOST_SECRET: ${{ secrets.EC2_HOST }}
      EC2_USER_SECRET: ${{ secrets.EC2_USER }}
      EC2_INSTANCE_ID_SECRET: ${{ secrets.EC2_INSTANCE_ID }}
      CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
      ECOMOS_ENV: ${{ secrets.ECOMOS_ENV }}
    concurrency:
      group: prod-main
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Install tools (ansible, rsync, jq, curl)
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible rsync jq curl
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: corepack enable && corepack prepare pnpm@9.0.0 --activate
      - run: pnpm install
      - name: Generate Prisma client for auth package
        env:
          CENTRAL_DB_URL: postgresql://postgres:postgres@localhost:5432/postgres?schema=auth
        run: pnpm --filter @ecom-os/auth prisma:generate
      - name: Generate Prisma client for WMS
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/postgres
        run: pnpm --filter @ecom-os/wms db:generate
      - name: Generate Prisma client for X-Plan
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/postgres
        run: pnpm --filter @ecom-os/x-plan prisma:generate
      - name: Build production apps
        env:
          NEXTAUTH_SECRET: test-nextauth-secret
          CENTRAL_AUTH_SECRET: test-central-secret
          CENTRAL_AUTH_URL: https://example.com
          NEXTAUTH_URL: https://example.com/api/auth
          COOKIE_DOMAIN: .example.com
          BASE_PATH: /wms
          NEXT_PUBLIC_BASE_PATH: /wms
          NEXT_PUBLIC_APP_URL: https://example.com/wms
          NEXT_PUBLIC_CENTRAL_AUTH_URL: https://example.com
          CSRF_ALLOWED_ORIGINS: https://example.com,https://example.com/wms
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/postgres
        run: pnpm turbo run build --filter=@ecom-os/website --filter=@ecom-os/ecomos --filter=@ecom-os/wms --filter=@ecom-os/x-plan || (echo "Build failed" && exit 1)

      - name: Configure SSH
        run: |
          install -m 600 -D /dev/null ~/.ssh/id_rsa
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa

      - name: Optionally assume AWS role and discover EC2 host
        if: ${{ env.AWS_ROLE_TO_ASSUME != '' && env.AWS_REGION != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Discover EC2 host (if AWS creds available)
        if: ${{ env.AWS_ROLE_TO_ASSUME != '' && env.AWS_REGION != '' }}
        run: |
          set -euo pipefail
          if [ -n "${EC2_INSTANCE_ID_SECRET:-}" ]; then
            QUERY_OPTS=(--instance-ids "$EC2_INSTANCE_ID_SECRET")
          else
            QUERY_OPTS=(--filters "Name=instance-state-name,Values=running")
          fi
          read INST_ID INST_AZ INST_IP < <(aws ec2 describe-instances "${QUERY_OPTS[@]}" \
            --query 'Reservations[0].Instances[0].[InstanceId,Placement.AvailabilityZone,PublicIpAddress]' --output text || true)
          if [ -z "${INST_IP:-}" ] || [ "${INST_IP}" = "None" ]; then
            echo "No matching EC2 instance with public IP found via AWS lookup" >&2
            exit 0
          fi
          echo "EC2_HOST=$INST_IP" >> $GITHUB_ENV
          echo "EIC_INSTANCE_ID=$INST_ID" >> $GITHUB_ENV
          echo "EIC_INSTANCE_AZ=$INST_AZ" >> $GITHUB_ENV
          echo "Discovered: id=$INST_ID az=$INST_AZ ip=$INST_IP"

      - name: Fallback to secrets for EC2 host and user (if not discovered)
        run: |
          if [ -z "${EC2_HOST:-}" ]; then
            echo "EC2_HOST=${EC2_HOST_SECRET}" >> $GITHUB_ENV
          fi
          echo "EC2_USER=${EC2_USER_SECRET}" >> $GITHUB_ENV

      - name: Validate EC2 host resolved
        run: |
          if [ -z "${EC2_HOST:-}" ]; then
            echo "::error title=Missing EC2 host::Failed to resolve EC2 host. Provide AWS filters or set EC2_HOST secret." >&2
            exit 1
          fi

      - name: Generate and inject CI SSH key via EC2 Instance Connect
        if: ${{ env.AWS_ROLE_TO_ASSUME != '' && env.AWS_REGION != '' }}
        env:
          OS_USER: ${{ env.EC2_USER_SECRET }}
        run: |
          set -e
          OS_USER=${OS_USER:-ubuntu}
          ssh-keygen -t ed25519 -N '' -f ~/.ssh/ci_key -C ci@github || true
          # Push key via EIC (ephemeral)
          aws ec2-instance-connect send-ssh-public-key \
            --instance-id "$EIC_INSTANCE_ID" \
            --availability-zone "$EIC_INSTANCE_AZ" \
            --instance-os-user "$OS_USER" \
            --ssh-public-key "file://$HOME/.ssh/ci_key.pub"
          # Use ephemeral window to append pubkey permanently
          ssh -i ~/.ssh/ci_key -o StrictHostKeyChecking=no "$OS_USER@$EC2_HOST" \
            "mkdir -p ~/.ssh && touch ~/.ssh/authorized_keys && grep -qxF '$(cat ~/.ssh/ci_key.pub)' ~/.ssh/authorized_keys || echo '$(cat ~/.ssh/ci_key.pub)' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys"
          # Switch default key for subsequent steps
          install -m 600 -D ~/.ssh/ci_key ~/.ssh/id_rsa

      - name: Append known_hosts for EC2
        run: |
          ssh-keyscan -H "$EC2_HOST" >> ~/.ssh/known_hosts

      - name: Check remote disk usage before deploy
        continue-on-error: true
        env:
          OS_USER: ${{ env.EC2_USER_SECRET }}
        run: |
          set -e
          OS_USER=${OS_USER:-${EC2_USER:-ubuntu}}
          SSH_SCRIPT=$'set -e\n'\
            $'df -h\n'\
            $'echo\n'\
            $'echo "Top-level usage:"\n'\
            $'sudo du -sh /opt/ecom-os /var/log || true\n'\
            $'echo\n'\
            $'echo "/opt/ecom-os breakdown:"\n'\
            $'sudo du -sh /opt/ecom-os/* 2>/dev/null | sort -hr | head || true\n'\
            $'echo\n'\
            $'echo "User cache breakdown:"\n'\
            $'sudo du -sh "$HOME/.local/share/pnpm" "$HOME/.local/state/pnpm" "$HOME/.pnpm-store" 2>/dev/null || true\n'\
            $'sudo du -sh "$HOME/.cache" 2>/dev/null | sort -hr | head || true\n'\
            $'echo\n'\
            $'echo "PM2 logs:"\n'\
            $'sudo du -sh "$HOME/.pm2/logs" 2>/dev/null || true'
          ssh -o StrictHostKeyChecking=no "$OS_USER@$EC2_HOST" "bash -s" <<< "$SSH_SCRIPT"

      - name: Update Cloudflare DNS (apex + www) to EC2
        continue-on-error: true
        env:
          CF_API_TOKEN: ${{ env.CF_API_TOKEN }}
          CF_ZONE_NAME: targonglobal.com
        run: |
          set -e
          if [ -z "${CF_API_TOKEN:-}" ]; then echo "No CF_API_TOKEN provided; skipping DNS update"; exit 0; fi
          echo "Fetching Cloudflare Zone ID for $CF_ZONE_NAME"
          ZONE_RESP=$(curl -s -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" \
            "https://api.cloudflare.com/client/v4/zones?name=$CF_ZONE_NAME")
          CF_ZONE_ID=$(echo "$ZONE_RESP" | jq -r '.result[0].id')
          if [ -z "$CF_ZONE_ID" ] || [ "$CF_ZONE_ID" = "null" ]; then echo "Zone not found" >&2; exit 1; fi
          upsert_a(){
            local NAME="$1"; local IP="$2"; local PROXIED=${3:-false}
            echo "Upserting A record $NAME -> $IP (proxied=$PROXIED)"
            REC_ID=$(curl -s -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" \
              "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?type=A&name=$NAME" | jq -r '.result[0].id')
            DATA=$(jq -n --arg type A --arg name "$NAME" --arg content "$IP" --argjson proxied $PROXIED '{type:"A",name:$name,content:$content,ttl:120,proxied:$proxied}')
            if [ -n "$REC_ID" ] && [ "$REC_ID" != "null" ]; then
              curl -s -X PUT -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" \
                "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records/$REC_ID" --data "$DATA" | jq -r '.success'
            else
              curl -s -X POST -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" \
                "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" --data "$DATA" | jq -r '.success'
            fi
          }
          upsert_a "$CF_ZONE_NAME" "$EC2_HOST" false
          upsert_a "www.$CF_ZONE_NAME" "$EC2_HOST" false
          upsert_a "ecomos.$CF_ZONE_NAME" "$EC2_HOST" false
          upsert_a "wms.$CF_ZONE_NAME" "$EC2_HOST" false

      - name: Write inventory
        run: |
          mkdir -p infra/ansible/inventory
          echo "[mono]" > infra/ansible/inventory/hosts.ini
          USER_VAL=${EC2_USER:-ubuntu}
          echo "$EC2_HOST ansible_user=$USER_VAL" >> infra/ansible/inventory/hosts.ini

      - name: Show ansible version
        run: ansible --version && ansible-galaxy collection list || true

      - name: Ansible ping EC2
        env:
          ANSIBLE_HOST_KEY_CHECKING: 'False'
          ANSIBLE_SSH_COMMON_ARGS: "-o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o ConnectionAttempts=10"
        run: |
          echo "[mono]" > infra/ansible/inventory/hosts.ini
          echo "$EC2_HOST ansible_user=${EC2_USER:-ubuntu}" >> infra/ansible/inventory/hosts.ini
          ansible -vvv -i infra/ansible/inventory/hosts.ini mono -m ping

      - name: Deploy via Ansible (monorepo)
        env:
          ANSIBLE_HOST_KEY_CHECKING: 'False'
          ANSIBLE_STDOUT_CALLBACK: debug
          ANSIBLE_SSH_COMMON_ARGS: "-o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o ConnectionAttempts=10"
          DEPLOY_COMMIT: ${{ github.sha }}
          WEBSITE_ENV: ${{ secrets.WEBSITE_ENV }}
          WMS_ENV: ${{ secrets.WMS_ENV }}
          HRMS_ENV: ${{ secrets.HRMS_ENV }}
          FCC_ENV: ${{ secrets.FCC_ENV }}
          CENTRAL_DB_ENV: ${{ secrets.CENTRAL_DB_ENV }}
          MARGIN_MASTER_ENV: ${{ secrets.MARGIN_MASTER_ENV }}
          JASON_ENV: ${{ secrets.JASON_ENV }}
          ECOMOS_ENV: ${{ secrets.ECOMOS_ENV }}
          XPLAN_ENV: ${{ secrets.XPLAN_ENV }}
        run: |
          set -e
          echo "Inventory:" && cat infra/ansible/inventory/hosts.ini
          ansible-playbook -vvv -i infra/ansible/inventory/hosts.ini infra/ansible/deploy-monorepo.yml

      - name: Post-deploy health checks
        run: |
          set -e
          HOST_IP="$EC2_HOST"
          parse_var() {
            awk -F': *' -v VAR="$1" '$1==VAR {print $2}' infra/ansible/group_vars/all.yml \
              | tr -d '"' \
              | sed -e 's/^ *//' -e 's/ *$//' \
              | tr -d '\n'
          }
          WEBSITE=$(parse_var website_server_name)
          WMS=$(parse_var wms_server_name)
          # Only check active hosts
          REQUIRED=($WEBSITE $WMS)
          OPTIONAL=()
          # host ip retries
          check_host() {
            local host="$1"; local ip="$2"; local retries="${3:-12}"; local path="/"; local i=1
            while [ $i -le "$retries" ]; do
              code=$(curl -sS --connect-timeout 3 --max-time 5 -o /dev/null -w "%{http_code}" -H "Host: $host" "http://$ip$path" || true)
              if echo "$code" | grep -Eq '^(20|30)[0-9]$'; then echo "OK: $host -> $code"; return 0; fi
              sleep 5; i=$((i+1))
            done
            echo "FAIL: $host"; return 1
          }
          failures=0
          # Required hosts (allow up to 12 attempts ~1 min max)
          for h in "${REQUIRED[@]}"; do [ -n "$h" ] && check_host "$h" "$HOST_IP" 12 || failures=$((failures+1)); done
          # Optional hosts: run in parallel with fewer attempts (6 attempts ~30s max each)
          for h in "${OPTIONAL[@]}"; do [ -n "$h" ] && check_host "$h" "$HOST_IP" 6 & done
          wait || true
          [ "$failures" -eq 0 ] || exit 1

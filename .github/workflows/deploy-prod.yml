name: CD

on:
  pull_request_target:
    branches:
      - main
  workflow_run:
    workflows: ["CI"]
    branches: [main]
    types: [completed]
  workflow_dispatch:
    inputs:
      ref:
        description: "Branch, tag, or commit SHA to deploy"
        required: false
        default: "main"

concurrency:
  group: prod-main
  cancel-in-progress: false

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      target_sha: ${{ steps.context.outputs.target_sha }}
      artifact_run_id: ${{ steps.artifact.outputs.artifact_run_id }}
      trigger: ${{ steps.context.outputs.trigger }}
      deploy_ref: ${{ steps.context.outputs.deploy_ref }}
      ci_ok: ${{ steps.context.outputs.ci_ok }}
      should_deploy: ${{ steps.context.outputs.ci_ok == 'true' && steps.diff.outputs.should_deploy == 'true' && 'true' || 'false' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve deployment target
        id: context
        env:
          EVENT_NAME: ${{ github.event_name }}
          WORKFLOW_CONCLUSION: ${{ github.event.workflow_run && github.event.workflow_run.conclusion || '' }}
          WORKFLOW_HEAD_SHA: ${{ github.event.workflow_run && github.event.workflow_run.head_sha || '' }}
          WORKFLOW_HEAD_BRANCH: ${{ github.event.workflow_run && github.event.workflow_run.head_branch || '' }}
          WORKFLOW_ID: ${{ github.event.workflow_run && github.event.workflow_run.id || '' }}
          INPUT_REF: ${{ github.event.inputs && github.event.inputs.ref || '' }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail

          TARGET_SHA=""
          DEPLOY_REF=""
          ARTIFACT_RUN_ID=""
          CI_OK="true"
          TRIGGER_KIND="$EVENT_NAME"

          if [ "$EVENT_NAME" = "workflow_run" ]; then
            if [ "$WORKFLOW_CONCLUSION" != "success" ]; then
              CI_OK="false"
              echo "CI workflow concluded with '$WORKFLOW_CONCLUSION'; skipping deploy" >> $GITHUB_STEP_SUMMARY
            fi
            TARGET_SHA="$WORKFLOW_HEAD_SHA"
            DEPLOY_REF="$WORKFLOW_HEAD_BRANCH"
            ARTIFACT_RUN_ID="$WORKFLOW_ID"
            TRIGGER_KIND="workflow_run"

            if [ "$CI_OK" = "true" ]; then
              git fetch origin "$DEPLOY_REF" || git fetch origin
              git checkout "$TARGET_SHA"
            fi
          else
            DEPLOY_REF="${INPUT_REF:-${GITHUB_REF_NAME:-main}}"
            git fetch origin

            if git rev-parse --verify --quiet "$DEPLOY_REF"; then
              TARGET_SHA=$(git rev-parse "$DEPLOY_REF")
            elif git rev-parse --verify --quiet "origin/$DEPLOY_REF"; then
              TARGET_SHA=$(git rev-parse "origin/$DEPLOY_REF")
              git checkout "origin/$DEPLOY_REF"
            else
              TARGET_SHA="${GITHUB_SHA:-$DEPLOY_REF}"
              git fetch origin "$TARGET_SHA" || true
            fi

            git checkout "$TARGET_SHA"
          fi

          if [ -z "$TARGET_SHA" ]; then
            echo "Unable to resolve deployment commit" >&2
            exit 1
          fi

          echo "target_sha=$TARGET_SHA" >> $GITHUB_OUTPUT
          echo "artifact_run_id=$ARTIFACT_RUN_ID" >> $GITHUB_OUTPUT
          echo "deploy_ref=$DEPLOY_REF" >> $GITHUB_OUTPUT
          echo "ci_ok=$CI_OK" >> $GITHUB_OUTPUT
          echo "trigger=$TRIGGER_KIND" >> $GITHUB_OUTPUT

      - name: Determine change scope
        id: diff
        if: steps.context.outputs.ci_ok == 'true'
        run: |
          set -euo pipefail

          TARGET_SHA=${{ steps.context.outputs.target_sha }}
          BASE_COMMIT=$(git rev-parse "${TARGET_SHA}^" 2>/dev/null || true)

          if [ -z "$BASE_COMMIT" ]; then
            echo "No base commit detected; defaulting to deploy" >> $GITHUB_STEP_SUMMARY
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          if git diff --name-only "$BASE_COMMIT" "$TARGET_SHA" | grep -qvE '^(BRANCHING\.md|\.github/workflows/(auto-sync-dev|pr-policy)\.yml|docs/|README\.md)'; then
            echo "Application changes detected between $BASE_COMMIT and $TARGET_SHA" >> $GITHUB_STEP_SUMMARY
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "Only documentation/workflow changes detected; skipping deploy" >> $GITHUB_STEP_SUMMARY
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Locate CI artifact run
        id: artifact
        env:
          GH_TOKEN: ${{ github.token }}
          EVENT_NAME: ${{ github.event_name }}
          WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id || '' }}
          TARGET_SHA: ${{ steps.context.outputs.target_sha }}
          REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          if [ "$EVENT_NAME" = "workflow_run" ] && [ -n "$WORKFLOW_RUN_ID" ]; then
            echo "artifact_run_id=$WORKFLOW_RUN_ID" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$EVENT_NAME" != "pull_request_target" ]; then
            echo "artifact_run_id=" >> $GITHUB_OUTPUT
            exit 0
          fi

          run_id=$(gh api --paginate "/repos/$REPOSITORY/actions/workflows/ci.yml/runs?per_page=50&event=pull_request" \
            | jq --arg sha "$TARGET_SHA" -r 'first(.workflow_runs[] | select(.head_sha == $sha) | .id)')

          if [ -n "${run_id:-}" ] && [ "$run_id" != "null" ]; then
            echo "Resolved CI run: $run_id"
            echo "artifact_run_id=$run_id" >> $GITHUB_OUTPUT
          else
            echo "No matching CI run found for $TARGET_SHA"
            echo "artifact_run_id=" >> $GITHUB_OUTPUT
          fi

  deploy:
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.should_deploy == 'true'
    permissions:
      id-token: write
      contents: write
    env:
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      AWS_ROLE_TO_ASSUME: ${{ secrets.AWS_ROLE_TO_ASSUME }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      EC2_HOST_SECRET: ${{ secrets.EC2_HOST }}
      EC2_USER_SECRET: ${{ secrets.EC2_USER }}
      EC2_INSTANCE_ID_SECRET: ${{ secrets.EC2_INSTANCE_ID }}
      CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
      ECOMOS_ENV: ${{ secrets.ECOMOS_ENV }}
      EC2_HOST_PUBLIC_KEY: ${{ secrets.EC2_HOST_PUBLIC_KEY }}
      EC2_HOST_FINGERPRINT: ${{ secrets.EC2_HOST_FINGERPRINT }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.target_sha }}
          fetch-depth: 0

      - name: Install tools (ansible, rsync, jq, curl)
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible rsync jq curl

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - run: corepack enable && corepack prepare pnpm@9.0.0 --activate

      - name: Install dependencies for packaging
        if: needs.prepare.outputs.artifact_run_id == ''
        run: pnpm install

      - name: Download CI build artifacts
        if: needs.prepare.outputs.artifact_run_id != ''
        id: download
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ needs.prepare.outputs.target_sha }}
          github-token: ${{ github.token }}
          run-id: ${{ needs.prepare.outputs.artifact_run_id }}
          path: artifacts

      - name: Determine artifact availability
        id: artifact_state
        run: |
          set -euo pipefail
          RUN_ID="${{ needs.prepare.outputs.artifact_run_id }}"
          if [ -z "$RUN_ID" ]; then
            echo "has_artifact=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          DOWNLOAD_PATH="${{ steps.download.outputs.download-path }}"
          TARGET_SHA="${{ needs.prepare.outputs.target_sha }}"
          if [ -n "$DOWNLOAD_PATH" ] && [ -d "$DOWNLOAD_PATH/build-artifacts-${TARGET_SHA}" ]; then
            echo "has_artifact=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_artifact=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Restore build outputs from artifacts
        if: steps.artifact_state.outputs.has_artifact == 'true'
        run: |
          set -euo pipefail
          ARTIFACT_ROOT="${{ steps.download.outputs.download-path }}"
          TARGET_SHA="${{ needs.prepare.outputs.target_sha }}"
          rsync -a "${ARTIFACT_ROOT}/build-artifacts-${TARGET_SHA}/" ./

      - name: Generate Prisma clients and build (fallback)
        if: steps.artifact_state.outputs.has_artifact != 'true'
        run: |
          pnpm --filter @ecom-os/auth prisma:generate
          pnpm --filter @ecom-os/wms db:generate
          pnpm --filter @ecom-os/x-plan prisma:generate
          pnpm --filter @ecom-os/website build
          pnpm --filter @ecom-os/ecomos build
          BASE_PATH=/wms NEXT_PUBLIC_BASE_PATH=/wms NEXTAUTH_URL=https://example.com/wms/api/auth NEXT_PUBLIC_APP_URL=https://example.com/wms NEXT_PUBLIC_CENTRAL_AUTH_URL=https://example.com CENTRAL_AUTH_URL=https://example.com CENTRAL_AUTH_SECRET=test-central-secret NEXTAUTH_SECRET=test-nextauth-secret CSRF_ALLOWED_ORIGINS=https://example.com,https://example.com/wms DATABASE_URL=postgresql://postgres:postgres@localhost:5432/postgres pnpm --filter @ecom-os/wms build
          BASE_PATH=/xplan NEXT_PUBLIC_BASE_PATH=/xplan NEXTAUTH_URL=https://example.com/xplan/api/auth NEXT_PUBLIC_APP_URL=https://example.com/xplan NEXT_PUBLIC_CENTRAL_AUTH_URL=https://example.com CENTRAL_AUTH_URL=https://example.com CENTRAL_AUTH_SECRET=test-central-secret NEXTAUTH_SECRET=test-nextauth-secret CSRF_ALLOWED_ORIGINS=https://example.com,https://example.com/xplan COOKIE_DOMAIN=.example.com DATABASE_URL=postgresql://postgres:postgres@localhost:5432/postgres pnpm --filter @ecom-os/x-plan build
        env:
          CENTRAL_DB_URL: postgresql://postgres:postgres@localhost:5432/postgres?schema=auth
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/postgres
          NEXTAUTH_SECRET: test-nextauth-secret
          CENTRAL_AUTH_SECRET: test-central-secret
          CENTRAL_AUTH_URL: https://example.com
          NEXTAUTH_URL: https://example.com/api/auth
          COOKIE_DOMAIN: .example.com
          BASE_PATH: /wms
          NEXT_PUBLIC_BASE_PATH: /wms
          NEXT_PUBLIC_APP_URL: https://example.com/wms
          NEXT_PUBLIC_CENTRAL_AUTH_URL: https://example.com
          CSRF_ALLOWED_ORIGINS: https://example.com,https://example.com/wms
          XPLAN_BASE_PATH: /xplan
          NEXT_PUBLIC_XPLAN_BASE_PATH: /xplan

      - name: Validate version consistency
        run: |
          echo "Validating version consistency across monorepo..."
          node scripts/sync-versions.js --check

      - name: Configure SSH
        run: |
          install -m 600 -D /dev/null ~/.ssh/id_rsa
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa

      - name: Optionally assume AWS role and discover EC2 host
        if: ${{ env.AWS_ROLE_TO_ASSUME != '' && env.AWS_REGION != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Discover EC2 host (if AWS creds available)
        if: ${{ env.AWS_ROLE_TO_ASSUME != '' && env.AWS_REGION != '' }}
        run: |
          set -euo pipefail
          if [ -n "${EC2_INSTANCE_ID_SECRET:-}" ]; then
            QUERY_OPTS=(--instance-ids "$EC2_INSTANCE_ID_SECRET")
          else
            QUERY_OPTS=(--filters "Name=instance-state-name,Values=running")
          fi
          read INST_ID INST_AZ INST_IP < <(aws ec2 describe-instances "${QUERY_OPTS[@]}" \
            --query 'Reservations[0].Instances[0].[InstanceId,Placement.AvailabilityZone,PublicIpAddress]' --output text || true)
          if [ -z "${INST_IP:-}" ] || [ "${INST_IP}" = "None" ]; then
            echo "No matching EC2 instance with public IP found via AWS lookup" >&2
            exit 0
          fi
          echo "EC2_HOST=$INST_IP" >> $GITHUB_ENV
          echo "EIC_INSTANCE_ID=$INST_ID" >> $GITHUB_ENV
          echo "EIC_INSTANCE_AZ=$INST_AZ" >> $GITHUB_ENV
          echo "Discovered: id=$INST_ID az=$INST_AZ ip=$INST_IP"

      - name: Fallback to secrets for EC2 host and user (if not discovered)
        run: |
          if [ -z "${EC2_HOST:-}" ]; then
            echo "EC2_HOST=${EC2_HOST_SECRET}" >> $GITHUB_ENV
          fi
          echo "EC2_USER=${EC2_USER_SECRET}" >> $GITHUB_ENV

      - name: Validate EC2 host resolved
        run: |
          if [ -z "${EC2_HOST:-}" ]; then
            echo "::error title=Missing EC2 host::Failed to resolve EC2 host. Provide AWS filters or set EC2_HOST secret." >&2
            exit 1
          fi

      - name: Generate and inject CI SSH key via EC2 Instance Connect
        if: ${{ github.event_name == 'workflow_run' && env.AWS_ROLE_TO_ASSUME != '' && env.AWS_REGION != '' && env.EIC_INSTANCE_ID != '' }}
        continue-on-error: true
        env:
          OS_USER: ${{ env.EC2_USER_SECRET }}
        run: |
          OS_USER=${OS_USER:-ubuntu}
          ssh-keygen -t ed25519 -N '' -f ~/.ssh/ci_key -C ci@github || true
          if ! aws ec2-instance-connect send-ssh-public-key \
            --instance-id "$EIC_INSTANCE_ID" \
            --availability-zone "$EIC_INSTANCE_AZ" \
            --instance-os-user "$OS_USER" \
            --ssh-public-key "file://$HOME/.ssh/ci_key.pub"; then
            echo "::warning title=EIC key injection failed::Continuing with existing SSH credentials" >&2
            exit 0
          fi
          if ! ssh -i ~/.ssh/ci_key "$OS_USER@$EC2_HOST" \
            "mkdir -p ~/.ssh && touch ~/.ssh/authorized_keys && grep -qxF '$(cat ~/.ssh/ci_key.pub)' ~/.ssh/authorized_keys || echo '$(cat ~/.ssh/ci_key.pub)' >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys"; then
            echo "::warning title=EIC SSH propagation failed::Continuing with existing SSH credentials" >&2
            exit 0
          fi
          install -m 600 -D ~/.ssh/ci_key ~/.ssh/id_rsa

      - name: Configure known_hosts entry
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          if [ -z "${EC2_HOST:-}" ]; then
            echo "::error title=Missing EC2 host::EC2_HOST must be resolved before configuring known_hosts." >&2
            exit 1
          fi

          resolved_entries=""

          if [ -n "${EC2_HOST_FINGERPRINT:-}" ]; then
            scan_output=$(ssh-keyscan -T 10 -t ed25519 "$EC2_HOST" 2>/dev/null || true)
            if [ -z "$scan_output" ]; then
              scan_output=$(ssh-keyscan -T 10 "$EC2_HOST" 2>/dev/null || true)
            fi

            if [ -n "$scan_output" ]; then
              while IFS= read -r line; do
                [ -z "$line" ] && continue
                fp=$(printf '%s\n' "$line" | ssh-keygen -lf - | awk 'NR==1 {print $2}')
                if [ "$fp" = "$EC2_HOST_FINGERPRINT" ]; then
                  echo "Matched host key type: $(printf '%s\n' "$line" | awk '{print $2}')"
                  host_token=$(printf '%s\n' "$line" | awk '{print $1}')
                  rest=$(printf '%s\n' "$line" | cut -d' ' -f2-)
                  if [ "$host_token" != "$EC2_HOST" ]; then
                    line="$EC2_HOST $rest"
                  fi
                  resolved_entries+="$line\n"
                fi
              done <<EOF
$scan_output
EOF
            fi
          fi

          if [ -z "$resolved_entries" ] && [ -n "${EC2_HOST_PUBLIC_KEY:-}" ]; then
            while IFS= read -r key_line; do
              [ -z "$key_line" ] && continue
              IFS=' ' read -r provided_host provided_type provided_key provided_rest <<<"$key_line"

              if [ -z "${provided_type:-}" ] || [ -z "${provided_key:-}" ]; then
                echo "::error title=Invalid host key::EC2_HOST_PUBLIC_KEY must contain a host, key type, and key material." >&2
                exit 1
              fi

              target_host="${EC2_HOST:-$provided_host}"

              formatted="$target_host $provided_type $provided_key"
              if [ -n "${provided_rest:-}" ]; then
                formatted="$formatted $provided_rest"
              fi

              if [ -n "${EC2_HOST_FINGERPRINT:-}" ]; then
                derived_fingerprint=$(printf '%s\n' "$formatted" | ssh-keygen -lf - | awk 'NR==1 {print $2}')
                if [ "$derived_fingerprint" != "$EC2_HOST_FINGERPRINT" ]; then
                  echo "::error title=Fingerprint mismatch::Expected $EC2_HOST_FINGERPRINT but derived $derived_fingerprint from EC2_HOST_PUBLIC_KEY." >&2
                  exit 1
                fi
              fi

              resolved_entries+="$formatted\n"

              if [ "$target_host" != "$provided_host" ] && [ -n "$provided_host" ] && [ "${provided_host#|}" = "$provided_host" ]; then
                resolved_entries+="$key_line\n"
              fi
            done <<<"$EC2_HOST_PUBLIC_KEY"
          fi

          if [ -z "$resolved_entries" ]; then
            echo "::error title=Unable to resolve host key::Provide EC2_HOST_PUBLIC_KEY/EC2_HOST_FINGERPRINT or ensure ssh-keyscan succeeds." >&2
            exit 1
          fi

          printf '%b' "$resolved_entries" > ~/.ssh/known_hosts

          echo "Recorded host keys for $EC2_HOST (fingerprint $EC2_HOST_FINGERPRINT):"
          ssh-keygen -lf ~/.ssh/known_hosts

          chmod 644 ~/.ssh/known_hosts

      - name: Check remote disk usage before deploy
        continue-on-error: true
        env:
          OS_USER: ${{ env.EC2_USER_SECRET }}
        run: |
          set -e
          OS_USER=${OS_USER:-${EC2_USER:-ubuntu}}
          ssh "$OS_USER@$EC2_HOST" bash <<'EOS'
          set -e
          df -h
          echo
          echo "Top-level usage:"
          sudo du -sh /opt/ecom-os /var/log || true
          echo
          echo "/opt/ecom-os breakdown:"
          sudo du -sh /opt/ecom-os/* 2>/dev/null | sort -hr | head || true
          echo
          echo "User cache breakdown:"
          sudo du -sh "$HOME/.local/share/pnpm" "$HOME/.local/state/pnpm" "$HOME/.pnpm-store" 2>/dev/null || true
          sudo du -sh "$HOME/.cache" 2>/dev/null | sort -hr | head || true
          echo
          echo "PM2 logs:"
          sudo du -sh "$HOME/.pm2/logs" 2>/dev/null || true
          EOS

      - name: Update Cloudflare DNS (apex + www) to EC2
        continue-on-error: true
        env:
          CF_API_TOKEN: ${{ env.CF_API_TOKEN }}
          CF_ZONE_NAME: targonglobal.com
        run: |
          set -e
          if [ -z "${CF_API_TOKEN:-}" ]; then echo "No CF_API_TOKEN provided; skipping DNS update"; exit 0; fi
          echo "Fetching Cloudflare Zone ID for $CF_ZONE_NAME"
          ZONE_RESP=$(curl -s -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" \
            "https://api.cloudflare.com/client/v4/zones?name=$CF_ZONE_NAME")
          CF_ZONE_ID=$(echo "$ZONE_RESP" | jq -r '.result[0].id')
          if [ -z "$CF_ZONE_ID" ] || [ "$CF_ZONE_ID" = "null" ]; then echo "Zone not found" >&2; exit 1; fi
          upsert_a(){
            local NAME="$1"; local IP="$2"; local PROXIED=${3:-false}
            echo "Upserting A record $NAME -> $IP (proxied=$PROXIED)"
            REC_ID=$(curl -s -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" \
              "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?type=A&name=$NAME" | jq -r '.result[0].id')
            DATA=$(jq -n --arg type A --arg name "$NAME" --arg content "$IP" --argjson proxied $PROXIED '{type:"A",name:$name,content:$content,ttl:120,proxied:$proxied}')
            if [ -n "$REC_ID" ] && [ "$REC_ID" != "null" ]; then
              curl -s -X PUT -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" \
                "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records/$REC_ID" --data "$DATA" | jq -r '.success'
            else
              curl -s -X POST -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" \
                "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" --data "$DATA" | jq -r '.success'
            fi
          }
          upsert_a "$CF_ZONE_NAME" "$EC2_HOST" false
          upsert_a "www.$CF_ZONE_NAME" "$EC2_HOST" false
          upsert_a "ecomos.$CF_ZONE_NAME" "$EC2_HOST" false
          upsert_a "wms.$CF_ZONE_NAME" "$EC2_HOST" false

      - name: Write inventory
        run: |
          mkdir -p infra/ansible/inventory
          echo "[mono]" > infra/ansible/inventory/hosts.ini
          USER_VAL=${EC2_USER:-ubuntu}
          echo "$EC2_HOST ansible_user=$USER_VAL" >> infra/ansible/inventory/hosts.ini

      - name: Show ansible version
        run: ansible --version && ansible-galaxy collection list || true

      - name: Ansible ping EC2
        env:
          ANSIBLE_HOST_KEY_CHECKING: 'True'
          ANSIBLE_SSH_COMMON_ARGS: "-o StrictHostKeyChecking=yes -o ServerAliveInterval=30 -o ConnectionAttempts=10"
        run: |
          echo "[mono]" > infra/ansible/inventory/hosts.ini
          echo "$EC2_HOST ansible_user=${EC2_USER:-ubuntu}" >> infra/ansible/inventory/hosts.ini
          ansible -vvv -i infra/ansible/inventory/hosts.ini mono -m ping

      - name: Deploy via Ansible (monorepo)
        env:
          ANSIBLE_HOST_KEY_CHECKING: 'True'
          ANSIBLE_STDOUT_CALLBACK: debug
          ANSIBLE_SSH_COMMON_ARGS: "-o StrictHostKeyChecking=yes -o ServerAliveInterval=30 -o ConnectionAttempts=10"
          DEPLOY_COMMIT: ${{ needs.prepare.outputs.target_sha }}
          WEBSITE_ENV: ${{ secrets.WEBSITE_ENV }}
          WMS_ENV: ${{ secrets.WMS_ENV }}
          HRMS_ENV: ${{ secrets.HRMS_ENV }}
          FCC_ENV: ${{ secrets.FCC_ENV }}
          CENTRAL_DB_ENV: ${{ secrets.CENTRAL_DB_ENV }}
          MARGIN_MASTER_ENV: ${{ secrets.MARGIN_MASTER_ENV }}
          JASON_ENV: ${{ secrets.JASON_ENV }}
          ECOMOS_ENV: ${{ secrets.ECOMOS_ENV }}
          XPLAN_ENV: ${{ secrets.XPLAN_ENV }}
        run: |
          set -e
          echo "Inventory:" && cat infra/ansible/inventory/hosts.ini
          ansible-playbook -vvv -i infra/ansible/inventory/hosts.ini infra/ansible/deploy-monorepo.yml

      - name: Health check critical services
        id: health_check
        run: |
          set -euo pipefail
          declare -A CHECKS=(
            [website]="https://www.targonglobal.com/"
            [portal]="https://ecomos.targonglobal.com/login"
            [wms]="https://ecomos.targonglobal.com/wms/api/health"
            [xplan]="https://ecomos.targonglobal.com/xplan"
          )
          failures=0
          for name in "${!CHECKS[@]}"; do
            url="${CHECKS[$name]}"
            echo "Checking $name => $url"
            if ! curl -fsS --max-time 15 "$url" >/dev/null; then
              echo "::warning title=Health check failed::$name at $url did not return 200" >&2
              failures=$((failures+1))
            fi
          done
          if [ "$failures" -gt 0 ]; then
            echo "⚠️  Warning: $failures health check(s) failed" >> $GITHUB_STEP_SUMMARY
          else
            echo "All health checks passed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create GitHub Release
        if: success() || failure()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          VERSION=$(node -p "require('./package.json').version")
          DEPLOYED_APPS=""
          if [ -d apps/wms/.next ]; then
            DEPLOYED_APPS="${DEPLOYED_APPS}- WMS v${VERSION}\n"
          fi
          if [ -d apps/website/.next ]; then
            DEPLOYED_APPS="${DEPLOYED_APPS}- Website v${VERSION}\n"
          fi
          if [ -d apps/ecomos/.next ]; then
            DEPLOYED_APPS="${DEPLOYED_APPS}- Ecomos v${VERSION}\n"
          fi
          if [ -d apps/x-plan/.next ]; then
            DEPLOYED_APPS="${DEPLOYED_APPS}- X-Plan v${VERSION}\n"
          fi
          HEALTH_STATUS="✓ Passed"
          if [ "${{ steps.health_check.outcome }}" != "success" ]; then
            HEALTH_STATUS="⚠️  Issues detected"
          fi
          RELEASE_NOTES="## Deployed Applications\n\n${DEPLOYED_APPS}\n## Deployment Info\n\n- **Commit**: ${{ needs.prepare.outputs.target_sha }}\n- **Deployed at**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")\n- **Triggered by**: ${{ github.actor }}\n- **Health Checks**: ${HEALTH_STATUS}\n\n## Changes\n\nSee commit history for details.\n"
          if echo "$DEPLOYED_APPS" | grep -q "WMS"; then
            TAG="wms-${VERSION}"
            if gh release view "$TAG" &>/dev/null; then
              gh release edit "$TAG" --notes "$RELEASE_NOTES"
            else
              gh release create "$TAG" --title "WMS v${VERSION}" --notes "$RELEASE_NOTES" --target main
            fi
          fi
          if echo "$DEPLOYED_APPS" | grep -q "Website"; then
            TAG="website-${VERSION}"
            if gh release view "$TAG" &>/dev/null; then
              gh release edit "$TAG" --notes "$RELEASE_NOTES"
            else
              gh release create "$TAG" --title "Website v${VERSION}" --notes "$RELEASE_NOTES" --target main
            fi
          fi
          if echo "$DEPLOYED_APPS" | grep -q "Ecomos"; then
            TAG="ecomos-${VERSION}"
            if gh release view "$TAG" &>/dev/null; then
              gh release edit "$TAG" --notes "$RELEASE_NOTES"
            else
              gh release create "$TAG" --title "Ecomos v${VERSION}" --notes "$RELEASE_NOTES" --target main
            fi
          fi
          if echo "$DEPLOYED_APPS" | grep -q "X-Plan"; then
            TAG="x-plan-${VERSION}"
            if gh release view "$TAG" &>/dev/null; then
              gh release edit "$TAG" --notes "$RELEASE_NOTES"
            else
              gh release create "$TAG" --title "X-Plan v${VERSION}" --notes "$RELEASE_NOTES" --target main
            fi
          fi
          echo "✓ GitHub releases created/updated for version ${VERSION}"

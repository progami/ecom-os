This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: apps/hrms/**, packages/prisma-hrms/**, packages/auth/**, packages/ui/**, packages/logger/**, package.json, pnpm-workspace.yaml, turbo.json, tsconfig.base.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
apps/
  hrms/
    app/
      (hrms)/
        calendar/
          page.tsx
        employees/
          [id]/
            edit/
              page.tsx
            page.tsx
          add/
            page.tsx
          page.tsx
        organogram/
          page.tsx
        performance/
          disciplinary/
            [id]/
              page.tsx
            add/
              page.tsx
            page.tsx
          reviews/
            [id]/
              page.tsx
            add/
              page.tsx
            page.tsx
        policies/
          [id]/
            edit/
              page.tsx
            page.tsx
          add/
            page.tsx
          page.tsx
        resources/
          add/
            page.tsx
          page.tsx
        layout.tsx
        page.tsx
      api/
        calendar/
          events/
            route.ts
        dashboard/
          route.ts
        departments/
          [id]/
            route.ts
          hierarchy/
            route.ts
          route.ts
        disciplinary-actions/
          [id]/
            route.ts
          route.ts
        employees/
          [id]/
            projects/
              route.ts
            route.ts
          manageable/
            route.ts
          route.ts
        google-admin/
          sync/
            route.ts
          users/
            route.ts
        health/
          route.ts
        hierarchy/
          route.ts
        hr-calendar/
          [id]/
            route.ts
          route.ts
        notifications/
          route.ts
        performance-reviews/
          [id]/
            route.ts
          route.ts
        policies/
          [id]/
            route.ts
          route.ts
        projects/
          hierarchy/
            route.ts
          route.ts
        resources/
          [id]/
            route.ts
          route.ts
        setup/
          departments/
            route.ts
      globals.css
      layout.tsx
    components/
      leave/
        LeaveBalanceCards.tsx
        LeaveHistoryTable.tsx
        LeaveRequestForm.tsx
      organogram/
        DepartmentOrgChart.tsx
        OrgChart.tsx
        ProjectOrgChart.tsx
      ui/
        Alert.tsx
        Avatar.tsx
        Badge.tsx
        Button.tsx
        Card.tsx
        EmptyState.tsx
        FormField.tsx
        Icons.tsx
        index.ts
        NotificationBell.tsx
        PageHeader.tsx
        SearchForm.tsx
        Table.tsx
      LoadingStates.tsx
    lib/
      api-client.ts
      api-helpers.ts
      auth.ts
      constants.ts
      current-user.ts
      google-admin-sync.ts
      google-admin.ts
      google-calendar.ts
      hrms-prisma-types.ts
      navigation-history.tsx
      notification-service.ts
      permissions.ts
      portal.ts
      prisma.ts
      startup.ts
      utils.ts
      validations.ts
    prisma/
      migrations/
        0001_init/
          migration.sql
        20250914013641_init/
          migration.sql
        20250914025834_roles_and_departments/
          migration.sql
        20251213050000_add_department_hierarchy/
          migration.sql
        migration_lock.toml
      seed/
        employees.json
        employees.sample.json
        policies.sample.json
        resources.sample.json
      schema.prisma
      seed-departments.ts
      seed.ts
    scripts/
      bootstrap-db.sql
    types/
      googleapis.d.ts
    .eslintrc.json
    .gitignore
    agents.json
    CLAUDE.md
    instrumentation.ts
    leave_policy_backup.csv
    leave_policy_content_backup.txt
    middleware.ts
    next-env.d.ts
    next.config.js
    package.json
    postcss.config.js
    README.md
    tailwind.config.js
    tsconfig.json
packages/
  auth/
    dist/
      db.d.ts
      db.js
      index.d.ts
      index.js
      server.d.ts
      server.js
      user-service.d.ts
      user-service.js
    prisma/
      schema.prisma
      seed.ts
    src/
      db.ts
      index.ts
      server.ts
      user-service.ts
    types/
      bcryptjs.d.ts
    .gitignore
    package.json
    tsconfig.build.json
    tsconfig.json
  logger/
    src/
      index.ts
    package.json
    tsconfig.build.json
    tsconfig.json
  prisma-hrms/
    package.json
  ui/
    src/
      index.tsx
    package.json
    tsconfig.build.json
    tsconfig.json
package.json
pnpm-workspace.yaml
tsconfig.base.json
turbo.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/hrms/app/(hrms)/resources/page.tsx">
'use client'

import { useCallback, useEffect, useState } from 'react'
import { ResourcesApi, type Resource } from '@/lib/api-client'
import { FolderIcon, PlusIcon, ExternalLinkIcon } from '@/components/ui/Icons'
import { ListPageHeader } from '@/components/ui/PageHeader'
import { Button } from '@/components/ui/Button'
import { Card } from '@/components/ui/Card'
import { SearchForm } from '@/components/ui/SearchForm'
import {
  Table,
  TableHeader,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  TableSkeleton,
  ResultsCount,
} from '@/components/ui/Table'
import { TableEmptyState } from '@/components/ui/EmptyState'

export default function ResourcesPage() {
  const [items, setItems] = useState<Resource[]>([])
  const [q, setQ] = useState('')
  const [loading, setLoading] = useState(true)

  const load = useCallback(async () => {
    try {
      setLoading(true)
      const data = await ResourcesApi.list({ q })
      setItems(data.items || [])
    } catch (e) {
      console.error('Failed to load resources', e)
      setItems([])
    } finally {
      setLoading(false)
    }
  }, [q])

  useEffect(() => {
    load()
  }, [load])

  return (
    <>
      <ListPageHeader
        title="Service Providers"
        description="Manage company resources and vendors"
        icon={<FolderIcon className="h-6 w-6 text-white" />}
        action={
          <Button href="/resources/add" icon={<PlusIcon className="h-4 w-4" />}>
            Add Resource
          </Button>
        }
      />

      <div className="space-y-6">
        {/* Search */}
        <Card padding="md">
          <SearchForm
            value={q}
            onChange={setQ}
            onSubmit={load}
            placeholder="Search resources..."
          />
        </Card>

        {/* Results count */}
        <ResultsCount
          count={items.length}
          singular="resource"
          plural="resources"
          loading={loading}
        />

        {/* Table */}
        <Table>
          <TableHeader>
            <TableHead>Name</TableHead>
            <TableHead>Category</TableHead>
            <TableHead>Subcategory</TableHead>
            <TableHead>Website</TableHead>
          </TableHeader>
          <TableBody>
            {loading ? (
              <TableSkeleton rows={5} columns={4} />
            ) : items.length === 0 ? (
              <TableEmptyState
                colSpan={4}
                icon={<FolderIcon className="h-10 w-10" />}
                title="No resources found"
                action={{
                  label: 'Add your first resource',
                  href: '/resources/add',
                }}
              />
            ) : (
              items.map((r) => (
                <TableRow key={r.id} hoverable>
                  <TableCell className="font-medium text-slate-900">{r.name}</TableCell>
                  <TableCell className="text-slate-600">{r.category}</TableCell>
                  <TableCell className="text-slate-500">{r.subcategory || '—'}</TableCell>
                  <TableCell>
                    {r.website ? (
                      <a
                        href={r.website}
                        target="_blank"
                        rel="noreferrer"
                        className="inline-flex items-center gap-1.5 text-sm text-cyan-600 hover:text-cyan-700"
                      >
                        <span className="truncate max-w-[180px]">{r.website.replace(/^https?:\/\//, '')}</span>
                        <ExternalLinkIcon className="h-3.5 w-3.5 flex-shrink-0" />
                      </a>
                    ) : (
                      <span className="text-slate-400">—</span>
                    )}
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/api/calendar/events/route.ts">
import { NextResponse } from 'next/server'
import { isCalendarConfigured, listUpcomingEvents, createEvent } from '@/lib/google-calendar'
import { CreateCalendarEventSchema } from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'

export async function GET(req: Request) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    if (!isCalendarConfigured()) {
      return NextResponse.json({ items: [], note: 'Google Calendar not configured' }, { status: 200 })
    }

    const items = await listUpcomingEvents({ maxResults: 25 })

    // Normalize minimal fields for client - only expose safe fields
    const normalized = items.map((e: Record<string, unknown>) => ({
      id: e.id,
      summary: e.summary,
      description: e.description,
      location: e.location,
      start: e.start,
      end: e.end,
      htmlLink: e.htmlLink,
    }))

    return NextResponse.json({ items: normalized })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to load events')
  }
}

export async function POST(req: Request) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    if (!isCalendarConfigured()) {
      return NextResponse.json({ error: 'Google Calendar not configured' }, { status: 400 })
    }

    const body = await req.json()

    // Validate input
    const validation = validateBody(CreateCalendarEventSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data

    const event = await createEvent({
      summary: data.summary,
      description: data.description,
      location: data.location,
      start: data.start,
      end: data.end,
    })

    return NextResponse.json(event, { status: 201 })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to create event')
  }
}
</file>

<file path="apps/hrms/app/api/employees/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'
import { EmploymentType, EmployeeStatus, TransactionClient } from '@/lib/hrms-prisma-types'
import {
  CreateEmployeeSchema,
  PaginationSchema,
  MAX_PAGINATION_LIMIT,
  EmployeeStatusEnum,
  EmploymentTypeEnum,
} from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'

export async function GET(req: Request) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { searchParams } = new URL(req.url)

    // Validate pagination params
    const paginationResult = PaginationSchema.safeParse({
      take: searchParams.get('take') || undefined,
      skip: searchParams.get('skip') || undefined,
      q: searchParams.get('q') || undefined,
    })

    const take = paginationResult.success ? paginationResult.data.take : 50
    const skip = paginationResult.success ? paginationResult.data.skip : 0
    const q = paginationResult.success ? paginationResult.data.q?.toLowerCase() : ''

    const where: Record<string, unknown> = {}

    if (q) {
      where.OR = [
        { firstName: { contains: q, mode: 'insensitive' } },
        { lastName: { contains: q, mode: 'insensitive' } },
        { email: { contains: q, mode: 'insensitive' } },
        { employeeId: { contains: q, mode: 'insensitive' } },
      ]
    }

    const employeeId = searchParams.get('employeeId')
    if (employeeId) where.employeeId = employeeId

    const department = searchParams.get('department')
    if (department) where.department = department

    // Validate status enum
    const statusParam = searchParams.get('status')
    if (statusParam) {
      const statusValidation = EmployeeStatusEnum.safeParse(statusParam.toUpperCase())
      if (statusValidation.success) {
        where.status = statusValidation.data
      }
    }

    // Validate employmentType enum
    const employmentTypeParam = searchParams.get('employmentType')
    if (employmentTypeParam) {
      const typeValidation = EmploymentTypeEnum.safeParse(employmentTypeParam.toUpperCase())
      if (typeValidation.success) {
        where.employmentType = typeValidation.data
      }
    }

    const [items, total] = await Promise.all([
      prisma.employee.findMany({
        where,
        take: Math.min(take, MAX_PAGINATION_LIMIT),
        skip,
        orderBy: { createdAt: 'desc' },
        include: { roles: true, dept: true },
      }),
      prisma.employee.count({ where }),
    ])

    return NextResponse.json({ items, total })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch employees')
  }
}

export async function POST(req: Request) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const body = await req.json()

    // Validate input
    const validation = validateBody(CreateEmployeeSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data
    const departmentName = data.department || data.departmentName || 'General'
    const roles = data.roles || []

    // Auto-generate employeeId if not provided
    let employeeId = data.employeeId
    if (!employeeId) {
      const lastEmployee = await prisma.employee.findFirst({
        orderBy: { createdAt: 'desc' },
        select: { employeeId: true },
      })
      const lastNum = lastEmployee?.employeeId?.match(/EMP(\d+)/)?.[1]
      const nextNum = lastNum ? parseInt(lastNum, 10) + 1 : 1
      employeeId = `EMP${String(nextNum).padStart(3, '0')}`
    }

    // Use transaction for atomic operation
    const emp = await prisma.$transaction(async (tx: TransactionClient) => {
      return tx.employee.create({
        data: {
          employeeId,
          firstName: data.firstName,
          lastName: data.lastName,
          email: data.email,
          phone: data.phone ?? null,
          department: departmentName,
          position: data.position,
          employmentType: data.employmentType as EmploymentType,
          joinDate: new Date(data.joinDate),
          status: data.status as EmployeeStatus,
          dept: {
            connectOrCreate: {
              where: { name: departmentName },
              create: { name: departmentName },
            },
          },
          roles: roles.length
            ? {
                connectOrCreate: roles.map((name) => ({
                  where: { name },
                  create: { name },
                })),
              }
            : undefined,
        },
        include: { roles: true, dept: true },
      })
    })

    return NextResponse.json(emp, { status: 201 })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to create employee')
  }
}
</file>

<file path="apps/hrms/app/api/health/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'

export async function GET() {
  try {
    const [employees, resources, policies] = await Promise.all([
      prisma.employee.count(),
      prisma.resource.count(),
      prisma.policy.count(),
    ])
    return NextResponse.json({ ok: true, employees, resources, policies })
  } catch (e) {
    // Don't expose internal error details in health check
    console.error('[HRMS Health] Database error:', e instanceof Error ? e.message : e)
    return NextResponse.json({ ok: false, error: 'DB not reachable' }, { status: 500 })
  }
}
</file>

<file path="apps/hrms/app/api/resources/[id]/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../lib/prisma'
import { UpdateResourceSchema } from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'

type ResourceRouteContext = { params: Promise<{ id: string }> }

export async function GET(req: Request, context: ResourceRouteContext) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const r = await prisma.resource.findUnique({ where: { id } })

    if (!r) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    return NextResponse.json(r)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch resource')
  }
}

export async function PATCH(req: Request, context: ResourceRouteContext) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const body = await req.json()

    // Validate input with whitelist schema
    const validation = validateBody(UpdateResourceSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data

    // Build update object with explicit field whitelist
    const updates: Record<string, unknown> = {}

    if (data.name !== undefined) updates.name = data.name
    if (data.category !== undefined) updates.category = data.category
    if (data.subcategory !== undefined) updates.subcategory = data.subcategory
    if (data.email !== undefined) updates.email = data.email
    if (data.phone !== undefined) updates.phone = data.phone
    if (data.website !== undefined) updates.website = data.website
    if (data.description !== undefined) updates.description = data.description
    if (data.rating !== undefined) updates.rating = data.rating

    const r = await prisma.resource.update({
      where: { id },
      data: updates,
    })

    return NextResponse.json(r)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to update resource')
  }
}

export async function DELETE(req: Request, context: ResourceRouteContext) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    await prisma.resource.delete({ where: { id } })
    return NextResponse.json({ ok: true })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to delete resource')
  }
}
</file>

<file path="apps/hrms/app/api/resources/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'
import {
  CreateResourceSchema,
  PaginationSchema,
  MAX_PAGINATION_LIMIT,
  ResourceCategoryEnum,
} from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'

export async function GET(req: Request) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { searchParams } = new URL(req.url)

    // Validate pagination params
    const paginationResult = PaginationSchema.safeParse({
      take: searchParams.get('take') || undefined,
      skip: searchParams.get('skip') || undefined,
      q: searchParams.get('q') || undefined,
    })

    const take = paginationResult.success ? paginationResult.data.take : 50
    const skip = paginationResult.success ? paginationResult.data.skip : 0
    const q = paginationResult.success ? paginationResult.data.q?.toLowerCase() : ''

    // Parse subcategories
    const subs = [...searchParams.getAll('subcategory')]
    const csv = (searchParams.get('subcategories') || '')
      .split(',')
      .map((s) => s.trim())
      .filter(Boolean)
    const subcategories = [...subs, ...csv].slice(0, 20) // Limit to 20 subcategories

    const where: Record<string, unknown> = {}

    if (q) {
      where.OR = [
        { name: { contains: q, mode: 'insensitive' } },
        { description: { contains: q, mode: 'insensitive' } },
      ]
    }

    // Validate category enum
    const categoryParam = searchParams.get('category')
    if (categoryParam) {
      const categoryValidation = ResourceCategoryEnum.safeParse(categoryParam.toUpperCase())
      if (categoryValidation.success) {
        where.category = categoryValidation.data
      }
    }

    if (subcategories.length) {
      where.subcategory = { in: subcategories }
    }

    const [items, total] = await Promise.all([
      prisma.resource.findMany({
        where,
        take: Math.min(take, MAX_PAGINATION_LIMIT),
        skip,
        orderBy: { createdAt: 'desc' },
      }),
      prisma.resource.count({ where }),
    ])

    return NextResponse.json({ items, total })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch resources')
  }
}

export async function POST(req: Request) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const body = await req.json()

    // Validate input
    const validation = validateBody(CreateResourceSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data

    // Check for duplicate by website if provided
    if (data.website) {
      const existing = await prisma.resource.findFirst({
        where: { website: data.website },
      })
      if (existing) {
        return NextResponse.json(
          { error: 'A resource with this website already exists', existing },
          { status: 409 }
        )
      }
    }

    const item = await prisma.resource.create({
      data: {
        name: data.name,
        category: data.category,
        subcategory: data.subcategory ?? null,
        email: data.email ?? null,
        phone: data.phone ?? null,
        website: data.website ?? null,
        description: data.description ?? null,
        rating: data.rating ?? null,
      },
    })

    return NextResponse.json(item, { status: 201 })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to create resource')
  }
}
</file>

<file path="apps/hrms/app/layout.tsx">
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const appBasePath = process.env.NEXT_PUBLIC_BASE_PATH || process.env.BASE_PATH || ''

const inter = Inter({
  subsets: ['latin'],
  variable: '--font-sans',
})

export const metadata: Metadata = {
  title: 'HRMS',
  description: 'Human Resource Management System',
  icons: {
    icon: `${appBasePath || ''}/favicon.ico`,
  },
}

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={`${inter.variable} font-sans`}>{children}</body>
    </html>
  )
}
</file>

<file path="apps/hrms/components/ui/Alert.tsx">
import { CheckCircleIcon, ExclamationCircleIcon, XIcon } from './Icons'

type AlertVariant = 'success' | 'error' | 'warning' | 'info'

type AlertProps = {
  variant?: AlertVariant
  title?: string
  children: React.ReactNode
  onDismiss?: () => void
  className?: string
}

const variantStyles: Record<AlertVariant, { bg: string; border: string; text: string; icon: string }> = {
  success: {
    bg: 'bg-green-50',
    border: 'border-green-200',
    text: 'text-green-800',
    icon: 'text-green-500',
  },
  error: {
    bg: 'bg-red-50',
    border: 'border-red-200',
    text: 'text-red-800',
    icon: 'text-red-500',
  },
  warning: {
    bg: 'bg-yellow-50',
    border: 'border-yellow-200',
    text: 'text-yellow-800',
    icon: 'text-yellow-500',
  },
  info: {
    bg: 'bg-blue-50',
    border: 'border-blue-200',
    text: 'text-blue-800',
    icon: 'text-blue-500',
  },
}

const variantIcons: Record<AlertVariant, React.ReactNode> = {
  success: <CheckCircleIcon className="h-5 w-5" />,
  error: <ExclamationCircleIcon className="h-5 w-5" />,
  warning: <ExclamationCircleIcon className="h-5 w-5" />,
  info: <ExclamationCircleIcon className="h-5 w-5" />,
}

export function Alert({
  variant = 'info',
  title,
  children,
  onDismiss,
  className = '',
}: AlertProps) {
  const styles = variantStyles[variant]

  return (
    <div className={`${styles.bg} ${styles.border} border rounded-lg p-4 ${className}`}>
      <div className="flex gap-3">
        <div className={styles.icon}>
          {variantIcons[variant]}
        </div>
        <div className="flex-1 min-w-0">
          {title && (
            <h3 className={`text-sm font-medium ${styles.text} mb-1`}>{title}</h3>
          )}
          <div className={`text-sm ${styles.text}`}>{children}</div>
        </div>
        {onDismiss && (
          <button
            onClick={onDismiss}
            className={`${styles.text} hover:opacity-70 transition-opacity`}
          >
            <XIcon className="h-5 w-5" />
          </button>
        )}
      </div>
    </div>
  )
}
</file>

<file path="apps/hrms/components/ui/Badge.tsx">
type BadgeVariant = 'success' | 'warning' | 'error' | 'info' | 'default'

type BadgeProps = {
  children: React.ReactNode
  variant?: BadgeVariant
  className?: string
}

const variantStyles: Record<BadgeVariant, string> = {
  success: 'bg-green-100 text-green-700',
  warning: 'bg-yellow-100 text-yellow-700',
  error: 'bg-red-100 text-red-700',
  info: 'bg-blue-100 text-blue-700',
  default: 'bg-slate-100 text-slate-600',
}

export function Badge({ children, variant = 'default', className = '' }: BadgeProps) {
  return (
    <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${variantStyles[variant]} ${className}`}>
      {children}
    </span>
  )
}

// Helper to get variant from status string
export function getStatusVariant(status: string): BadgeVariant {
  const s = status.toLowerCase()
  if (s === 'active' || s === 'published' || s === 'approved') return 'success'
  if (s === 'draft' || s === 'pending' || s === 'review') return 'warning'
  if (s === 'archived' || s === 'inactive' || s === 'suspended') return 'default'
  if (s === 'rejected' || s === 'error' || s === 'failed') return 'error'
  return 'info'
}

// Convenience component for status badges
type StatusBadgeProps = {
  status: string
  className?: string
}

export function StatusBadge({ status, className = '' }: StatusBadgeProps) {
  return (
    <Badge variant={getStatusVariant(status)} className={className}>
      {status}
    </Badge>
  )
}
</file>

<file path="apps/hrms/components/ui/Button.tsx">
import Link from 'next/link'
import { SpinnerIcon } from './Icons'

type ButtonVariant = 'primary' | 'secondary' | 'ghost' | 'danger'
type ButtonSize = 'sm' | 'md' | 'lg'

type ButtonProps = {
  children: React.ReactNode
  variant?: ButtonVariant
  size?: ButtonSize
  href?: string
  disabled?: boolean
  loading?: boolean
  type?: 'button' | 'submit' | 'reset'
  onClick?: () => void
  className?: string
  icon?: React.ReactNode
}

const variantStyles: Record<ButtonVariant, string> = {
  primary: 'bg-cyan-600 text-white hover:bg-cyan-700 focus:ring-cyan-500',
  secondary: 'bg-white text-slate-700 border border-slate-200 hover:bg-slate-50 focus:ring-slate-500',
  ghost: 'text-slate-600 hover:bg-slate-100 hover:text-slate-900 focus:ring-slate-500',
  danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
}

const sizeStyles: Record<ButtonSize, string> = {
  sm: 'px-3 py-1.5 text-xs',
  md: 'px-4 py-2 text-sm',
  lg: 'px-5 py-2.5 text-base',
}

export function Button({
  children,
  variant = 'primary',
  size = 'md',
  href,
  disabled = false,
  loading = false,
  type = 'button',
  onClick,
  className = '',
  icon,
}: ButtonProps) {
  const baseStyles = 'inline-flex items-center justify-center gap-2 font-medium rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed'

  const combinedClassName = `${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${className}`

  const content = (
    <>
      {loading ? (
        <SpinnerIcon className="h-4 w-4 animate-spin" />
      ) : icon ? (
        icon
      ) : null}
      {children}
    </>
  )

  if (href && !disabled) {
    return (
      <Link href={href} className={combinedClassName}>
        {content}
      </Link>
    )
  }

  return (
    <button
      type={type}
      disabled={disabled || loading}
      onClick={onClick}
      className={combinedClassName}
    >
      {content}
    </button>
  )
}

// Icon button for actions like back, edit, delete
type IconButtonProps = {
  icon: React.ReactNode
  onClick?: () => void
  href?: string
  label: string
  variant?: 'default' | 'ghost'
  size?: 'sm' | 'md'
  className?: string
}

export function IconButton({
  icon,
  onClick,
  href,
  label,
  variant = 'default',
  size = 'md',
  className = '',
}: IconButtonProps) {
  const sizeClasses = size === 'sm' ? 'h-8 w-8' : 'h-10 w-10'
  const variantClasses = variant === 'ghost'
    ? 'hover:bg-slate-100 text-slate-600 hover:text-slate-900'
    : 'border border-slate-200 hover:bg-slate-50 text-slate-600'

  const baseClasses = `flex items-center justify-center rounded-lg transition-colors ${sizeClasses} ${variantClasses} ${className}`

  if (href) {
    return (
      <Link href={href} className={baseClasses} aria-label={label}>
        {icon}
      </Link>
    )
  }

  return (
    <button onClick={onClick} className={baseClasses} aria-label={label}>
      {icon}
    </button>
  )
}
</file>

<file path="apps/hrms/components/ui/Card.tsx">
type CardProps = {
  children: React.ReactNode
  className?: string
  padding?: 'none' | 'sm' | 'md' | 'lg'
  hover?: boolean
}

const paddingStyles = {
  none: '',
  sm: 'p-4',
  md: 'p-6',
  lg: 'p-8',
}

export function Card({
  children,
  className = '',
  padding = 'md',
  hover = false,
}: CardProps) {
  const hoverClass = hover ? 'hover:shadow-md hover:border-slate-300 transition-all duration-200' : ''

  return (
    <div className={`bg-white rounded-xl border border-slate-200 shadow-sm ${paddingStyles[padding]} ${hoverClass} ${className}`}>
      {children}
    </div>
  )
}

// Section divider within cards
export function CardDivider() {
  return <div className="border-t border-slate-200 my-6" />
}

// Card header with title and optional description
type CardHeaderProps = {
  title: string
  description?: string
  action?: React.ReactNode
}

export function CardHeader({ title, description, action }: CardHeaderProps) {
  return (
    <div className="flex items-start justify-between mb-6">
      <div>
        <h3 className="text-base font-semibold text-slate-900">{title}</h3>
        {description && (
          <p className="text-sm text-slate-500 mt-1">{description}</p>
        )}
      </div>
      {action && <div>{action}</div>}
    </div>
  )
}

// Stat card for dashboard
type StatCardProps = {
  title: string
  value: string | number
  icon?: React.ReactNode
  trend?: {
    value: string
    positive: boolean
  }
  className?: string
}

export function StatCard({ title, value, icon, trend, className = '' }: StatCardProps) {
  return (
    <Card padding="md" hover className={className}>
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <p className="text-sm font-medium text-slate-500">{title}</p>
          <p className="text-2xl font-bold text-slate-900 mt-1">{value}</p>
          {trend && (
            <p className={`text-xs mt-2 ${trend.positive ? 'text-green-600' : 'text-red-600'}`}>
              {trend.positive ? '+' : ''}{trend.value}
            </p>
          )}
        </div>
        {icon && (
          <div className="p-2 rounded-lg bg-slate-100">
            {icon}
          </div>
        )}
      </div>
    </Card>
  )
}
</file>

<file path="apps/hrms/components/ui/EmptyState.tsx">
import Link from 'next/link'
import { PlusIcon } from './Icons'

type EmptyStateProps = {
  icon?: React.ReactNode
  title: string
  description?: string
  action?: {
    label: string
    href: string
  }
}

export function EmptyState({ icon, title, description, action }: EmptyStateProps) {
  return (
    <div className="flex flex-col items-center justify-center py-16 px-4">
      {icon && (
        <div className="mb-4 text-slate-300">
          {icon}
        </div>
      )}
      <h3 className="text-sm font-medium text-slate-900 mb-1">{title}</h3>
      {description && (
        <p className="text-sm text-slate-500 text-center max-w-sm mb-4">{description}</p>
      )}
      {action && (
        <Link
          href={action.href}
          className="inline-flex items-center gap-1.5 text-cyan-600 hover:text-cyan-700 text-sm font-medium"
        >
          <PlusIcon className="h-4 w-4" />
          {action.label}
        </Link>
      )}
    </div>
  )
}

// Table empty state (for use inside table body)
type TableEmptyStateProps = {
  colSpan: number
  icon?: React.ReactNode
  title: string
  action?: {
    label: string
    href: string
  }
}

export function TableEmptyState({ colSpan, icon, title, action }: TableEmptyStateProps) {
  return (
    <tr>
      <td colSpan={colSpan} className="px-4 py-16">
        <div className="flex flex-col items-center justify-center">
          {icon && (
            <div className="mb-3 text-slate-300">
              {icon}
            </div>
          )}
          <p className="text-sm text-slate-500 mb-2">{title}</p>
          {action && (
            <Link
              href={action.href}
              className="inline-flex items-center gap-1.5 text-cyan-600 hover:text-cyan-700 text-sm font-medium"
            >
              <PlusIcon className="h-4 w-4" />
              {action.label}
            </Link>
          )}
        </div>
      </td>
    </tr>
  )
}
</file>

<file path="apps/hrms/components/ui/FormField.tsx">
type FormFieldProps = {
  label: string
  name: string
  type?: string
  required?: boolean
  placeholder?: string
  defaultValue?: string
  value?: string
  onChange?: (e: React.ChangeEvent<HTMLInputElement>) => void
  error?: string
  hint?: string
  disabled?: boolean
  children?: React.ReactNode
}

export function FormField({
  label,
  name,
  type = 'text',
  required = false,
  placeholder,
  defaultValue,
  value,
  onChange,
  error,
  hint,
  disabled = false,
  children,
}: FormFieldProps) {
  return (
    <div>
      <label htmlFor={name} className="block text-sm font-medium text-slate-700 mb-1.5">
        {label}
        {required && <span className="text-red-500 ml-0.5">*</span>}
      </label>
      {children || (
        <input
          id={name}
          name={name}
          type={type}
          required={required}
          placeholder={placeholder}
          defaultValue={defaultValue}
          value={value}
          onChange={onChange}
          disabled={disabled}
          className={`w-full px-3 py-2.5 border rounded-lg text-sm transition-all duration-200
            ${error
              ? 'border-red-300 focus:ring-red-500 focus:border-red-500'
              : 'border-slate-200 focus:ring-cyan-500 focus:border-cyan-500'
            }
            ${disabled ? 'bg-slate-50 text-slate-500 cursor-not-allowed' : 'bg-white'}
            focus:outline-none focus:ring-2 focus:ring-offset-0
          `}
        />
      )}
      {hint && !error && (
        <p className="text-xs text-slate-500 mt-1.5">{hint}</p>
      )}
      {error && (
        <p className="text-xs text-red-600 mt-1.5">{error}</p>
      )}
    </div>
  )
}

// Select field
type SelectFieldProps = {
  label: string
  name: string
  required?: boolean
  defaultValue?: string
  value?: string
  onChange?: (e: React.ChangeEvent<HTMLSelectElement>) => void
  error?: string
  disabled?: boolean
  options: { value: string; label: string }[]
  placeholder?: string
}

export function SelectField({
  label,
  name,
  required = false,
  defaultValue,
  value,
  onChange,
  error,
  disabled = false,
  options,
  placeholder,
}: SelectFieldProps) {
  return (
    <div>
      <label htmlFor={name} className="block text-sm font-medium text-slate-700 mb-1.5">
        {label}
        {required && <span className="text-red-500 ml-0.5">*</span>}
      </label>
      <select
        id={name}
        name={name}
        required={required}
        defaultValue={defaultValue}
        value={value}
        onChange={onChange}
        disabled={disabled}
        className={`w-full px-3 py-2.5 border rounded-lg text-sm transition-all duration-200 bg-white
          ${error
            ? 'border-red-300 focus:ring-red-500 focus:border-red-500'
            : 'border-slate-200 focus:ring-cyan-500 focus:border-cyan-500'
          }
          ${disabled ? 'bg-slate-50 text-slate-500 cursor-not-allowed' : ''}
          focus:outline-none focus:ring-2 focus:ring-offset-0
        `}
      >
        {placeholder && <option value="">{placeholder}</option>}
        {options.map((opt) => (
          <option key={opt.value} value={opt.value}>
            {opt.label}
          </option>
        ))}
      </select>
      {error && (
        <p className="text-xs text-red-600 mt-1.5">{error}</p>
      )}
    </div>
  )
}

// Textarea field
type TextareaFieldProps = {
  label: string
  name: string
  required?: boolean
  placeholder?: string
  defaultValue?: string
  value?: string
  onChange?: (e: React.ChangeEvent<HTMLTextAreaElement>) => void
  error?: string
  hint?: string
  disabled?: boolean
  rows?: number
  monospace?: boolean
  resizable?: boolean
}

export function TextareaField({
  label,
  name,
  required = false,
  placeholder,
  defaultValue,
  value,
  onChange,
  error,
  hint,
  disabled = false,
  rows = 4,
  monospace = false,
  resizable = true,
}: TextareaFieldProps) {
  return (
    <div>
      <label htmlFor={name} className="block text-sm font-medium text-slate-700 mb-1.5">
        {label}
        {required && <span className="text-red-500 ml-0.5">*</span>}
      </label>
      <textarea
        id={name}
        name={name}
        required={required}
        placeholder={placeholder}
        defaultValue={defaultValue}
        value={value}
        onChange={onChange}
        disabled={disabled}
        rows={rows}
        className={`w-full px-3 py-2.5 border rounded-lg text-sm transition-all duration-200
          ${error
            ? 'border-red-300 focus:ring-red-500 focus:border-red-500'
            : 'border-slate-200 focus:ring-cyan-500 focus:border-cyan-500'
          }
          ${disabled ? 'bg-slate-50 text-slate-500 cursor-not-allowed' : 'bg-white'}
          ${monospace ? 'font-mono' : ''}
          ${resizable ? 'resize-y' : 'resize-none'}
          focus:outline-none focus:ring-2 focus:ring-offset-0
        `}
      />
      {hint && !error && (
        <p className="text-xs text-slate-500 mt-1.5">{hint}</p>
      )}
      {error && (
        <p className="text-xs text-red-600 mt-1.5">{error}</p>
      )}
    </div>
  )
}

// Form section with title
type FormSectionProps = {
  title: string
  description?: string
  children: React.ReactNode
}

export function FormSection({ title, description, children }: FormSectionProps) {
  return (
    <div className="space-y-4">
      <div>
        <h3 className="text-sm font-semibold text-slate-900">{title}</h3>
        {description && (
          <p className="text-xs text-slate-500 mt-0.5">{description}</p>
        )}
      </div>
      {children}
    </div>
  )
}

// Form actions footer
type FormActionsProps = {
  children: React.ReactNode
}

export function FormActions({ children }: FormActionsProps) {
  return (
    <div className="flex items-center justify-end gap-3 pt-6 border-t border-slate-200">
      {children}
    </div>
  )
}
</file>

<file path="apps/hrms/components/ui/index.ts">
// UI Component exports
export * from './Icons'
export * from './Button'
export * from './Badge'
export * from './Card'
export * from './PageHeader'
export * from './FormField'
export * from './SearchForm'
export * from './EmptyState'
export * from './Table'
export * from './Alert'
</file>

<file path="apps/hrms/components/ui/SearchForm.tsx">
import { SearchIcon } from './Icons'

type SearchFormProps = {
  value: string
  onChange: (value: string) => void
  onSubmit: () => void
  placeholder?: string
  className?: string
}

export function SearchForm({
  value,
  onChange,
  onSubmit,
  placeholder = 'Search...',
  className = '',
}: SearchFormProps) {
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit()
  }

  return (
    <form onSubmit={handleSubmit} className={`flex gap-3 ${className}`}>
      <div className="relative flex-1">
        <SearchIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-slate-400" />
        <input
          type="text"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={placeholder}
          className="w-full pl-10 pr-4 py-2.5 border border-slate-200 rounded-lg text-sm bg-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all"
        />
      </div>
      <button
        type="submit"
        className="px-4 py-2.5 bg-slate-900 text-white rounded-lg text-sm font-medium hover:bg-slate-800 transition-colors"
      >
        Search
      </button>
    </form>
  )
}

// Search with filters variant
type FilterOption = {
  value: string
  label: string
}

type SearchWithFiltersProps = {
  value: string
  onChange: (value: string) => void
  onSubmit: () => void
  placeholder?: string
  filters?: {
    name: string
    value: string
    onChange: (value: string) => void
    options: FilterOption[]
    placeholder?: string
  }[]
}

export function SearchWithFilters({
  value,
  onChange,
  onSubmit,
  placeholder = 'Search...',
  filters = [],
}: SearchWithFiltersProps) {
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit()
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-3">
      <div className="flex gap-3">
        <div className="relative flex-1">
          <SearchIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-slate-400" />
          <input
            type="text"
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder}
            className="w-full pl-10 pr-4 py-2.5 border border-slate-200 rounded-lg text-sm bg-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all"
          />
        </div>
        <button
          type="submit"
          className="px-4 py-2.5 bg-slate-900 text-white rounded-lg text-sm font-medium hover:bg-slate-800 transition-colors"
        >
          Search
        </button>
      </div>
      {filters.length > 0 && (
        <div className="flex flex-wrap gap-3">
          {filters.map((filter) => (
            <select
              key={filter.name}
              value={filter.value}
              onChange={(e) => filter.onChange(e.target.value)}
              className="px-3 py-2 border border-slate-200 rounded-lg text-sm bg-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all"
            >
              {filter.placeholder && (
                <option value="">{filter.placeholder}</option>
              )}
              {filter.options.map((opt) => (
                <option key={opt.value} value={opt.value}>
                  {opt.label}
                </option>
              ))}
            </select>
          ))}
        </div>
      )}
    </form>
  )
}
</file>

<file path="apps/hrms/components/ui/Table.tsx">
type TableProps = {
  children: React.ReactNode
  className?: string
}

export function Table({ children, className = '' }: TableProps) {
  return (
    <div className={`bg-white border border-slate-200 rounded-xl overflow-hidden ${className}`}>
      <div className="overflow-x-auto">
        <table className="w-full">
          {children}
        </table>
      </div>
    </div>
  )
}

export function TableHeader({ children }: { children: React.ReactNode }) {
  return (
    <thead>
      <tr className="border-b border-slate-200 bg-slate-50">
        {children}
      </tr>
    </thead>
  )
}

type TableHeadProps = {
  children: React.ReactNode
  className?: string
  align?: 'left' | 'center' | 'right'
}

export function TableHead({ children, className = '', align = 'left' }: TableHeadProps) {
  const alignClass = {
    left: 'text-left',
    center: 'text-center',
    right: 'text-right',
  }[align]

  return (
    <th className={`px-4 py-3 text-xs font-semibold text-slate-600 uppercase tracking-wider ${alignClass} ${className}`}>
      {children}
    </th>
  )
}

export function TableBody({ children }: { children: React.ReactNode }) {
  return (
    <tbody className="divide-y divide-slate-100">
      {children}
    </tbody>
  )
}

type TableRowProps = {
  children: React.ReactNode
  onClick?: () => void
  className?: string
  hoverable?: boolean
}

export function TableRow({ children, onClick, className = '', hoverable = true }: TableRowProps) {
  const hoverClass = hoverable ? 'hover:bg-slate-50' : ''
  const cursorClass = onClick ? 'cursor-pointer' : ''

  return (
    <tr
      onClick={onClick}
      className={`${hoverClass} ${cursorClass} ${className}`}
    >
      {children}
    </tr>
  )
}

type TableCellProps = {
  children: React.ReactNode
  className?: string
  align?: 'left' | 'center' | 'right'
}

export function TableCell({ children, className = '', align = 'left' }: TableCellProps) {
  const alignClass = {
    left: 'text-left',
    center: 'text-center',
    right: 'text-right',
  }[align]

  return (
    <td className={`px-4 py-4 text-sm ${alignClass} ${className}`}>
      {children}
    </td>
  )
}

// Loading skeleton for table rows
type TableSkeletonProps = {
  rows?: number
  columns: number
}

export function TableSkeleton({ rows = 5, columns }: TableSkeletonProps) {
  return (
    <>
      {Array.from({ length: rows }).map((_, i) => (
        <tr key={i} className="animate-pulse">
          {Array.from({ length: columns }).map((_, j) => (
            <td key={j} className="px-4 py-4">
              <div className="h-4 bg-slate-200 rounded w-3/4" />
            </td>
          ))}
        </tr>
      ))}
    </>
  )
}

// Results count display
type ResultsCountProps = {
  count: number
  singular: string
  plural: string
  loading?: boolean
}

export function ResultsCount({ count, singular, plural, loading = false }: ResultsCountProps) {
  if (loading) {
    return <p className="text-sm text-slate-500">Loading...</p>
  }

  return (
    <p className="text-sm text-slate-500">
      {count} {count === 1 ? singular : plural}
    </p>
  )
}
</file>

<file path="apps/hrms/components/LoadingStates.tsx">
'use client'

export function CardSkeleton() {
  return (
    <div className="dashboard-card p-6 animate-pulse">
      <div className="h-4 bg-slate-200 rounded w-1/3 mb-4"></div>
      <div className="h-8 bg-slate-200 rounded w-2/3 mb-2"></div>
      <div className="h-4 bg-slate-200 rounded w-1/4"></div>
    </div>
  )
}

export function TableRowSkeleton() {
  return (
    <tr className="animate-pulse">
      <td className="px-4 py-4">
        <div className="h-4 bg-slate-200 rounded w-3/4"></div>
      </td>
      <td className="px-4 py-4">
        <div className="h-4 bg-slate-200 rounded w-1/2"></div>
      </td>
      <td className="px-4 py-4">
        <div className="h-4 bg-slate-200 rounded w-2/3"></div>
      </td>
      <td className="px-4 py-4">
        <div className="h-6 bg-slate-200 rounded-full w-20"></div>
      </td>
    </tr>
  )
}

export function PageSkeleton() {
  return (
    <div className="space-y-6 animate-pulse">
      {/* Stats Grid */}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
        {[...Array(3)].map((_, i) => (
          <div key={i} className="dashboard-card p-6">
            <div className="h-4 bg-slate-200 rounded w-24 mb-3"></div>
            <div className="h-8 bg-slate-200 rounded w-16 mb-2"></div>
            <div className="h-3 bg-slate-200 rounded w-20"></div>
          </div>
        ))}
      </div>

      {/* Content Grid */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2 dashboard-card p-6">
          <div className="h-5 bg-slate-200 rounded w-32 mb-4"></div>
          <div className="space-y-3">
            {[...Array(4)].map((_, i) => (
              <div key={i} className="p-3 rounded-lg bg-slate-50">
                <div className="h-4 bg-slate-200 rounded w-3/4 mb-2"></div>
                <div className="h-3 bg-slate-200 rounded w-1/4"></div>
              </div>
            ))}
          </div>
        </div>
        <div className="dashboard-card p-6">
          <div className="h-5 bg-slate-200 rounded w-28 mb-4"></div>
          <div className="space-y-3">
            {[...Array(3)].map((_, i) => (
              <div key={i} className="p-3 rounded-lg border border-slate-200">
                <div className="h-4 bg-slate-200 rounded w-2/3 mb-2"></div>
                <div className="h-3 bg-slate-200 rounded w-1/3"></div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  )
}

export function TableSkeleton({ rows = 5 }: { rows?: number }) {
  return (
    <div className="dashboard-card overflow-hidden">
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead>
            <tr className="border-b border-slate-200 bg-slate-50">
              <th className="text-left px-4 py-3">
                <div className="h-3 bg-slate-200 rounded w-20"></div>
              </th>
              <th className="text-left px-4 py-3">
                <div className="h-3 bg-slate-200 rounded w-24"></div>
              </th>
              <th className="text-left px-4 py-3">
                <div className="h-3 bg-slate-200 rounded w-16"></div>
              </th>
            </tr>
          </thead>
          <tbody className="divide-y divide-slate-200">
            {[...Array(rows)].map((_, i) => (
              <tr key={i}>
                <td className="px-4 py-4">
                  <div className="h-4 bg-slate-200 rounded w-32"></div>
                </td>
                <td className="px-4 py-4">
                  <div className="h-4 bg-slate-200 rounded w-24"></div>
                </td>
                <td className="px-4 py-4">
                  <div className="h-6 bg-slate-200 rounded-full w-16"></div>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}

export function Spinner({ size = 'md', className = '' }: { size?: 'sm' | 'md' | 'lg', className?: string }) {
  const sizeClasses = {
    sm: 'w-4 h-4 border-2',
    md: 'w-6 h-6 border-2',
    lg: 'w-8 h-8 border-3'
  }

  return (
    <div
      className={`animate-spin rounded-full border-cyan-600 border-t-transparent ${sizeClasses[size]} ${className}`}
    />
  )
}

export function LoadingOverlay({ message = 'Loading...' }: { message?: string }) {
  return (
    <div className="fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-50 flex items-center justify-center">
      <div className="bg-white rounded-lg p-6 shadow-soft-lg flex flex-col items-center gap-4">
        <Spinner size="lg" />
        <p className="text-slate-900 font-medium">{message}</p>
      </div>
    </div>
  )
}

export function FullPageLoader({ message = 'Loading...' }: { message?: string }) {
  return (
    <div className="flex flex-col items-center justify-center min-h-[400px]">
      <Spinner size="lg" />
      <p className="mt-4 text-sm text-slate-500">{message}</p>
    </div>
  )
}
</file>

<file path="apps/hrms/lib/api-helpers.ts">
import { NextResponse } from 'next/server'
import { ZodError, ZodSchema } from 'zod'

// Rate limiting - simple in-memory implementation
// For production, use Redis-based solution
const rateLimitMap = new Map<string, { count: number; resetTime: number }>()

const RATE_LIMIT_WINDOW_MS = 60 * 1000 // 1 minute
const RATE_LIMIT_MAX_REQUESTS = 100 // 100 requests per minute

export function getRateLimitKey(request: Request): string {
  // Use X-Forwarded-For header or fall back to a default
  const forwarded = request.headers.get('x-forwarded-for')
  const ip = forwarded?.split(',')[0]?.trim() || 'unknown'
  return ip
}

export function checkRateLimit(key: string): { allowed: boolean; remaining: number; resetIn: number } {
  const now = Date.now()
  const record = rateLimitMap.get(key)

  if (!record || now > record.resetTime) {
    rateLimitMap.set(key, { count: 1, resetTime: now + RATE_LIMIT_WINDOW_MS })
    return { allowed: true, remaining: RATE_LIMIT_MAX_REQUESTS - 1, resetIn: RATE_LIMIT_WINDOW_MS }
  }

  if (record.count >= RATE_LIMIT_MAX_REQUESTS) {
    return { allowed: false, remaining: 0, resetIn: record.resetTime - now }
  }

  record.count++
  return { allowed: true, remaining: RATE_LIMIT_MAX_REQUESTS - record.count, resetIn: record.resetTime - now }
}

export function rateLimitResponse(resetIn: number): NextResponse {
  return NextResponse.json(
    { error: 'Too many requests. Please try again later.' },
    {
      status: 429,
      headers: {
        'Retry-After': String(Math.ceil(resetIn / 1000)),
        'X-RateLimit-Limit': String(RATE_LIMIT_MAX_REQUESTS),
        'X-RateLimit-Remaining': '0',
      },
    }
  )
}

// Clean up old rate limit entries periodically
if (typeof setInterval !== 'undefined') {
  setInterval(() => {
    const now = Date.now()
    for (const [key, record] of rateLimitMap.entries()) {
      if (now > record.resetTime) {
        rateLimitMap.delete(key)
      }
    }
  }, 60 * 1000) // Clean up every minute
}

// Validation helper
export function validateBody<T>(schema: ZodSchema<T>, body: unknown): { success: true; data: T } | { success: false; error: NextResponse } {
  try {
    const data = schema.parse(body)
    return { success: true, data }
  } catch (err) {
    if (err instanceof ZodError) {
      const errors = err.issues.map((e) => ({
        field: e.path.join('.'),
        message: e.message,
      }))
      return {
        success: false,
        error: NextResponse.json({ error: 'Validation failed', details: errors }, { status: 400 }),
      }
    }
    return {
      success: false,
      error: NextResponse.json({ error: 'Invalid request body' }, { status: 400 }),
    }
  }
}

// Safe error response - never expose internal details
export function safeErrorResponse(error: unknown, defaultMessage: string, status: number = 500): NextResponse {
  // Log the actual error server-side
  console.error(`[HRMS API Error] ${defaultMessage}:`, error)

  // Check for known safe errors
  if (error instanceof Error) {
    // Prisma unique constraint violation
    if (error.message.includes('Unique constraint')) {
      return NextResponse.json({ error: 'A record with this identifier already exists' }, { status: 409 })
    }
    // Prisma record not found
    if (error.message.includes('Record to update not found') || error.message.includes('Record to delete does not exist')) {
      return NextResponse.json({ error: 'Record not found' }, { status: 404 })
    }
  }

  // Return generic error message to client
  return NextResponse.json({ error: defaultMessage }, { status })
}

// Apply rate limiting to a request
export function withRateLimit(request: Request): NextResponse | null {
  const key = getRateLimitKey(request)
  const { allowed, remaining, resetIn } = checkRateLimit(key)

  if (!allowed) {
    return rateLimitResponse(resetIn)
  }

  return null // Continue processing
}
</file>

<file path="apps/hrms/lib/auth.ts">
import NextAuth from 'next-auth';
import type { NextAuthConfig } from 'next-auth';
import { applyDevAuthDefaults, withSharedAuth } from '@ecom-os/auth';

// NOTE: Keep providers/callbacks/pages here as HRMS evolves.
if (!process.env.NEXT_PUBLIC_APP_URL) {
  throw new Error('NEXT_PUBLIC_APP_URL must be defined for HRMS auth configuration.')
}
if (!process.env.PORTAL_AUTH_URL) {
  throw new Error('PORTAL_AUTH_URL must be defined for HRMS auth configuration.')
}
if (!process.env.NEXT_PUBLIC_PORTAL_AUTH_URL) {
  throw new Error('NEXT_PUBLIC_PORTAL_AUTH_URL must be defined for HRMS auth configuration.')
}
applyDevAuthDefaults({
  appId: 'hrms',
});

const sharedSecret = process.env.PORTAL_AUTH_SECRET || process.env.NEXTAUTH_SECRET;
if (sharedSecret) {
  process.env.NEXTAUTH_SECRET = sharedSecret;
}

const baseAuthOptions: NextAuthConfig = {
  // Add providers when ready (e.g., Credentials, OIDC)
  providers: [],
  session: { strategy: 'jwt' },
  secret: sharedSecret,
  callbacks: {
    async jwt({ token, user }) {
      if (user && (user as any).id) {
        token.sub = (user as any).id
      }
      return token
    },
    async session({ session, token }) {
      // propagate portal roles for HRMS consumption if needed
      // @ts-expect-error roles claim passthrough
      session.roles = (token as any).roles
      session.user.id = (token.sub as string) || session.user.id
      return session
    },
  },
};

export const authOptions: NextAuthConfig = withSharedAuth(baseAuthOptions, {
  cookieDomain: process.env.COOKIE_DOMAIN || '.targonglobal.com',
  appId: 'hrms',
});

// Initialize NextAuth with config and export handlers + auth function
export const { handlers, auth, signIn, signOut } = NextAuth(authOptions);
</file>

<file path="apps/hrms/lib/google-calendar.ts">
import { google } from 'googleapis'

const CALENDAR_ID = process.env.GOOGLE_CALENDAR_ID || ''
const CLIENT_ID = process.env.GOOGLE_CLIENT_ID || ''
const CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET || ''
const REFRESH_TOKEN = process.env.GOOGLE_REFRESH_TOKEN || ''

const REQUEST_TIMEOUT = 8000 // 8 seconds timeout

export function isCalendarConfigured() {
  return Boolean(CALENDAR_ID && CLIENT_ID && CLIENT_SECRET && REFRESH_TOKEN)
}

function getOAuth2Client() {
  if (!isCalendarConfigured()) {
    throw new Error('Google Calendar not configured. Set GOOGLE_CALENDAR_ID, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_REFRESH_TOKEN')
  }
  const oAuth2Client = new google.auth.OAuth2({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET })
  oAuth2Client.setCredentials({ refresh_token: REFRESH_TOKEN })
  return oAuth2Client
}

export async function listUpcomingEvents(opts?: { maxResults?: number }) {
  const auth = getOAuth2Client()
  const calendar = google.calendar({ version: 'v3', auth })
  const now = new Date().toISOString()
  const res = await calendar.events.list({
    calendarId: CALENDAR_ID,
    timeMin: now,
    maxResults: opts?.maxResults ?? 10,
    singleEvents: true,
    orderBy: 'startTime',
  }, { timeout: REQUEST_TIMEOUT })
  return res.data.items || []
}

export type CreateEventInput = {
  summary: string
  description?: string
  location?: string
  start: { dateTime: string; timeZone?: string }
  end: { dateTime: string; timeZone?: string }
}

export async function createEvent(input: CreateEventInput) {
  const auth = getOAuth2Client()
  const calendar = google.calendar({ version: 'v3', auth })
  const res = await calendar.events.insert({
    calendarId: CALENDAR_ID,
    requestBody: {
      summary: input.summary,
      description: input.description,
      location: input.location,
      start: input.start,
      end: input.end,
    },
  }, { timeout: REQUEST_TIMEOUT })
  return res.data
}
</file>

<file path="apps/hrms/lib/portal.ts">
import { buildPortalUrl, resolvePortalAuthOrigin } from '@ecom-os/auth'

type RequestLike = {
  headers: Headers
  url: string
}

export function portalOrigin(request?: RequestLike, fallbackOrigin?: string) {
  return resolvePortalAuthOrigin({ request, fallbackOrigin })
}

export function portalUrl(path: string, request?: RequestLike, fallbackOrigin?: string) {
  return buildPortalUrl(path, { request, fallbackOrigin })
}
</file>

<file path="apps/hrms/lib/utils.ts">
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// Accessibility helpers
export function announceToScreenReader(message: string) {
  const announcement = document.createElement('div')
  announcement.setAttribute('aria-live', 'polite')
  announcement.setAttribute('aria-atomic', 'true')
  announcement.className = 'sr-only'
  announcement.textContent = message
  document.body.appendChild(announcement)
  setTimeout(() => document.body.removeChild(announcement), 1000)
}

// Keyboard navigation helpers
export const KEYS = {
  ENTER: 'Enter',
  SPACE: ' ',
  ESCAPE: 'Escape',
  ARROW_UP: 'ArrowUp',
  ARROW_DOWN: 'ArrowDown',
  ARROW_LEFT: 'ArrowLeft',
  ARROW_RIGHT: 'ArrowRight',
  TAB: 'Tab',
  HOME: 'Home',
  END: 'End',
}

export function handleKeyboardNavigation(
  e: React.KeyboardEvent,
  callbacks: Partial<Record<string, () => void>>
) {
  const callback = callbacks[e.key]
  if (callback) {
    e.preventDefault()
    callback()
  }
}

// Focus management
export function trapFocus(element: HTMLElement) {
  const focusableElements = element.querySelectorAll(
    'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])'
  )
  const firstFocusable = focusableElements[0] as HTMLElement
  const lastFocusable = focusableElements[focusableElements.length - 1] as HTMLElement

  element.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return

    if (e.shiftKey) {
      if (document.activeElement === firstFocusable) {
        e.preventDefault()
        lastFocusable.focus()
      }
    } else {
      if (document.activeElement === lastFocusable) {
        e.preventDefault()
        firstFocusable.focus()
      }
    }
  })

  firstFocusable?.focus()
}

// Performance monitoring
export function measurePerformance(metricName: string, startMark: string, endMark: string) {
  if (typeof window !== 'undefined' && window.performance) {
    performance.mark(startMark)
    // ... operation to measure
    performance.mark(endMark)
    performance.measure(metricName, startMark, endMark)

    const measure = performance.getEntriesByName(metricName)[0]
    console.log(`${metricName}: ${measure.duration.toFixed(2)}ms`)

    // Clean up
    performance.clearMarks(startMark)
    performance.clearMarks(endMark)
    performance.clearMeasures(metricName)

    return measure.duration
  }
  return 0
}

// Debounce for search inputs
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null

  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      timeout = null
      func(...args)
    }

    if (timeout) clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// Format utilities
export function formatDate(date: Date | string, format: 'short' | 'long' = 'short'): string {
  const d = new Date(date)
  if (format === 'short') {
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })
  }
  return d.toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  })
}

export function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(amount)
}

// Responsive helpers
export function isMobile(): boolean {
  if (typeof window === 'undefined') return false
  return window.innerWidth < 768
}

export function isTablet(): boolean {
  if (typeof window === 'undefined') return false
  return window.innerWidth >= 768 && window.innerWidth < 1024
}

export function isDesktop(): boolean {
  if (typeof window === 'undefined') return false
  return window.innerWidth >= 1024
}
</file>

<file path="apps/hrms/prisma/migrations/0001_init/migration.sql">
-- Create Enums
CREATE TYPE "EmploymentType" AS ENUM ('FULL_TIME','PART_TIME','CONTRACT','INTERN');
CREATE TYPE "EmployeeStatus" AS ENUM ('ACTIVE','ON_LEAVE','TERMINATED','RESIGNED');
CREATE TYPE "ResourceCategory" AS ENUM ('ACCOUNTING','LEGAL','DESIGN','MARKETING','IT','HR','OTHER');
CREATE TYPE "PolicyCategory" AS ENUM ('LEAVE','PERFORMANCE','CONDUCT','SECURITY','COMPENSATION','OTHER');
CREATE TYPE "PolicyStatus" AS ENUM ('DRAFT','ACTIVE','ARCHIVED');

-- Employee
CREATE TABLE "Employee" (
  "id" TEXT PRIMARY KEY,
  "employeeId" TEXT NOT NULL UNIQUE,
  "firstName" TEXT NOT NULL,
  "lastName" TEXT NOT NULL,
  "email" TEXT NOT NULL UNIQUE,
  "phone" TEXT,
  "avatar" TEXT,
  "dateOfBirth" TIMESTAMP(3),
  "gender" TEXT,
  "maritalStatus" TEXT,
  "nationality" TEXT,
  "address" TEXT,
  "city" TEXT,
  "country" TEXT,
  "postalCode" TEXT,
  "department" TEXT NOT NULL,
  "position" TEXT NOT NULL,
  "employmentType" "EmploymentType" NOT NULL DEFAULT 'FULL_TIME',
  "joinDate" TIMESTAMP(3) NOT NULL,
  "status" "EmployeeStatus" NOT NULL DEFAULT 'ACTIVE',
  "reportsTo" TEXT,
  "salary" DOUBLE PRECISION,
  "currency" TEXT NOT NULL DEFAULT 'USD',
  "emergencyContact" TEXT,
  "emergencyPhone" TEXT,
  "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updatedAt" TIMESTAMP(3) NOT NULL
);

CREATE INDEX "Employee_email_idx" ON "Employee" ("email");
CREATE INDEX "Employee_employeeId_idx" ON "Employee" ("employeeId");
CREATE INDEX "Employee_department_idx" ON "Employee" ("department");
CREATE INDEX "Employee_status_idx" ON "Employee" ("status");

-- Resource (Service Providers)
CREATE TABLE "Resource" (
  "id" TEXT PRIMARY KEY,
  "name" TEXT NOT NULL,
  "category" "ResourceCategory" NOT NULL,
  "description" TEXT,
  "contactName" TEXT,
  "email" TEXT,
  "phone" TEXT,
  "website" TEXT,
  "address" TEXT,
  "city" TEXT,
  "country" TEXT,
  "tags" TEXT[] NOT NULL DEFAULT '{}',
  "rating" DOUBLE PRECISION,
  "notes" TEXT,
  "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updatedAt" TIMESTAMP(3) NOT NULL
);

CREATE INDEX "Resource_category_idx" ON "Resource" ("category");
CREATE INDEX "Resource_name_idx" ON "Resource" ("name");

-- Policy
CREATE TABLE "Policy" (
  "id" TEXT PRIMARY KEY,
  "title" TEXT NOT NULL,
  "category" "PolicyCategory" NOT NULL,
  "summary" TEXT,
  "content" TEXT,
  "fileUrl" TEXT,
  "version" TEXT,
  "effectiveDate" TIMESTAMP(3),
  "status" "PolicyStatus" NOT NULL DEFAULT 'ACTIVE',
  "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updatedAt" TIMESTAMP(3) NOT NULL
);

CREATE INDEX "Policy_category_idx" ON "Policy" ("category");
CREATE INDEX "Policy_status_idx" ON "Policy" ("status");
</file>

<file path="apps/hrms/prisma/migrations/20250914013641_init/migration.sql">
-- CreateEnum
CREATE TYPE "EmploymentType" AS ENUM ('FULL_TIME', 'PART_TIME', 'CONTRACT', 'INTERN');

-- CreateEnum
CREATE TYPE "EmployeeStatus" AS ENUM ('ACTIVE', 'ON_LEAVE', 'TERMINATED', 'RESIGNED');

-- CreateEnum
CREATE TYPE "ResourceCategory" AS ENUM ('ACCOUNTING', 'LEGAL', 'DESIGN', 'MARKETING', 'IT', 'HR', 'OTHER');

-- CreateEnum
CREATE TYPE "PolicyCategory" AS ENUM ('LEAVE', 'PERFORMANCE', 'CONDUCT', 'SECURITY', 'COMPENSATION', 'OTHER');

-- CreateEnum
CREATE TYPE "PolicyStatus" AS ENUM ('DRAFT', 'ACTIVE', 'ARCHIVED');

-- CreateTable
CREATE TABLE "Employee" (
    "id" TEXT NOT NULL,
    "employeeId" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "phone" TEXT,
    "avatar" TEXT,
    "dateOfBirth" TIMESTAMP(3),
    "gender" TEXT,
    "maritalStatus" TEXT,
    "nationality" TEXT,
    "address" TEXT,
    "city" TEXT,
    "country" TEXT,
    "postalCode" TEXT,
    "department" TEXT NOT NULL,
    "position" TEXT NOT NULL,
    "employmentType" "EmploymentType" NOT NULL DEFAULT 'FULL_TIME',
    "joinDate" TIMESTAMP(3) NOT NULL,
    "status" "EmployeeStatus" NOT NULL DEFAULT 'ACTIVE',
    "reportsTo" TEXT,
    "salary" DOUBLE PRECISION,
    "currency" TEXT NOT NULL DEFAULT 'USD',
    "emergencyContact" TEXT,
    "emergencyPhone" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Employee_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "EmployeeFile" (
    "id" TEXT NOT NULL,
    "employeeId" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "fileUrl" TEXT NOT NULL,
    "uploadedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "EmployeeFile_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Resource" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "category" "ResourceCategory" NOT NULL,
    "subcategory" TEXT,
    "description" TEXT,
    "contactName" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "website" TEXT,
    "address" TEXT,
    "city" TEXT,
    "country" TEXT,
    "tags" TEXT[],
    "rating" DOUBLE PRECISION,
    "notes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Resource_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Policy" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "category" "PolicyCategory" NOT NULL,
    "summary" TEXT,
    "content" TEXT,
    "fileUrl" TEXT,
    "version" TEXT,
    "effectiveDate" TIMESTAMP(3),
    "status" "PolicyStatus" NOT NULL DEFAULT 'ACTIVE',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Policy_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Employee_employeeId_key" ON "Employee"("employeeId");

-- CreateIndex
CREATE UNIQUE INDEX "Employee_email_key" ON "Employee"("email");

-- CreateIndex
CREATE INDEX "Employee_email_idx" ON "Employee"("email");

-- CreateIndex
CREATE INDEX "Employee_employeeId_idx" ON "Employee"("employeeId");

-- CreateIndex
CREATE INDEX "Employee_department_idx" ON "Employee"("department");

-- CreateIndex
CREATE INDEX "Employee_status_idx" ON "Employee"("status");

-- CreateIndex
CREATE INDEX "EmployeeFile_employeeId_idx" ON "EmployeeFile"("employeeId");

-- CreateIndex
CREATE INDEX "Resource_category_idx" ON "Resource"("category");

-- CreateIndex
CREATE INDEX "Resource_category_subcategory_idx" ON "Resource"("category", "subcategory");

-- CreateIndex
CREATE INDEX "Resource_name_idx" ON "Resource"("name");

-- CreateIndex
CREATE INDEX "Policy_category_idx" ON "Policy"("category");

-- CreateIndex
CREATE INDEX "Policy_status_idx" ON "Policy"("status");

-- AddForeignKey
ALTER TABLE "EmployeeFile" ADD CONSTRAINT "EmployeeFile_employeeId_fkey" FOREIGN KEY ("employeeId") REFERENCES "Employee"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="apps/hrms/prisma/migrations/20250914025834_roles_and_departments/migration.sql">
-- AlterTable
ALTER TABLE "Employee" ADD COLUMN     "departmentId" TEXT;

-- CreateTable
CREATE TABLE "Department" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "code" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Department_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Role" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Role_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_EmployeeToRole" (
    "A" TEXT NOT NULL,
    "B" TEXT NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX "Department_name_key" ON "Department"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Department_code_key" ON "Department"("code");

-- CreateIndex
CREATE UNIQUE INDEX "Role_name_key" ON "Role"("name");

-- CreateIndex
CREATE UNIQUE INDEX "_EmployeeToRole_AB_unique" ON "_EmployeeToRole"("A", "B");

-- CreateIndex
CREATE INDEX "_EmployeeToRole_B_index" ON "_EmployeeToRole"("B");

-- CreateIndex
CREATE INDEX "Employee_departmentId_idx" ON "Employee"("departmentId");

-- AddForeignKey
ALTER TABLE "Employee" ADD CONSTRAINT "Employee_departmentId_fkey" FOREIGN KEY ("departmentId") REFERENCES "Department"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_EmployeeToRole" ADD CONSTRAINT "_EmployeeToRole_A_fkey" FOREIGN KEY ("A") REFERENCES "Employee"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_EmployeeToRole" ADD CONSTRAINT "_EmployeeToRole_B_fkey" FOREIGN KEY ("B") REFERENCES "Role"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="apps/hrms/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="apps/hrms/prisma/seed/employees.json">
[
  {
    "employeeId": "EMP2001",
    "firstName": "Abdul",
    "lastName": "Basit",
    "email": "abdulbasit@targonglobal.com",
    "department": "Operations",
    "position": "Staff",
    "employmentType": "PART_TIME",
    "joinDate": "2024-09-01",
    "status": "ACTIVE"
  },
  {
    "employeeId": "EMP2002",
    "firstName": "Hamad",
    "lastName": "Khan",
    "email": "hamadkhan@targonglobal.com",
    "department": "Operations",
    "position": "Staff",
    "employmentType": "FULL_TIME",
    "joinDate": "2024-09-01",
    "status": "ACTIVE"
  },
  {
    "employeeId": "EMP2003",
    "firstName": "Hashar",
    "lastName": "Awan",
    "email": "hashar@targonglobal.com",
    "department": "Operations",
    "position": "Staff",
    "employmentType": "FULL_TIME",
    "joinDate": "2024-09-01",
    "status": "ACTIVE"
  },
  {
    "employeeId": "EMP2004",
    "firstName": "Jarrar",
    "lastName": "Amjad",
    "email": "jarrar@targonglobal.com",
    "department": "Operations",
    "position": "Staff",
    "employmentType": "FULL_TIME",
    "joinDate": "2024-09-01",
    "status": "ACTIVE"
  },
  {
    "employeeId": "EMP2005",
    "firstName": "Muhammad",
    "lastName": "Mehdi",
    "email": "mehdi@targonglobal.com",
    "department": "Operations",
    "position": "Staff",
    "employmentType": "CONTRACT",
    "joinDate": "2024-09-01",
    "status": "ACTIVE"
  },
  {
    "employeeId": "EMP2006",
    "firstName": "Umair",
    "lastName": "Afzal",
    "email": "umair@targonglobal.com",
    "department": "Operations",
    "position": "Staff",
    "employmentType": "FULL_TIME",
    "joinDate": "2024-09-01",
    "status": "ACTIVE"
  }
]
</file>

<file path="apps/hrms/prisma/seed/employees.sample.json">
[
  {
    "employeeId": "EMP1001",
    "firstName": "Ava",
    "lastName": "Ng",
    "email": "ava.ng@example.com",
    "department": "HR",
    "position": "HR Generalist",
    "employmentType": "FULL_TIME",
    "joinDate": "2024-01-15",
    "status": "ACTIVE"
  }
]
</file>

<file path="apps/hrms/prisma/seed/policies.sample.json">
[
  {
    "title": "Annual Leave Policy",
    "category": "LEAVE",
    "summary": "Guidelines for PTO accrual and usage",
    "status": "ACTIVE"
  }
]
</file>

<file path="apps/hrms/prisma/seed/resources.sample.json">
[
  {
    "name": "Acme Accounting",
    "category": "ACCOUNTING",
    "subcategory": "Tax",
    "email": "contact@acmeaccounting.com",
    "phone": "+1-555-111-2222",
    "website": "https://acmeaccounting.com",
    "description": "Tax and bookkeeping services",
    "rating": 4.6
  }
]
</file>

<file path="apps/hrms/scripts/bootstrap-db.sql">
-- Bootstrap local Postgres for HRMS (matches production-style privileges)
-- Run as a superuser (postgres). Examples:
--   macOS:   psql -v ON_ERROR_STOP=1 -h localhost -U postgres -f apps/hrms/scripts/bootstrap-db.sql
--   Linux:   sudo -u postgres psql -v ON_ERROR_STOP=1 -f apps/hrms/scripts/bootstrap-db.sql

-- 1) Create role if missing
DO $$
BEGIN
   IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'hrms') THEN
      CREATE ROLE hrms LOGIN PASSWORD 'hrms';
   END IF;
END $$;

-- 2) Recreate database owned by hrms (drop if exists; safe for empty dev env)
--    Comment out DROP if you already have data you want to keep.
DROP DATABASE IF EXISTS hrms;
CREATE DATABASE hrms OWNER hrms;

-- 3) Ensure schema ownership and privileges
\connect hrms
ALTER SCHEMA public OWNER TO hrms;
GRANT USAGE, CREATE ON SCHEMA public TO hrms;
GRANT ALL PRIVILEGES ON ALL TABLES    IN SCHEMA public TO hrms;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO hrms;
GRANT ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA public TO hrms;

-- 4) Default privileges for future objects
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES    TO hrms;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO hrms;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON FUNCTIONS TO hrms;

-- 5) Explicit connect grant (usually implicit for owner, but keep for clarity)
\connect postgres
GRANT CONNECT ON DATABASE hrms TO hrms;
</file>

<file path="apps/hrms/types/googleapis.d.ts">
declare module 'googleapis';
</file>

<file path="apps/hrms/.eslintrc.json">
{
  "extends": ["next/core-web-vitals"]
}
</file>

<file path="apps/hrms/.gitignore">
# Dependencies
node_modules/

# Next.js
.next/
out/

# Logs and reports
logs/
*.log
playwright-report/
test-results/

# Env files
.env.local
.env.development
.env.production
.env.test
.env

# OS
.DS_Store

# Prisma
prisma/*.db
prisma/*.sqlite
# Keep migrations tracked for production deployments
</file>

<file path="apps/hrms/agents.json">
{
  "agents": {
    "uiux": {
      "name": "UIUX",
      "role": "Senior UIUX Developer",
      "status": "complete",
      "lastUpdate": "2025-01-13T21:30:00Z"
    },
    "codex": {
      "name": "Codex",
      "role": "Backend Engineer",
      "status": "active",
      "policy": {
        "acceptTasksIf": [
          "Conform to monorepo docs (README.md, docs/*).",
          "Reuse Website brand colors and tokens; no ad‑hoc palettes.",
          "Follow WMS UX patterns; no one‑off navigation.",
          "Shared concerns (auth/ui/theme) should live in packages/* where possible.",
          "Scripts/tsconfig consistent with root turbo/tsconfig.base.json"
        ],
        "rejectIf": [
          "Duplicating shared logic/colors in app folder",
          "Introducing non‑standard build/test pipeline",
          "Adding auth outside packages/auth contract",
          "Breaking API contracts defined in HRMS spec"
        ],
        "references": [
          "README.md",
          "docs/ARCHITECTURE.md",
          "docs/STYLE_GUIDE.md",
          "docs/TECH_STACK.md",
          "apps/website/README.md",
          "apps/wms/README.md (if present)",
          "docs/SHARED_WORKFLOWS_MIGRATION.md"
        ]
      }
    }
  },
  "taskQueue": [
    {
      "id": "TASK-001",
      "priority": "CRITICAL",
      "status": "ACCEPTED",
      "assignedTo": "Codex",
      "createdBy": "UIUX",
      "timestamp": "2025-01-13T21:00:00Z",
      "need": "Employee Data Operations",
      "requirements": {
        "operations": ["list", "create", "update", "delete", "search"],
        "dataNeeded": {
          "id": "unique",
          "employeeId": "unique business id",
          "firstName": "string",
          "lastName": "string",
          "email": "unique string",
          "department": "string",
          "position": "string",
          "joinDate": "date (ISO)",
          "employmentType": "FULL_TIME|PART_TIME|CONTRACT|INTERN",
          "status": "ACTIVE|ON_LEAVE|TERMINATED|RESIGNED",
          "salary": "number optional",
          "currency": "string optional (default USD)",
          "phone": "string optional",
          "addressFields": ["address?", "city?", "country?", "postalCode?"]
        },
        "listView": {
          "pagination": true,
          "itemsPerPage": 20,
          "sorting": ["name", "department", "joinDate"],
          "filtering": ["department", "status", "employmentType"],
          "search": "name or email"
        },
        "validation": {
          "emailUnique": true,
          "salaryPositive": true,
          "required": ["employeeId", "firstName", "lastName", "email", "department", "position", "joinDate", "employmentType"]
        }
      },
      "triage": {
        "decision": "accept",
        "rationale": "Aligns with HRMS business spec; will implement per Next.js App Router contracts with Prisma later."
      }
    },
    {
      "id": "TASK-002",
      "priority": "HIGH",
      "status": "ACCEPTED",
      "assignedTo": "Codex",
      "createdBy": "UIUX",
      "timestamp": "2025-01-13T21:00:00Z",
      "need": "Dashboard Statistics",
      "requirements": {
        "refreshRate": "realtime",
        "data": {
          "employeeCount": "number",
          "activeCount": "number",
          "departmentCount": "number",
          "monthlyPayroll": "number",
          "resourceCount": "number",
          "policyCount": "number",
          "employeeGrowthTrend": "percentage",
          "payrollChangeTrend": "percentage",
          "recentActivity": {
            "description": "string",
            "timestamp": "datetime",
            "type": "string"
          }
        }
      },
      "triage": {
        "decision": "accept",
        "rationale": "Dashboard stats derived from DB aggregates; initial version may compute from in‑memory/DB counts with later SSE for realtime."
      }
    },
    {
      "id": "TASK-003",
      "priority": "HIGH",
      "status": "ACCEPTED_WITH_CONSTRAINTS",
      "assignedTo": "Codex",
      "createdBy": "UIUX",
      "timestamp": "2025-01-13T21:00:00Z",
      "need": "User Authentication",
      "requirements": {
        "operations": {
          "login": "email + password",
          "logout": "clear session",
          "sessionPersist": "remember me",
          "passwordReset": "email"
        },
        "roles": {
          "admin": "all permissions",
          "hrManager": "employees + policies",
          "employee": "own profile + resources",
          "viewer": "read only"
        },
        "returnData": {
          "name": "string",
          "email": "string",
          "role": "string",
          "avatar": "url optional",
          "isAuthenticated": "boolean",
          "permissions": "array"
        }
      },
      "triage": {
        "decision": "accept_with_constraints",
        "constraints": [
          "Use packages/auth (shared) for NextAuth options",
          "Cookie domain from env; no per‑app ad‑hoc sessions"
        ],
        "rationale": "Auth must be centralized; HRMS consumes shared contract."
      }
    },
    {
      "id": "TASK-004",
      "priority": "MEDIUM",
      "status": "ACCEPTED_WITH_CONSTRAINTS",
      "assignedTo": "Codex",
      "createdBy": "UIUX",
      "timestamp": "2025-01-13T21:00:00Z",
      "need": "File Upload",
      "requirements": {
        "types": ["photos", "documents", "policies"],
        "maxSize": "10MB",
        "formats": ["jpg", "png", "pdf", "doc", "docx"],
        "returnData": {
          "uploadProgress": "0-100",
          "previewUrl": "string",
          "downloadUrl": "string",
          "deleteEndpoint": "string"
        }
      },
      "triage": {
        "decision": "accept_with_constraints",
        "constraints": [
          "Use S3 presign → PUT → finalize pattern",
          "Enforce 10MB and allowed formats at client+server"
        ],
        "rationale": "Matches spec file‑flow; no third‑party blobs beyond S3."
      }
    },
    {
      "id": "TASK-005",
      "priority": "MEDIUM",
      "status": "ACCEPTED_WITH_CONSTRAINTS",
      "assignedTo": "Codex",
      "createdBy": "UIUX",
      "timestamp": "2025-01-13T21:00:00Z",
      "need": "Search",
      "requirements": {
        "searchIn": {
          "employees": ["name", "email", "department"],
          "resources": ["name", "tags", "description"],
          "policies": ["title", "content"]
        },
        "features": {
          "instant": true,
          "highlighting": true,
          "suggestions": true,
          "filters": true
        }
      },
      "triage": {
        "decision": "accept_with_constraints",
        "constraints": [
          "Backed by DB queries; client highlighting/suggestions OK",
          "Respect entity‑specific fields per spec"
        ],
        "rationale": "Search fits monorepo; may evolve into separate service later."
      }
    },
    {
      "id": "TASK-006",
      "priority": "LOW",
      "status": "ACCEPTED",
      "assignedTo": "Codex",
      "createdBy": "UIUX",
      "timestamp": "2025-01-13T21:00:00Z",
      "need": "Notifications",
      "requirements": {
        "types": ["success", "error", "info", "warning"],
        "delivery": ["inApp", "persistent", "email"]
      },
      "triage": {
        "decision": "accept",
        "rationale": "In‑app toasts/persistent notifications; later email via planned service."
      }
    }
  ],
  "completedTasks": [],
  "dataFormats": {
    "list": {
      "data": "array",
      "total": "number",
      "page": "number",
      "pageSize": "number",
      "hasMore": "boolean"
    },
    "single": {
      "data": "object",
      "meta": "object optional"
    },
    "error": {
      "error": "string",
      "field": "string optional",
      "code": "string"
    },
    "success": {
      "success": true,
      "message": "string",
      "data": "any"
    }
  },
  "uiuxComplete": {
    "designSystem": {
      "colors": "Navy (#002C51) / Teal (#00C2B9) / Slate (#6F7B8B)",
      "typography": "System font stack with responsive sizing",
      "spacing": "4px base unit system",
      "borderRadius": "0.75rem base"
    },
    "componentsReady": [
      "Dashboard with stat cards",
      "Desktop sidebar navigation",
      "Mobile slide-out navigation",
      "Loading skeletons (CardSkeleton, TableRowSkeleton, PageSkeleton)",
      "Spinner component (sm/md/lg)",
      "LoadingOverlay with backdrop",
      "Error boundaries",
      "Empty states",
      "Form validation states",
      "Toast notification UI"
    ],
    "accessibility": {
      "wcag": "2.1 AA compliant structure",
      "ariaLabels": "All interactive elements",
      "keyboardNav": "Focus management utilities",
      "screenReader": "sr-only classes implemented",
      "focusTrap": "trapFocus() utility ready",
      "contrastRatio": "15.7:1 (Navy on white)"
    },
    "responsive": {
      "breakpoints": "320px mobile / 768px tablet / 1024px desktop",
      "touchTargets": "44px minimum",
      "mobileNav": "Slide-out drawer with backdrop",
      "utilities": "Responsive helpers (isMobile, isTablet, isDesktop)"
    },
    "performance": {
      "animations": "150-350ms duration",
      "debounce": "Utility ready for search",
      "measurePerformance": "Monitoring function ready",
      "lazyLoading": "Ready to implement with Next/Image"
    },
    "pagesStructure": {
      "/hrms": "Dashboard shell complete",
      "/hrms/employees": "List view UI ready",
      "/hrms/employees/add": "Form UI ready",
      "/hrms/employees/[id]": "Detail view UI ready",
      "/hrms/resources": "Grid view UI ready",
      "/hrms/policies": "List view UI ready"
    },
    "utilities": [
      "cn() - class merging",
      "announceToScreenReader()",
      "handleKeyboardNavigation()",
      "trapFocus()",
      "debounce()",
      "formatDate()",
      "formatCurrency()",
      "responsive helpers"
    ],
    "blockedByBackend": [
      "Live data integration",
      "Authentication flow",
      "File upload functionality",
      "Search results",
      "Real-time updates",
      "Notification delivery"
    ]
  },
  "nextSteps": {
    "forCodex": [
      "Implement API endpoints per requirements",
      "Set up database with Prisma",
      "Configure shared auth package",
      "Set up S3 for file uploads",
      "Implement search queries"
    ],
    "forUIUX": [
      "Integrate with API endpoints when ready",
      "Add error handling for API calls",
      "Implement optimistic updates",
      "Add PWA manifest when backend stable",
      "Performance testing with real data"
    ]
  },
  "metadata": {
    "lastUpdate": "2025-01-13T21:30:00Z",
    "uiuxStatus": "COMPLETE",
    "backendStatus": "IN_PROGRESS",
    "buildStatus": "SUCCESS",
    "deploymentReady": false
  }
}
</file>

<file path="apps/hrms/next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
</file>

<file path="apps/hrms/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="apps/hrms/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: "media",
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        // Custom brand colors
        navy: {
          DEFAULT: "#002C51",
          50: "#E6EEF4",
          100: "#CCDDE9",
          200: "#99BBD3",
          300: "#6699BD",
          400: "#3377A7",
          500: "#005591",
          600: "#004474",
          700: "#003357",
          800: "#002C51",
          900: "#001629"
        },
        teal: {
          DEFAULT: "#00C2B9",
          50: "#E6FAF9",
          100: "#CCF5F3",
          200: "#99EBE7",
          300: "#66E1DB",
          400: "#33D7CF",
          500: "#00C2B9",
          600: "#009B94",
          700: "#00746F",
          800: "#004D4A",
          900: "#002625"
        },
        slate: {
          DEFAULT: "#6F7B8B",
          50: "#F1F3F5",
          100: "#E3E6EA",
          200: "#C7CDD5",
          300: "#ABB4C0",
          400: "#8F9BAB",
          500: "#6F7B8B",
          600: "#59626F",
          700: "#434A53",
          800: "#2D3137",
          900: "#17191C"
        }
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
}
</file>

<file path="apps/hrms/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "baseUrl": ".",
    "allowJs": false,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "prisma"
  ]
}
</file>

<file path="packages/auth/dist/db.d.ts">
import { PrismaClient } from '../node_modules/.prisma/client-auth/index.js';
export declare function getPortalAuthPrisma(): PrismaClient;
declare global {
    var __portalAuthPrisma: PrismaClient | null | undefined;
}
</file>

<file path="packages/auth/dist/db.js">
// Use the Prisma client generated for the portal auth schema
// Explicitly reference the index.js to avoid ESM directory import issues in Node 20
// The generated client is produced by this package via `prisma generate --schema prisma/schema.prisma`
// and emitted to ../node_modules/.prisma/client-auth
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore — path import to generated client
import { PrismaClient } from '../node_modules/.prisma/client-auth/index.js';
let prismaInstance = globalThis.__portalAuthPrisma ?? null;
export function getPortalAuthPrisma() {
    if (!process.env.PORTAL_DB_URL) {
        throw new Error('PORTAL_DB_URL is not configured');
    }
    if (!prismaInstance) {
        prismaInstance = new PrismaClient();
        if (process.env.NODE_ENV !== 'production') {
            ;
            globalThis.__portalAuthPrisma = prismaInstance;
        }
    }
    return prismaInstance;
}
</file>

<file path="packages/auth/dist/server.d.ts">
export { getPortalAuthPrisma } from './db.js';
export { authenticateWithPortalDirectory, getUserEntitlements, getUserByEmail } from './user-service.js';
</file>

<file path="packages/auth/dist/server.js">
export { getPortalAuthPrisma } from './db.js';
export { authenticateWithPortalDirectory, getUserEntitlements, getUserByEmail } from './user-service.js';
</file>

<file path="packages/auth/dist/user-service.d.ts">
type AppEntitlementMap = Record<string, {
    role: string;
    departments: string[];
}>;
export type AuthenticatedUser = {
    id: string;
    email: string;
    username: string | null;
    fullName: string | null;
    roles: string[];
    entitlements: Record<string, {
        role: string;
        departments: string[];
    }>;
};
export declare function authenticateWithPortalDirectory(input: unknown): Promise<AuthenticatedUser | null>;
export declare function getUserEntitlements(userId: string): Promise<AppEntitlementMap>;
export declare function getUserByEmail(email: string): Promise<AuthenticatedUser | null>;
export {};
</file>

<file path="packages/auth/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client-auth"
}

datasource db {
  provider = "postgresql"
  url      = env("PORTAL_DB_URL")
}

model User {
  id            String      @id @default(uuid())
  email         String      @unique
  username      String?     @unique
  passwordHash  String
  firstName     String?
  lastName      String?
  isActive      Boolean     @default(true)
  isDemo        Boolean     @default(false)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  roles         UserRole[]
  appAccess     UserApp[]
}

model Role {
  id          String      @id @default(uuid())
  name        String      @unique
  description String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  users       UserRole[]
}

model UserRole {
  userId    String
  roleId    String
  assignedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
  @@index([roleId])
}

model App {
  id          String    @id @default(uuid())
  slug        String    @unique
  name        String
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  assignments UserApp[]
}

model UserApp {
  userId       String
  appId        String
  accessLevel  String    @default("member")
  assignedById String?
  assignedAt   DateTime  @default(now())
  departments  Json?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  app  App  @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@id([userId, appId])
  @@index([appId])
}
</file>

<file path="packages/auth/prisma/seed.ts">
import { PrismaClient } from '../node_modules/.prisma/client-auth'
import bcrypt from 'bcryptjs'

const prisma = new PrismaClient()

async function main() {
  const portalAdminEmail = process.env.SEED_PORTAL_ADMIN_EMAIL?.trim().toLowerCase()
  const portalAdminPassword = process.env.SEED_PORTAL_ADMIN_PASSWORD

  if (!portalAdminEmail) {
    throw new Error('SEED_PORTAL_ADMIN_EMAIL is required for seeding. Provide a real admin email via the environment.')
  }

  if (!portalAdminPassword || portalAdminPassword.length < 12) {
    throw new Error('SEED_PORTAL_ADMIN_PASSWORD is required and must be at least 12 characters long.')
  }

  const passwordHash = await bcrypt.hash(portalAdminPassword, 12)

  const [adminRole] = await Promise.all([
    prisma.role.upsert({
      where: { name: 'admin' },
      update: {},
      create: { name: 'admin', description: 'Full administrative access' },
    }),
    prisma.role.upsert({
      where: { name: 'manager' },
      update: {},
      create: { name: 'manager', description: 'Operational management role' },
    }),
    prisma.role.upsert({
      where: { name: 'staff' },
      update: {},
      create: { name: 'staff', description: 'Standard application access' },
    }),
    prisma.role.upsert({
      where: { name: 'viewer' },
      update: {},
      create: { name: 'viewer', description: 'Read-only access' },
    }),
  ])

  const username = portalAdminEmail.split('@')[0] ?? portalAdminEmail

  const apps = [
    { slug: 'wms', name: 'Warehouse Management' },
    { slug: 'hrms', name: 'HRMS' },
    { slug: 'fcc', name: 'Finance Console' },
    { slug: 'margin-master', name: 'Margin Master' },
    { slug: 'website', name: 'Website CMS' },
    { slug: 'legal-suite', name: 'Legal Suite' },
  ]

  await Promise.all(
    apps.map(app =>
      prisma.app.upsert({
        where: { slug: app.slug },
        update: {},
        create: { ...app },
      })
    )
  )

  const adminUser = await prisma.user.upsert({
    where: { email: portalAdminEmail },
    update: {
      passwordHash,
      isActive: true,
      isDemo: false,
      username,
    },
    create: {
      email: portalAdminEmail,
      username,
      passwordHash,
      firstName: 'Portal',
      lastName: 'Admin',
      isActive: true,
      isDemo: false,
    },
  })

  await prisma.userRole.upsert({
    where: {
      userId_roleId: {
        userId: adminUser.id,
        roleId: adminRole.id,
      },
    },
    update: {},
    create: {
      userId: adminUser.id,
      roleId: adminRole.id,
    },
  })

  const appRecords = await prisma.app.findMany({ select: { id: true, slug: true } })

  await Promise.all(
    appRecords.map(app =>
      prisma.userApp.upsert({
        where: {
          userId_appId: {
            userId: adminUser.id,
            appId: app.id,
          },
        },
        update: {},
        create: {
          userId: adminUser.id,
          appId: app.id,
          accessLevel: 'admin',
        },
      })
    )
  )

  console.log('Seed completed. Portal admin:', portalAdminEmail)
}

main()
  .catch(error => {
    console.error('Seed failed', error)
    process.exitCode = 1
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
</file>

<file path="packages/auth/src/db.ts">
// Use the Prisma client generated for the portal auth schema
// Explicitly reference the index.js to avoid ESM directory import issues in Node 20
// The generated client is produced by this package via `prisma generate --schema prisma/schema.prisma`
// and emitted to ../node_modules/.prisma/client-auth
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore — path import to generated client
import { PrismaClient } from '../node_modules/.prisma/client-auth/index.js'

let prismaInstance: PrismaClient | null = (globalThis as typeof globalThis & { __portalAuthPrisma?: PrismaClient | null }).__portalAuthPrisma ?? null

export function getPortalAuthPrisma(): PrismaClient {
  if (!process.env.PORTAL_DB_URL) {
    throw new Error('PORTAL_DB_URL is not configured')
  }

  if (!prismaInstance) {
    prismaInstance = new PrismaClient()
    if (process.env.NODE_ENV !== 'production') {
      ;(globalThis as typeof globalThis & { __portalAuthPrisma?: PrismaClient | null }).__portalAuthPrisma = prismaInstance
    }
  }

  return prismaInstance
}

declare global {
  // eslint-disable-next-line no-var -- reuse prisma in dev hot reload
  var __portalAuthPrisma: PrismaClient | null | undefined
}
</file>

<file path="packages/auth/src/server.ts">
export { getPortalAuthPrisma } from './db.js'
export { authenticateWithPortalDirectory, getUserEntitlements, getUserByEmail } from './user-service.js'
</file>

<file path="packages/auth/types/bcryptjs.d.ts">
declare module 'bcryptjs' {
  export function hash(data: string, salt: number): Promise<string>
  export function hashSync(data: string, salt: number): string
  export function compare(data: string, encrypted: string): Promise<boolean>
  export function compareSync(data: string, encrypted: string): boolean
}
</file>

<file path="packages/auth/.gitignore">
node_modules/
</file>

<file path="packages/auth/package.json">
{
  "name": "@ecom-os/auth",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc -p tsconfig.build.json",
    "dev": "tsc -w -p tsconfig.build.json",
    "type-check": "tsc --noEmit -p tsconfig.build.json",
    "lint": "echo 'No lint configured for auth package'",
    "prisma:generate": "prisma generate --schema prisma/schema.prisma",
    "prisma:migrate": "prisma db push --schema prisma/schema.prisma",
    "prisma:seed": "prisma db seed --schema prisma/schema.prisma",
    "prepare": "prisma generate --schema prisma/schema.prisma"
  },
  "devDependencies": {
    "@types/bcryptjs": "^3.0.0",
    "@types/node": "^24.3.0",
    "ts-node": "^10.9.2",
    "tsx": "^4.21.0",
    "next": "16.0.8",
    "next-auth": "5.0.0-beta.30",
    "prisma": "6.19.0",
    "typescript": "5.9.3"
  },
  "dependencies": {
    "@prisma/client": "6.19.0",
    "bcryptjs": "^3.0.3",
    "zod": "^3.24.4"
  },
  "peerDependencies": {
    "next-auth": "5.0.0-beta.30",
    "next": "16.0.8",
    "zod": "^3.24.4"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./server": {
      "import": "./dist/server.js",
      "types": "./dist/server.d.ts"
    }
  }
}
</file>

<file path="packages/auth/tsconfig.build.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "noEmit": false,
    "outDir": "dist",
    "declaration": true,
    "types": ["node"]
  },
  "include": ["src/**/*.ts", "types/**/*.d.ts"]
}
</file>

<file path="packages/auth/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "noEmit": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"]
}
</file>

<file path="packages/logger/src/index.ts">
type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface LoggerOptions {
  level?: LogLevel;
  name?: string;
}

export function createLogger(opts: LoggerOptions = {}) {
  const levelOrder: LogLevel[] = ['debug', 'info', 'warn', 'error'];
  const minLevel = opts.level ?? 'info';
  const minIdx = levelOrder.indexOf(minLevel);
  const name = opts.name ? `[${opts.name}]` : '';

  function log(lvl: LogLevel, ...args: unknown[]) {
    if (levelOrder.indexOf(lvl) < minIdx) return;
    const ts = new Date().toISOString();
    // eslint-disable-next-line no-console
    console[lvl === 'debug' ? 'log' : lvl](`${ts} ${name} ${lvl.toUpperCase()}:`, ...args);
  }

  return {
    debug: (...a: unknown[]) => log('debug', ...a),
    info: (...a: unknown[]) => log('info', ...a),
    warn: (...a: unknown[]) => log('warn', ...a),
    error: (...a: unknown[]) => log('error', ...a),
  };
}
</file>

<file path="packages/logger/package.json">
{
  "name": "@ecom-os/logger",
  "version": "0.1.0",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc -p tsconfig.build.json",
    "dev": "tsc -w -p tsconfig.build.json",
    "type-check": "tsc --noEmit -p tsconfig.build.json",
    "lint": "echo 'No lint configured for logger package'"
  },
  "devDependencies": {
    "typescript": "5.9.3"
  }
}
</file>

<file path="packages/logger/tsconfig.build.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "declaration": true
  },
  "include": ["src/**/*.ts"]
}
</file>

<file path="packages/logger/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "noEmit": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"]
}
</file>

<file path="packages/ui/src/index.tsx">
import * as React from 'react';

export type ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: 'primary' | 'secondary';
};

export function Button({ variant = 'primary', ...props }: ButtonProps) {
  const base = {
    primary: {
      backgroundColor: '#10b981',
      color: 'white',
      border: '1px solid #059669',
    },
    secondary: {
      backgroundColor: '#f3f4f6',
      color: '#111827',
      border: '1px solid #d1d5db',
    },
  } as const;

  return (
    <button
      style={{
        padding: '8px 12px',
        borderRadius: 6,
        cursor: 'pointer',
        ...base[variant],
      }}
      {...props}
    />
  );
}
</file>

<file path="packages/ui/package.json">
{
  "name": "@ecom-os/ui",
  "version": "0.1.0",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc -p tsconfig.build.json",
    "dev": "tsc -w -p tsconfig.build.json",
    "type-check": "tsc --noEmit -p tsconfig.build.json"
  },
  "peerDependencies": {
    "react": "19.2.1",
    "react-dom": "19.2.1"
  },
  "devDependencies": {
    "@types/react": "19.1.10",
    "@types/react-dom": "19.1.6",
    "typescript": "5.9.3"
  }
}
</file>

<file path="packages/ui/tsconfig.build.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "declaration": true,
    "jsx": "react-jsx"
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"]
}
</file>

<file path="packages/ui/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "noEmit": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"]
}
</file>

<file path="package.json">
{
  "name": "ecom-os",
  "private": true,
  "version": "1.1.0",
  "packageManager": "pnpm@10.21.0",
  "scripts": {
    "predev": "node scripts/prepare-dev-logs.js",
    "dev": "turbo run dev --parallel",
    "build": "node scripts/run-turbo-task.js build",
    "test": "node scripts/run-turbo-task.js test",
    "lint": "node scripts/run-turbo-task.js lint",
    "typecheck": "node scripts/run-turbo-task.js type-check",
    "format": "node scripts/run-turbo-task.js format",
    "refresh:wms-dev": "bash scripts/refresh-dev-app.sh wms",
    "refresh:ecomos-dev": "bash scripts/refresh-dev-app.sh ecomos",
    "refresh:website-dev": "bash scripts/refresh-dev-app.sh website",
    "refresh:xplan-dev": "bash scripts/refresh-dev-app.sh xplan",
    "deploy:metadata": "bash scripts/update-deploy-metadata.sh"
  },
  "devDependencies": {
    "@playwright/test": "^1.57.0",
    "playwright": "^1.57.0",
    "turbo": "^2.6.1",
    "typescript": "5.9.2"
  }
}
</file>

<file path="tsconfig.base.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "preserve",
    "strict": true,
    "noEmit": true,
    "allowJs": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@ecom-os/ui": ["packages/ui/src"],
      "@ecom-os/theme": ["packages/theme/src"],
      "@ecom-os/config": ["packages/config/src"],
      "@ecom-os/logger": ["packages/logger/src"],
      "@ecom-os/ledger": ["packages/ledger/src"]
    }
  }
}
</file>

<file path="turbo.json">
{
  "$schema": "https://turbo.build/schema.json",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**"],
      "env": [
        "NEXTAUTH_SECRET",
        "PORTAL_AUTH_SECRET",
        "PORTAL_AUTH_URL",
        "NEXTAUTH_URL",
        "COOKIE_DOMAIN",
        "BASE_PATH",
        "NEXT_PUBLIC_BASE_PATH",
        "NEXT_PUBLIC_APP_URL",
        "NEXT_PUBLIC_PORTAL_AUTH_URL",
        "CSRF_ALLOWED_ORIGINS",
        "DATABASE_URL"
      ]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "lint": {},
    "test": {
      "dependsOn": ["^build"]
    },
    "type-check": {
      "dependsOn": ["^type-check"]
    }
  }
}
</file>

<file path="apps/hrms/app/(hrms)/calendar/page.tsx">
"use client"

import { useEffect, useState } from 'react'
import { CalendarApi, type CalendarEvent } from '@/lib/api-client'
import { PageHeader } from '@/components/ui/PageHeader'
import { CalendarIcon } from '@/components/ui/Icons'

const EMBED_URL = process.env.NEXT_PUBLIC_GOOGLE_CALENDAR_EMBED_URL || ''

function formatDateTime(dateTime?: string, date?: string): string {
  const value = dateTime || date
  if (!value) return '—'

  try {
    const d = new Date(value)
    if (isNaN(d.getTime())) return '—'

    if (date && !dateTime) {
      return d.toLocaleDateString('en-US', {
        weekday: 'short',
        month: 'short',
        day: 'numeric',
        year: 'numeric',
      })
    }

    return d.toLocaleString('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      hour12: true,
    })
  } catch {
    return '—'
  }
}

export default function CalendarPage() {
  const [items, setItems] = useState<CalendarEvent[]>([])
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    ;(async () => {
      try {
        const { items } = await CalendarApi.list()
        setItems(items || [])
      } catch (e: any) {
        setError(e?.message || 'Failed to load events')
      }
    })()
  }, [])

  return (
    <div className="space-y-4">
      <PageHeader
        title="Team Calendar"
        description="Google Calendar integration"
        icon={<CalendarIcon className="h-6 w-6 text-white" />}
        showBack
      />

      {EMBED_URL && (
        <div className="w-full h-[700px] rounded-md border overflow-hidden">
          <iframe className="w-full h-full" src={EMBED_URL} title="Google Calendar" />
        </div>
      )}

      <div>
        <h2 className="text-lg font-medium mb-2">Upcoming Events</h2>
        {error && <div className="text-sm text-red-600 mb-2">{error}</div>}
        <div className="rounded-md border">
          <table className="w-full text-sm">
            <thead className="bg-muted">
              <tr>
                <th className="text-left p-2">Summary</th>
                <th className="text-left p-2">Start</th>
                <th className="text-left p-2">End</th>
                <th className="text-left p-2">Link</th>
              </tr>
            </thead>
            <tbody>
              {items.map(ev => (
                <tr key={ev.id} className="border-b border-gray-200 dark:border-gray-800">
                  <td className="p-2">{ev.summary || '—'}</td>
                  <td className="p-2">{formatDateTime(ev.start?.dateTime, (ev.start as any)?.date)}</td>
                  <td className="p-2">{formatDateTime(ev.end?.dateTime, (ev.end as any)?.date)}</td>
                  <td className="p-2">{ev.htmlLink ? <a className="text-primary underline" target="_blank" href={ev.htmlLink} rel="noreferrer">Open</a> : '—'}</td>
                </tr>
              ))}
              {!items.length && (
                <tr><td className="p-3 text-sm text-muted-foreground" colSpan={4}>No upcoming events or calendar not configured.</td></tr>
              )}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/performance/disciplinary/page.tsx">
'use client'

import { useCallback, useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { DisciplinaryActionsApi, type DisciplinaryAction } from '@/lib/api-client'
import { ShieldExclamationIcon, PlusIcon } from '@/components/ui/Icons'
import { ListPageHeader } from '@/components/ui/PageHeader'
import { Button } from '@/components/ui/Button'
import { StatusBadge } from '@/components/ui/Badge'
import { Card } from '@/components/ui/Card'
import { SearchForm } from '@/components/ui/SearchForm'
import {
  Table,
  TableHeader,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  ResultsCount,
} from '@/components/ui/Table'
import { TableEmptyState } from '@/components/ui/EmptyState'

const VIOLATION_TYPE_LABELS: Record<string, string> = {
  ATTENDANCE: 'Attendance',
  CONDUCT: 'Conduct',
  PERFORMANCE: 'Performance',
  POLICY_VIOLATION: 'Policy Violation',
  SAFETY: 'Safety',
  HARASSMENT: 'Harassment',
  INSUBORDINATION: 'Insubordination',
  THEFT_FRAUD: 'Theft/Fraud',
  SUBSTANCE_ABUSE: 'Substance Abuse',
  OTHER: 'Other',
}

const SEVERITY_LABELS: Record<string, string> = {
  MINOR: 'Minor',
  MODERATE: 'Moderate',
  MAJOR: 'Major',
  CRITICAL: 'Critical',
}

const SEVERITY_COLORS: Record<string, string> = {
  MINOR: 'bg-slate-100 text-slate-700',
  MODERATE: 'bg-amber-100 text-amber-700',
  MAJOR: 'bg-orange-100 text-orange-700',
  CRITICAL: 'bg-red-100 text-red-700',
}

const STATUS_LABELS: Record<string, string> = {
  OPEN: 'Open',
  UNDER_INVESTIGATION: 'Investigating',
  ACTION_TAKEN: 'Action Taken',
  APPEALED: 'Appealed',
  CLOSED: 'Closed',
  DISMISSED: 'Dismissed',
}

function SeverityBadge({ severity }: { severity: string }) {
  const colorClass = SEVERITY_COLORS[severity] || 'bg-slate-100 text-slate-700'
  return (
    <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${colorClass}`}>
      {SEVERITY_LABELS[severity] || severity}
    </span>
  )
}

function TableRowSkeleton() {
  return (
    <>
      {[...Array(5)].map((_, i) => (
        <tr key={i} className="animate-pulse">
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-32" /></td>
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-24" /></td>
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-16" /></td>
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-24" /></td>
          <td className="px-4 py-4"><div className="h-5 bg-slate-200 rounded w-20" /></td>
        </tr>
      ))}
    </>
  )
}

export default function DisciplinaryActionsPage() {
  const router = useRouter()
  const [items, setItems] = useState<DisciplinaryAction[]>([])
  const [q, setQ] = useState('')
  const [loading, setLoading] = useState(true)

  const load = useCallback(async () => {
    try {
      setLoading(true)
      const data = await DisciplinaryActionsApi.list({ q })
      setItems(data.items || [])
    } catch (err) {
      console.error('Error fetching disciplinary actions:', err)
      setItems([])
    } finally {
      setLoading(false)
    }
  }, [q])

  useEffect(() => {
    load()
  }, [load])

  const formatDate = (dateStr: string) => {
    return new Date(dateStr).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    })
  }

  return (
    <>
      <ListPageHeader
        title="Disciplinary Actions"
        description="Track violations and disciplinary records"
        icon={<ShieldExclamationIcon className="h-6 w-6 text-white" />}
        action={
          <Button href="/performance/disciplinary/add" icon={<PlusIcon className="h-4 w-4" />}>
            Report Violation
          </Button>
        }
      />

      <div className="space-y-6">
        <Card padding="md">
          <SearchForm
            value={q}
            onChange={setQ}
            onSubmit={load}
            placeholder="Search by employee name or description..."
          />
        </Card>

        <ResultsCount
          count={items.length}
          singular="record"
          plural="records"
          loading={loading}
        />

        <Table>
          <TableHeader>
            <TableHead>Employee</TableHead>
            <TableHead>Violation Type</TableHead>
            <TableHead>Severity</TableHead>
            <TableHead>Incident Date</TableHead>
            <TableHead>Status</TableHead>
          </TableHeader>
          <TableBody>
            {loading ? (
              <TableRowSkeleton />
            ) : items.length === 0 ? (
              <TableEmptyState
                colSpan={5}
                icon={<ShieldExclamationIcon className="h-10 w-10" />}
                title="No disciplinary records found"
              />
            ) : (
              items.map((d) => (
                <TableRow
                  key={d.id}
                  onClick={() => router.push(`/performance/disciplinary/${d.id}`)}
                >
                  <TableCell>
                    <div>
                      <p className="font-medium text-slate-900">
                        {d.employee?.firstName} {d.employee?.lastName}
                      </p>
                      <p className="text-xs text-slate-500">{d.employee?.department}</p>
                    </div>
                  </TableCell>
                  <TableCell className="text-slate-600">
                    {VIOLATION_TYPE_LABELS[d.violationType] || d.violationType}
                  </TableCell>
                  <TableCell>
                    <SeverityBadge severity={d.severity} />
                  </TableCell>
                  <TableCell className="text-slate-500">{formatDate(d.incidentDate)}</TableCell>
                  <TableCell>
                    <StatusBadge status={STATUS_LABELS[d.status] || d.status} />
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/performance/reviews/page.tsx">
'use client'

import { useCallback, useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { PerformanceReviewsApi, type PerformanceReview } from '@/lib/api-client'
import { ClipboardDocumentCheckIcon, PlusIcon, StarFilledIcon } from '@/components/ui/Icons'
import { ListPageHeader } from '@/components/ui/PageHeader'
import { Button } from '@/components/ui/Button'
import { StatusBadge } from '@/components/ui/Badge'
import { Card } from '@/components/ui/Card'
import { SearchForm } from '@/components/ui/SearchForm'
import {
  Table,
  TableHeader,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  ResultsCount,
} from '@/components/ui/Table'
import { TableEmptyState } from '@/components/ui/EmptyState'

const REVIEW_TYPE_LABELS: Record<string, string> = {
  PROBATION: 'Probation',
  QUARTERLY: 'Quarterly',
  SEMI_ANNUAL: 'Semi-Annual',
  ANNUAL: 'Annual',
  PROMOTION: 'Promotion',
  PIP: 'PIP',
}

const STATUS_LABELS: Record<string, string> = {
  DRAFT: 'Draft',
  PENDING_REVIEW: 'Pending',
  COMPLETED: 'Completed',
  ACKNOWLEDGED: 'Acknowledged',
}

function RatingStars({ rating }: { rating: number }) {
  return (
    <div className="flex items-center gap-0.5">
      {[1, 2, 3, 4, 5].map((star) => (
        <StarFilledIcon
          key={star}
          className={`h-4 w-4 ${star <= rating ? 'text-amber-400' : 'text-slate-200'}`}
        />
      ))}
    </div>
  )
}

function TableRowSkeleton() {
  return (
    <>
      {[...Array(5)].map((_, i) => (
        <tr key={i} className="animate-pulse">
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-32" /></td>
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-24" /></td>
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-20" /></td>
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-24" /></td>
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-16" /></td>
          <td className="px-4 py-4"><div className="h-5 bg-slate-200 rounded w-20" /></td>
        </tr>
      ))}
    </>
  )
}

export default function PerformanceReviewsPage() {
  const router = useRouter()
  const [items, setItems] = useState<PerformanceReview[]>([])
  const [q, setQ] = useState('')
  const [loading, setLoading] = useState(true)

  const load = useCallback(async () => {
    try {
      setLoading(true)
      const data = await PerformanceReviewsApi.list({ q })
      setItems(data.items || [])
    } catch (err) {
      console.error('Error fetching reviews:', err)
      setItems([])
    } finally {
      setLoading(false)
    }
  }, [q])

  useEffect(() => {
    load()
  }, [load])

  const formatDate = (dateStr: string) => {
    return new Date(dateStr).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    })
  }

  return (
    <>
      <ListPageHeader
        title="Performance Reviews"
        description="Track employee performance evaluations"
        icon={<ClipboardDocumentCheckIcon className="h-6 w-6 text-white" />}
        action={
          <Button href="/performance/reviews/add" icon={<PlusIcon className="h-4 w-4" />}>
            New Review
          </Button>
        }
      />

      <div className="space-y-6">
        <Card padding="md">
          <SearchForm
            value={q}
            onChange={setQ}
            onSubmit={load}
            placeholder="Search by employee name or reviewer..."
          />
        </Card>

        <ResultsCount
          count={items.length}
          singular="review"
          plural="reviews"
          loading={loading}
        />

        <Table>
          <TableHeader>
            <TableHead>Employee</TableHead>
            <TableHead>Review Type</TableHead>
            <TableHead>Period</TableHead>
            <TableHead>Date</TableHead>
            <TableHead>Rating</TableHead>
            <TableHead>Status</TableHead>
          </TableHeader>
          <TableBody>
            {loading ? (
              <TableRowSkeleton />
            ) : items.length === 0 ? (
              <TableEmptyState
                colSpan={6}
                icon={<ClipboardDocumentCheckIcon className="h-10 w-10" />}
                title="No reviews found"
                action={{
                  label: 'Create your first review',
                  href: '/performance/reviews/add',
                }}
              />
            ) : (
              items.map((r) => (
                <TableRow
                  key={r.id}
                  onClick={() => router.push(`/performance/reviews/${r.id}`)}
                >
                  <TableCell>
                    <div>
                      <p className="font-medium text-slate-900">
                        {r.employee?.firstName} {r.employee?.lastName}
                      </p>
                      <p className="text-xs text-slate-500">{r.employee?.department}</p>
                    </div>
                  </TableCell>
                  <TableCell className="text-slate-600">
                    {REVIEW_TYPE_LABELS[r.reviewType] || r.reviewType}
                  </TableCell>
                  <TableCell className="text-slate-600">{r.reviewPeriod}</TableCell>
                  <TableCell className="text-slate-500">{formatDate(r.reviewDate)}</TableCell>
                  <TableCell>
                    <RatingStars rating={r.overallRating} />
                  </TableCell>
                  <TableCell>
                    <StatusBadge status={STATUS_LABELS[r.status] || r.status} />
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/resources/add/page.tsx">
"use client"

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { ResourcesApi } from '@/lib/api-client'
import { PageHeader } from '@/components/ui/PageHeader'
import { FolderIcon } from '@/components/ui/Icons'
import { useNavigationHistory } from '@/lib/navigation-history'

export default function AddResourcePage() {
  const r = useRouter()
  const { goBack } = useNavigationHistory()
  const [submitting, setSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)

  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault()
    setSubmitting(true)
    setError(null)
    const fd = new FormData(e.currentTarget)
    const payload = Object.fromEntries(fd.entries()) as any
    try {
      await ResourcesApi.create({
        name: String(payload.name),
        category: String(payload.category || 'OTHER'),
        subcategory: payload.subcategory ? String(payload.subcategory) : undefined,
        email: payload.email ? String(payload.email) : undefined,
        phone: payload.phone ? String(payload.phone) : undefined,
        website: payload.website ? String(payload.website) : undefined,
        description: payload.description ? String(payload.description) : undefined,
        rating: payload.rating ? Number(payload.rating) : undefined,
      })
      r.push('/resources')
    } catch (e: any) {
      setError(e.message)
    } finally {
      setSubmitting(false)
    }
  }

  return (
    <div className="max-w-2xl space-y-4">
      <PageHeader
        title="Add Resource"
        description="Company Resources"
        icon={<FolderIcon className="h-6 w-6 text-white" />}
        showBack
      />

      {error && <div className="rounded-md border border-red-300 bg-red-50 text-red-700 p-3 text-sm">{error}</div>}

      <form onSubmit={onSubmit} className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm mb-1">Name *</label>
          <input name="name" required className="w-full px-3 py-2 rounded-md border border-input" />
        </div>
        <div>
          <label className="block text-sm mb-1">Category *</label>
          <select name="category" className="w-full px-3 py-2 rounded-md border border-input">
            <option value="ACCOUNTING">ACCOUNTING</option>
            <option value="LEGAL">LEGAL</option>
            <option value="DESIGN">DESIGN</option>
            <option value="MARKETING">MARKETING</option>
            <option value="IT">IT</option>
            <option value="HR">HR</option>
            <option value="OTHER">OTHER</option>
          </select>
        </div>
        <div>
          <label className="block text-sm mb-1">Subcategory</label>
          <input name="subcategory" className="w-full px-3 py-2 rounded-md border border-input" />
        </div>
        <div>
          <label className="block text-sm mb-1">Email</label>
          <input name="email" type="email" className="w-full px-3 py-2 rounded-md border border-input" />
        </div>
        <div>
          <label className="block text-sm mb-1">Phone</label>
          <input name="phone" className="w-full px-3 py-2 rounded-md border border-input" />
        </div>
        <div>
          <label className="block text-sm mb-1">Website</label>
          <input name="website" className="w-full px-3 py-2 rounded-md border border-input" />
        </div>
        <div className="md:col-span-2">
          <label className="block text-sm mb-1">Description</label>
          <textarea name="description" rows={4} className="w-full px-3 py-2 rounded-md border border-input" />
        </div>
        <div>
          <label className="block text-sm mb-1">Rating</label>
          <input name="rating" type="number" step="0.1" min="0" max="5" className="w-full px-3 py-2 rounded-md border border-input" />
        </div>
        <div className="md:col-span-2 flex gap-3">
          <button type="button" onClick={goBack} className="px-4 py-2 rounded-md border border-slate-200 bg-white hover:bg-slate-50 text-slate-700">
            Cancel
          </button>
          <button disabled={submitting} className="px-4 py-2 rounded-md bg-primary text-primary-foreground disabled:opacity-50">
            {submitting ? 'Saving…' : 'Save Resource'}
          </button>
        </div>
      </form>
    </div>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/page.tsx">
'use client'

import Link from 'next/link'
import { useState, useEffect } from 'react'
import { DashboardApi, NotificationsApi, type DashboardData } from '@/lib/api-client'
import {
  HomeIcon,
  UsersIcon,
  BellIcon,
  SpinnerIcon,
  UserIcon,
  CheckIcon,
  ChevronRightIcon,
  ExclamationCircleIcon,
  CalendarDaysIcon,
  EnvelopeIcon,
  PhoneIcon,
  BuildingIcon,
} from '@/components/ui/Icons'
import { ListPageHeader } from '@/components/ui/PageHeader'
import { Card } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import { Avatar } from '@/components/ui/Avatar'
import { LeaveBalanceCards } from '@/components/leave/LeaveBalanceCards'

function formatDate(dateString: string) {
  const date = new Date(dateString)
  const now = new Date()
  const diffMs = now.getTime() - date.getTime()
  const diffMins = Math.floor(diffMs / 60000)
  const diffHours = Math.floor(diffMins / 60)
  const diffDays = Math.floor(diffHours / 24)

  if (diffMins < 1) return 'Just now'
  if (diffMins < 60) return `${diffMins}m ago`
  if (diffHours < 24) return `${diffHours}h ago`
  if (diffDays < 7) return `${diffDays}d ago`
  return date.toLocaleDateString()
}

export default function Dashboard() {
  const [data, setData] = useState<DashboardData | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    fetchDashboardData()
  }, [])

  const fetchDashboardData = async () => {
    try {
      setLoading(true)
      setError(null)
      const dashboardData = await DashboardApi.get()
      setData(dashboardData)
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Failed to load dashboard'
      setError(message)
    } finally {
      setLoading(false)
    }
  }

  const markNotificationRead = async (id: string) => {
    try {
      await NotificationsApi.markAsRead([id])
      if (data) {
        setData({
          ...data,
          notifications: data.notifications.map((n) =>
            n.id === id ? { ...n, isRead: true } : n
          ),
          unreadNotificationCount: Math.max(0, data.unreadNotificationCount - 1),
        })
      }
    } catch (err) {
      console.error('Failed to mark notification as read:', err)
    }
  }

  const markAllRead = async () => {
    if (!data) return
    const unreadIds = data.notifications.filter(n => !n.isRead).map(n => n.id)
    if (unreadIds.length === 0) return

    try {
      await NotificationsApi.markAsRead(unreadIds)
      setData({
        ...data,
        notifications: data.notifications.map((n) => ({ ...n, isRead: true })),
        unreadNotificationCount: 0,
      })
    } catch (err) {
      console.error('Failed to mark notifications as read:', err)
    }
  }

  if (loading) {
    return (
      <>
        <ListPageHeader
          title="Dashboard"
          description="Welcome to your HR management system"
          icon={<HomeIcon className="h-6 w-6 text-white" />}
        />
        <div className="flex items-center justify-center h-64">
          <SpinnerIcon className="h-8 w-8 animate-spin text-cyan-600" />
        </div>
      </>
    )
  }

  if (error) {
    return (
      <>
        <ListPageHeader
          title="Dashboard"
          description="Welcome to your HR management system"
          icon={<HomeIcon className="h-6 w-6 text-white" />}
        />
        <div className="flex flex-col items-center justify-center h-64">
          <Alert variant="error" className="max-w-md mb-4">
            {error}
          </Alert>
          <Button onClick={fetchDashboardData}>Retry</Button>
        </div>
      </>
    )
  }

  const greeting = data?.user ? `Welcome back, ${data.user.firstName}` : 'Welcome'
  const isManager = data?.isManager ?? false
  const hasDirectReports = data?.directReports && data.directReports.length > 0
  const hasNotifications = data?.notifications && data.notifications.length > 0
  const unreadCount = data?.unreadNotificationCount ?? 0
  const hasPendingLeaves = data?.pendingLeaveRequests && data.pendingLeaveRequests.length > 0
  const myLeaveBalance = data?.myLeaveBalance || []
  const currentEmployee = data?.currentEmployee

  return (
    <>
      <ListPageHeader
        title={greeting}
        description={
          data?.user
            ? `${data.user.position} • ${data.user.department}`
            : 'Your HR management dashboard'
        }
        icon={<HomeIcon className="h-6 w-6 text-white" />}
      />

      <div className="grid grid-cols-1 lg:grid-cols-5 gap-6">
        {/* Main Content - Manager sees My Team, Regular users see My Profile */}
        <div className="lg:col-span-3 space-y-6">
          {isManager ? (
            <>
              {/* Manager View: My Team */}
              <Card padding="none">
                <div className="px-5 py-4 border-b border-slate-100 flex items-center justify-between">
                  <h2 className="font-semibold text-slate-900 flex items-center gap-2">
                    <UsersIcon className="h-5 w-5 text-cyan-600" />
                    My Team
                    {hasDirectReports && (
                      <span className="text-sm font-normal text-slate-400">
                        ({data.directReports.length})
                      </span>
                    )}
                  </h2>
                  {hasDirectReports && (
                    <Link
                      href="/employees"
                      className="text-sm text-cyan-600 hover:text-cyan-700 flex items-center gap-1"
                    >
                      All employees
                      <ChevronRightIcon className="h-4 w-4" />
                    </Link>
                  )}
                </div>

                <div className="p-5">
                  {hasDirectReports ? (
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                      {data.directReports.map((report) => (
                        <Link
                          key={report.id}
                          href={`/employees/${report.id}`}
                          className="flex items-center gap-3 p-3 rounded-xl border border-slate-100 hover:border-cyan-200 hover:bg-cyan-50/30 transition-all group"
                        >
                          <Avatar
                            src={report.avatar}
                            alt={`${report.firstName} ${report.lastName}`}
                            size="md"
                          />
                          <div className="flex-1 min-w-0">
                            <p className="font-medium text-slate-900 group-hover:text-cyan-700 truncate">
                              {report.firstName} {report.lastName}
                            </p>
                            <p className="text-sm text-slate-500 truncate">
                              {report.position}
                            </p>
                          </div>
                        </Link>
                      ))}
                    </div>
                  ) : (
                    <div className="text-center py-8">
                      <UserIcon className="h-8 w-8 text-slate-300 mx-auto mb-2" />
                      <p className="text-slate-500 text-sm">No direct reports</p>
                    </div>
                  )}
                </div>
              </Card>

              {/* Manager View: Pending Leave Approvals */}
              {hasPendingLeaves && (
                <Card padding="none">
                  <div className="px-5 py-4 border-b border-slate-100 flex items-center justify-between">
                    <h2 className="font-semibold text-slate-900 flex items-center gap-2">
                      <CalendarDaysIcon className="h-5 w-5 text-amber-500" />
                      Pending Leave Approvals
                      <span className="px-2 py-0.5 text-xs font-semibold bg-amber-100 text-amber-600 rounded-full">
                        {data.pendingLeaveRequests.length}
                      </span>
                    </h2>
                  </div>
                  <div className="divide-y divide-slate-100">
                    {data.pendingLeaveRequests.map((request) => (
                      <div key={request.id} className="px-5 py-4 flex items-center justify-between">
                        <div className="flex items-center gap-3">
                          <Avatar
                            src={request.employee?.avatar}
                            alt={`${request.employee?.firstName} ${request.employee?.lastName}`}
                            size="sm"
                          />
                          <div>
                            <p className="font-medium text-slate-900">
                              {request.employee?.firstName} {request.employee?.lastName}
                            </p>
                            <p className="text-sm text-slate-500">
                              {request.leaveType.replace('_', ' ')} · {request.totalDays} day{request.totalDays !== 1 ? 's' : ''}
                            </p>
                          </div>
                        </div>
                        <Link
                          href={`/employees/${request.employee?.id}`}
                          className="text-sm text-cyan-600 hover:text-cyan-700"
                        >
                          Review
                        </Link>
                      </div>
                    ))}
                  </div>
                </Card>
              )}
            </>
          ) : (
            <>
              {/* Regular User View: My Profile */}
              <Card padding="none">
                <div className="px-5 py-4 border-b border-slate-100 flex items-center justify-between">
                  <h2 className="font-semibold text-slate-900 flex items-center gap-2">
                    <UserIcon className="h-5 w-5 text-cyan-600" />
                    My Profile
                  </h2>
                  {currentEmployee && (
                    <Link
                      href={`/employees/${currentEmployee.id}`}
                      className="text-sm text-cyan-600 hover:text-cyan-700 flex items-center gap-1"
                    >
                      View full profile
                      <ChevronRightIcon className="h-4 w-4" />
                    </Link>
                  )}
                </div>

                <div className="p-5">
                  {currentEmployee ? (
                    <div className="flex flex-col sm:flex-row gap-6">
                      <div className="flex items-center gap-4">
                        <Avatar
                          src={currentEmployee.avatar}
                          alt={`${currentEmployee.firstName} ${currentEmployee.lastName}`}
                          size="lg"
                        />
                        <div>
                          <h3 className="text-lg font-semibold text-slate-900">
                            {currentEmployee.firstName} {currentEmployee.lastName}
                          </h3>
                          <p className="text-slate-600">{currentEmployee.position}</p>
                          <p className="text-sm text-slate-500">{currentEmployee.employeeId}</p>
                        </div>
                      </div>
                      <div className="flex-1 grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div className="flex items-center gap-2 text-sm">
                          <EnvelopeIcon className="h-4 w-4 text-slate-400" />
                          <span className="text-slate-600 truncate">{currentEmployee.email}</span>
                        </div>
                        {currentEmployee.phone && (
                          <div className="flex items-center gap-2 text-sm">
                            <PhoneIcon className="h-4 w-4 text-slate-400" />
                            <span className="text-slate-600">{currentEmployee.phone}</span>
                          </div>
                        )}
                        {currentEmployee.department && (
                          <div className="flex items-center gap-2 text-sm">
                            <BuildingIcon className="h-4 w-4 text-slate-400" />
                            <span className="text-slate-600">{currentEmployee.department}</span>
                          </div>
                        )}
                        {currentEmployee.reportsTo && (
                          <div className="flex items-center gap-2 text-sm">
                            <UsersIcon className="h-4 w-4 text-slate-400" />
                            <span className="text-slate-600">
                              Reports to {currentEmployee.reportsTo.firstName} {currentEmployee.reportsTo.lastName}
                            </span>
                          </div>
                        )}
                      </div>
                    </div>
                  ) : (
                    <div className="text-center py-8">
                      <UserIcon className="h-8 w-8 text-slate-300 mx-auto mb-2" />
                      <p className="text-slate-500 text-sm">Profile not available</p>
                    </div>
                  )}
                </div>
              </Card>

              {/* Regular User View: My Leave Balance */}
              <Card padding="none">
                <div className="px-5 py-4 border-b border-slate-100 flex items-center justify-between">
                  <h2 className="font-semibold text-slate-900 flex items-center gap-2">
                    <CalendarDaysIcon className="h-5 w-5 text-cyan-600" />
                    My Leave Balance
                  </h2>
                  {currentEmployee && (
                    <Link
                      href={`/employees/${currentEmployee.id}`}
                      className="text-sm text-cyan-600 hover:text-cyan-700 flex items-center gap-1"
                    >
                      Request leave
                      <ChevronRightIcon className="h-4 w-4" />
                    </Link>
                  )}
                </div>
                <div className="p-5">
                  <LeaveBalanceCards balances={myLeaveBalance} />
                </div>
              </Card>
            </>
          )}
        </div>

        {/* Sidebar - Notifications */}
        <div className="lg:col-span-2">
          <Card padding="none" className="h-full">
            <div className="px-5 py-4 border-b border-slate-100 flex items-center justify-between">
              <h2 className="font-semibold text-slate-900 flex items-center gap-2">
                <BellIcon className="h-5 w-5 text-cyan-600" />
                Notifications
                {unreadCount > 0 && (
                  <span className="px-2 py-0.5 text-xs font-semibold bg-red-100 text-red-600 rounded-full">
                    {unreadCount}
                  </span>
                )}
              </h2>
              {unreadCount > 0 && (
                <button
                  onClick={markAllRead}
                  className="text-xs text-slate-500 hover:text-cyan-600 transition-colors"
                >
                  Mark all read
                </button>
              )}
            </div>

            <div className="max-h-[400px] overflow-y-auto">
              {hasNotifications ? (
                <div className="divide-y divide-slate-100">
                  {data.notifications.map((notification) => (
                    <div
                      key={notification.id}
                      className={`px-5 py-4 transition-colors ${
                        notification.isRead ? 'bg-white' : 'bg-amber-50/50'
                      }`}
                    >
                      <div className="flex items-start gap-3">
                        <div className={`mt-0.5 flex-shrink-0 ${
                          notification.isRead ? 'text-slate-400' : 'text-amber-500'
                        }`}>
                          {notification.isRead ? (
                            <CheckIcon className="h-4 w-4" />
                          ) : (
                            <ExclamationCircleIcon className="h-4 w-4" />
                          )}
                        </div>
                        <div className="flex-1 min-w-0">
                          <p className={`text-sm ${
                            notification.isRead ? 'text-slate-600' : 'text-slate-900 font-medium'
                          }`}>
                            {notification.title}
                          </p>
                          <p className="text-xs text-slate-500 mt-0.5 line-clamp-2">
                            {notification.message}
                          </p>
                          <div className="flex items-center gap-3 mt-2">
                            <span className="text-[11px] text-slate-400">
                              {formatDate(notification.createdAt)}
                            </span>
                            {notification.link && (
                              <Link
                                href={notification.link}
                                className="text-[11px] text-cyan-600 hover:text-cyan-700"
                              >
                                View details
                              </Link>
                            )}
                            {!notification.isRead && (
                              <button
                                onClick={() => markNotificationRead(notification.id)}
                                className="text-[11px] text-slate-500 hover:text-slate-700"
                              >
                                Dismiss
                              </button>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="text-center py-12 px-5">
                  <div className="inline-flex items-center justify-center w-12 h-12 rounded-full bg-slate-100 mb-3">
                    <BellIcon className="h-6 w-6 text-slate-400" />
                  </div>
                  <p className="text-slate-500 text-sm">No notifications</p>
                </div>
              )}
            </div>
          </Card>
        </div>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/api/dashboard/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'
import { withRateLimit } from '@/lib/api-helpers'
import { getCurrentUser } from '@/lib/current-user'

export async function GET(req: Request) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  // Default fallback data when database is unavailable
  const fallbackData = {
    user: null,
    isManager: false,
    currentEmployee: null,
    directReports: [],
    notifications: [],
    unreadNotificationCount: 0,
    pendingReviews: [],
    pendingLeaveRequests: [],
    myLeaveBalance: [],
    upcomingLeaves: [],
    stats: [
      { label: 'Direct Reports', value: 0 },
      { label: 'Pending Reviews', value: 0 },
      { label: 'Unread Notifications', value: 0 },
    ],
  }

  try {
    const currentUser = await getCurrentUser()
    const employeeId = currentUser?.employee?.id

    if (!employeeId) {
      return NextResponse.json(fallbackData)
    }

    // Fetch personalized data
    const [
      currentEmployee,
      directReports,
      notifications,
      pendingReviews,
    ] = await Promise.all([
      // Get current employee's full profile
      prisma.employee.findUnique({
        where: { id: employeeId },
        select: {
          id: true,
          employeeId: true,
          firstName: true,
          lastName: true,
          email: true,
          phone: true,
          department: true,
          position: true,
          avatar: true,
          status: true,
          employmentType: true,
          joinDate: true,
          reportsToId: true,
          manager: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
            },
          },
        },
      }),
      // Get direct reports
      prisma.employee.findMany({
        where: {
          reportsToId: employeeId,
          status: 'ACTIVE',
        },
        select: {
          id: true,
          employeeId: true,
          firstName: true,
          lastName: true,
          email: true,
          department: true,
          position: true,
          avatar: true,
        },
        orderBy: [{ firstName: 'asc' }, { lastName: 'asc' }],
        take: 10,
      }),
      // Get user's notifications (personal + broadcast)
      prisma.notification.findMany({
        where: {
          OR: [{ employeeId }, { employeeId: null }],
        },
        orderBy: { createdAt: 'desc' },
        take: 10,
      }),
      // Get pending reviews for direct reports
      prisma.performanceReview.findMany({
        where: {
          employee: { reportsToId: employeeId },
          status: { in: ['DRAFT', 'PENDING_REVIEW'] },
        },
        select: {
          id: true,
          reviewType: true,
          reviewPeriod: true,
          reviewDate: true,
          status: true,
          employee: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              employeeId: true,
            },
          },
        },
        orderBy: { reviewDate: 'asc' },
        take: 5,
      }),
    ])

    // Determine if user is a manager (has direct reports)
    const isManager = directReports.length > 0

    // Get unread notification count
    const unreadNotificationCount = await prisma.notification.count({
      where: {
        isRead: false,
        OR: [{ employeeId }, { employeeId: null }],
      },
    })

    const stats = [
      { label: 'Direct Reports', value: directReports.length },
      { label: 'Pending Reviews', value: pendingReviews.length },
      { label: 'Unread Notifications', value: unreadNotificationCount },
    ]

    // Map manager to reportsTo for frontend compatibility
    const currentEmployeeFormatted = currentEmployee ? {
      ...currentEmployee,
      reportsTo: (currentEmployee as any).manager || null,
    } : null

    return NextResponse.json({
      user: currentUser?.employee,
      isManager,
      currentEmployee: currentEmployeeFormatted,
      directReports,
      notifications,
      unreadNotificationCount,
      pendingReviews,
      pendingLeaveRequests: [], // TODO: Add when leave models exist
      myLeaveBalance: [], // TODO: Add when leave models exist
      upcomingLeaves: [], // TODO: Add when leave models exist
      stats,
    })
  } catch (e) {
    // Log error server-side but return fallback data to keep UI functional
    console.error('[HRMS Dashboard] Database error:', e instanceof Error ? e.message : e)

    // Return fallback data instead of error so UI renders
    return NextResponse.json(fallbackData)
  }
}
</file>

<file path="apps/hrms/app/api/departments/[id]/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../lib/prisma'
import { withRateLimit } from '@/lib/api-helpers'

type Params = { params: Promise<{ id: string }> }

export async function GET(req: Request, { params }: Params) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  const { id } = await params

  try {
    const department = await prisma.department.findUnique({
      where: { id },
      include: {
        head: {
          select: {
            id: true,
            employeeId: true,
            firstName: true,
            lastName: true,
            email: true,
            position: true,
            avatar: true,
          },
        },
        parent: true,
        children: {
          include: {
            head: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                avatar: true,
              },
            },
          },
        },
        employees: {
          select: {
            id: true,
            employeeId: true,
            firstName: true,
            lastName: true,
            position: true,
            avatar: true,
          },
        },
      },
    })

    if (!department) {
      return NextResponse.json({ error: 'Department not found' }, { status: 404 })
    }

    return NextResponse.json(department)
  } catch (e) {
    console.error('[Department] Error:', e)
    return NextResponse.json({ error: 'Failed to fetch department' }, { status: 500 })
  }
}

export async function PATCH(req: Request, { params }: Params) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  const { id } = await params

  try {
    const body = await req.json()
    const { name, code, kpi, headId, parentId } = body

    const updates: Record<string, unknown> = {}
    if (name !== undefined) updates.name = name
    if (code !== undefined) updates.code = code || null
    if (kpi !== undefined) updates.kpi = kpi || null
    if (headId !== undefined) updates.headId = headId || null
    if (parentId !== undefined) updates.parentId = parentId || null

    const department = await prisma.department.update({
      where: { id },
      data: updates,
      include: {
        head: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            avatar: true,
          },
        },
        parent: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    })

    return NextResponse.json(department)
  } catch (e: any) {
    if (e.code === 'P2025') {
      return NextResponse.json({ error: 'Department not found' }, { status: 404 })
    }
    if (e.code === 'P2002') {
      return NextResponse.json({ error: 'Department name already exists' }, { status: 400 })
    }
    console.error('[Department] Error:', e)
    return NextResponse.json({ error: 'Failed to update department' }, { status: 500 })
  }
}

export async function DELETE(req: Request, { params }: Params) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  const { id } = await params

  try {
    await prisma.department.delete({ where: { id } })
    return NextResponse.json({ success: true })
  } catch (e: any) {
    if (e.code === 'P2025') {
      return NextResponse.json({ error: 'Department not found' }, { status: 404 })
    }
    console.error('[Department] Error:', e)
    return NextResponse.json({ error: 'Failed to delete department' }, { status: 500 })
  }
}
</file>

<file path="apps/hrms/app/api/departments/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'
import { withRateLimit } from '@/lib/api-helpers'

export async function GET(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const departments = await prisma.department.findMany({
      include: {
        head: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            avatar: true,
            position: true,
          },
        },
        parent: {
          select: {
            id: true,
            name: true,
          },
        },
        _count: {
          select: {
            employees: true,
            children: true,
          },
        },
      },
      orderBy: { name: 'asc' },
    })

    return NextResponse.json({ items: departments })
  } catch (e) {
    console.error('[Departments] Error:', e)
    return NextResponse.json({ error: 'Failed to fetch departments' }, { status: 500 })
  }
}

export async function POST(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const body = await req.json()
    const { name, code, kpi, headId, parentId } = body

    if (!name) {
      return NextResponse.json({ error: 'Name is required' }, { status: 400 })
    }

    const department = await prisma.department.create({
      data: {
        name,
        code: code || null,
        kpi: kpi || null,
        headId: headId || null,
        parentId: parentId || null,
      },
      include: {
        head: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    })

    return NextResponse.json(department, { status: 201 })
  } catch (e: any) {
    if (e.code === 'P2002') {
      return NextResponse.json({ error: 'Department name already exists' }, { status: 400 })
    }
    console.error('[Departments] Error:', e)
    return NextResponse.json({ error: 'Failed to create department' }, { status: 500 })
  }
}
</file>

<file path="apps/hrms/app/api/employees/[id]/projects/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../../lib/prisma'
import { withRateLimit, safeErrorResponse } from '@/lib/api-helpers'

type RouteContext = { params: Promise<{ id: string }> }

/**
 * GET /api/employees/[id]/projects
 * Get all project memberships for an employee
 */
export async function GET(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const memberships = await prisma.projectMember.findMany({
      where: { employeeId: id },
      include: {
        project: {
          select: {
            id: true,
            name: true,
            code: true,
            status: true,
          },
        },
      },
      orderBy: { joinedAt: 'desc' },
    })

    return NextResponse.json({ items: memberships })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch project memberships')
  }
}

/**
 * PUT /api/employees/[id]/projects
 * Replace all project memberships for an employee
 * Body: { memberships: [{ projectId: string, role?: string }] }
 */
export async function PUT(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const body = await req.json()
    const { memberships } = body as { memberships: { projectId: string; role?: string }[] }

    if (!Array.isArray(memberships)) {
      return NextResponse.json({ error: 'memberships must be an array' }, { status: 400 })
    }

    // Verify employee exists
    const employee = await prisma.employee.findUnique({
      where: { id },
    })
    if (!employee) {
      return NextResponse.json({ error: 'Employee not found' }, { status: 404 })
    }

    // Use transaction to replace all memberships
    await prisma.$transaction(async (tx) => {
      // Delete existing memberships
      await tx.projectMember.deleteMany({
        where: { employeeId: id },
      })

      // Create new memberships
      if (memberships.length > 0) {
        await tx.projectMember.createMany({
          data: memberships.map((m) => ({
            employeeId: id,
            projectId: m.projectId,
            role: m.role || null,
          })),
        })
      }
    })

    // Fetch and return updated memberships
    const updated = await prisma.projectMember.findMany({
      where: { employeeId: id },
      include: {
        project: {
          select: {
            id: true,
            name: true,
            code: true,
            status: true,
          },
        },
      },
      orderBy: { joinedAt: 'desc' },
    })

    return NextResponse.json({ items: updated })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to update project memberships')
  }
}
</file>

<file path="apps/hrms/app/api/employees/manageable/route.ts">
import { NextResponse } from 'next/server'
import { getCurrentEmployeeId } from '@/lib/current-user'
import { getManageableEmployees, canManageEmployee } from '@/lib/permissions'
import { withRateLimit, safeErrorResponse } from '@/lib/api-helpers'

/**
 * GET /api/employees/manageable
 * Returns list of employees the current user can manage (for reviews, disciplinary actions, etc.)
 */
export async function GET(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const currentEmployeeId = await getCurrentEmployeeId()
    if (!currentEmployeeId) {
      return NextResponse.json(
        { error: 'Unauthorized - not logged in' },
        { status: 401 }
      )
    }

    const employees = await getManageableEmployees(currentEmployeeId)
    return NextResponse.json({ items: employees, total: employees.length })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch manageable employees')
  }
}

/**
 * POST /api/employees/manageable/check
 * Check if current user can manage a specific employee
 */
export async function POST(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const currentEmployeeId = await getCurrentEmployeeId()
    if (!currentEmployeeId) {
      return NextResponse.json(
        { error: 'Unauthorized - not logged in' },
        { status: 401 }
      )
    }

    const body = await req.json()
    const targetEmployeeId = body.employeeId

    if (!targetEmployeeId) {
      return NextResponse.json(
        { error: 'employeeId is required' },
        { status: 400 }
      )
    }

    const result = await canManageEmployee(currentEmployeeId, targetEmployeeId)
    return NextResponse.json(result)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to check permission')
  }
}
</file>

<file path="apps/hrms/app/api/google-admin/sync/route.ts">
import { NextResponse } from 'next/server'
import { syncGoogleAdminUsers } from '@/lib/google-admin-sync'
import { isAdminConfigured } from '@/lib/google-admin'

export async function POST() {
  if (!isAdminConfigured()) {
    return NextResponse.json(
      { error: 'Google Admin API not configured' },
      { status: 500 }
    )
  }

  try {
    const result = await syncGoogleAdminUsers()
    return NextResponse.json(result)
  } catch (e: any) {
    console.error('Failed to sync Google Admin users:', e)
    return NextResponse.json(
      { error: e.message || 'Failed to sync users' },
      { status: 500 }
    )
  }
}

// Also allow GET for easy testing
export async function GET() {
  return POST()
}
</file>

<file path="apps/hrms/app/api/google-admin/users/route.ts">
import { NextResponse } from 'next/server'
import { listAllUsers, isAdminConfigured } from '@/lib/google-admin'

export async function GET() {
  if (!isAdminConfigured()) {
    return NextResponse.json(
      { error: 'Google Admin API not configured' },
      { status: 500 }
    )
  }

  try {
    const users = await listAllUsers()

    // Transform to a cleaner format
    const employees = users
      .filter(u => !u.suspended && !u.archived)
      .map(u => ({
        googleId: u.id,
        email: u.primaryEmail,
        firstName: u.name?.givenName || '',
        lastName: u.name?.familyName || '',
        fullName: u.name?.fullName || '',
        department: u.organizations?.[0]?.department || null,
        position: u.organizations?.[0]?.title || null,
        phone: u.phones?.[0]?.value || null,
        orgUnit: u.orgUnitPath,
        isAdmin: u.isAdmin,
        createdAt: u.creationTime,
        lastLogin: u.lastLoginTime,
        photoUrl: u.thumbnailPhotoUrl || null,
      }))

    return NextResponse.json({
      items: employees,
      total: employees.length,
    })
  } catch (e: any) {
    console.error('Failed to fetch Google Admin users:', e)
    return NextResponse.json(
      { error: e.message || 'Failed to fetch users' },
      { status: 500 }
    )
  }
}
</file>

<file path="apps/hrms/app/api/hr-calendar/[id]/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../lib/prisma'
import { UpdateHRCalendarEventSchema } from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'

type RouteContext = { params: Promise<{ id: string }> }

export async function GET(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const item = await prisma.hRCalendarEvent.findUnique({
      where: { id },
    })

    if (!item) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    return NextResponse.json(item)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch HR calendar event')
  }
}

export async function PATCH(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const body = await req.json()

    const validation = validateBody(UpdateHRCalendarEventSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data
    const updates: Record<string, unknown> = {}

    if (data.title !== undefined) updates.title = data.title
    if (data.description !== undefined) updates.description = data.description
    if (data.eventType !== undefined) updates.eventType = data.eventType
    if (data.startDate !== undefined) updates.startDate = new Date(data.startDate)
    if (data.endDate !== undefined) updates.endDate = data.endDate ? new Date(data.endDate) : null
    if (data.allDay !== undefined) updates.allDay = data.allDay
    if (data.employeeId !== undefined) updates.employeeId = data.employeeId
    if (data.relatedRecordId !== undefined) updates.relatedRecordId = data.relatedRecordId
    if (data.relatedRecordType !== undefined) updates.relatedRecordType = data.relatedRecordType

    const item = await prisma.hRCalendarEvent.update({
      where: { id },
      data: updates,
    })

    return NextResponse.json(item)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to update HR calendar event')
  }
}

export async function DELETE(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    await prisma.hRCalendarEvent.delete({ where: { id } })
    return NextResponse.json({ ok: true })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to delete HR calendar event')
  }
}
</file>

<file path="apps/hrms/app/api/hr-calendar/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'
import {
  CreateHRCalendarEventSchema,
  PaginationSchema,
  MAX_PAGINATION_LIMIT,
  HREventTypeEnum,
} from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'

export async function GET(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { searchParams } = new URL(req.url)

    const paginationResult = PaginationSchema.safeParse({
      take: searchParams.get('take') || undefined,
      skip: searchParams.get('skip') || undefined,
      q: searchParams.get('q') || undefined,
    })

    const take = paginationResult.success ? paginationResult.data.take : 50
    const skip = paginationResult.success ? paginationResult.data.skip : 0
    const q = paginationResult.success ? paginationResult.data.q?.toLowerCase() : ''

    const where: Record<string, unknown> = {}

    if (q) {
      where.OR = [
        { title: { contains: q, mode: 'insensitive' } },
        { description: { contains: q, mode: 'insensitive' } },
      ]
    }

    const eventTypeParam = searchParams.get('eventType')
    if (eventTypeParam) {
      const typeValidation = HREventTypeEnum.safeParse(eventTypeParam.toUpperCase())
      if (typeValidation.success) {
        where.eventType = typeValidation.data
      }
    }

    const employeeIdParam = searchParams.get('employeeId')
    if (employeeIdParam) {
      where.employeeId = employeeIdParam
    }

    // Date range filtering
    const startDateParam = searchParams.get('startDate')
    const endDateParam = searchParams.get('endDate')

    if (startDateParam || endDateParam) {
      where.startDate = {}
      if (startDateParam) {
        (where.startDate as Record<string, unknown>).gte = new Date(startDateParam)
      }
      if (endDateParam) {
        (where.startDate as Record<string, unknown>).lte = new Date(endDateParam)
      }
    }

    const [items, total] = await Promise.all([
      prisma.hRCalendarEvent.findMany({
        where,
        take: Math.min(take, MAX_PAGINATION_LIMIT),
        skip,
        orderBy: { startDate: 'asc' },
      }),
      prisma.hRCalendarEvent.count({ where }),
    ])

    return NextResponse.json({ items, total })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch HR calendar events')
  }
}

export async function POST(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const body = await req.json()

    const validation = validateBody(CreateHRCalendarEventSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data

    const item = await prisma.hRCalendarEvent.create({
      data: {
        title: data.title,
        description: data.description ?? null,
        eventType: data.eventType,
        startDate: new Date(data.startDate),
        endDate: data.endDate ? new Date(data.endDate) : null,
        allDay: data.allDay,
        employeeId: data.employeeId ?? null,
        relatedRecordId: data.relatedRecordId ?? null,
        relatedRecordType: data.relatedRecordType ?? null,
      },
    })

    return NextResponse.json(item, { status: 201 })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to create HR calendar event')
  }
}
</file>

<file path="apps/hrms/app/api/projects/hierarchy/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../lib/prisma'
import { withRateLimit } from '@/lib/api-helpers'

export async function GET(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    // Check if the project model exists (migration may not have been run yet)
    const projectModel = (prisma as any).project
    if (!projectModel) {
      return NextResponse.json({ items: [] })
    }

    // Fetch all projects with their leads and member details
    const projects = await projectModel.findMany({
      where: {
        status: {
          in: ['ACTIVE', 'PLANNING'],
        },
      },
      select: {
        id: true,
        name: true,
        code: true,
        description: true,
        status: true,
        leadId: true,
        startDate: true,
        endDate: true,
        lead: {
          select: {
            id: true,
            employeeId: true,
            firstName: true,
            lastName: true,
            email: true,
            position: true,
            avatar: true,
          },
        },
        members: {
          select: {
            id: true,
            role: true,
            employee: {
              select: {
                id: true,
                employeeId: true,
                firstName: true,
                lastName: true,
                email: true,
                position: true,
                department: true,
                avatar: true,
              },
            },
          },
        },
        _count: {
          select: {
            members: true,
          },
        },
      },
      orderBy: { name: 'asc' },
    })

    return NextResponse.json({ items: projects })
  } catch (e: any) {
    // Handle case where Project table doesn't exist yet
    if (e.code === 'P2021' || e.message?.includes('does not exist')) {
      return NextResponse.json({ items: [] })
    }
    console.error('[Projects Hierarchy] Error:', e)
    return NextResponse.json(
      { error: 'Failed to fetch project hierarchy' },
      { status: 500 }
    )
  }
}
</file>

<file path="apps/hrms/app/api/projects/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'
import { withRateLimit } from '@/lib/api-helpers'

export async function GET(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    // Check if the project model exists (migration may not have been run yet)
    const projectModel = (prisma as any).project
    if (!projectModel) {
      return NextResponse.json({ items: [] })
    }

    const projects = await projectModel.findMany({
      include: {
        lead: {
          select: {
            id: true,
            employeeId: true,
            firstName: true,
            lastName: true,
            email: true,
            position: true,
            avatar: true,
          },
        },
        _count: {
          select: {
            members: true,
          },
        },
      },
      orderBy: { name: 'asc' },
    })

    return NextResponse.json({ items: projects })
  } catch (e: any) {
    // Handle case where Project table doesn't exist yet
    if (e.code === 'P2021' || e.message?.includes('does not exist')) {
      return NextResponse.json({ items: [] })
    }
    console.error('[Projects] Error:', e)
    return NextResponse.json({ error: 'Failed to fetch projects' }, { status: 500 })
  }
}

export async function POST(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    // Check if the project model exists (migration may not have been run yet)
    const projectModel = (prisma as any).project
    if (!projectModel) {
      return NextResponse.json({ error: 'Projects feature not available. Please run database migration.' }, { status: 503 })
    }

    const body = await req.json()
    const { name, code, description, status, leadId, startDate, endDate } = body

    if (!name) {
      return NextResponse.json({ error: 'Name is required' }, { status: 400 })
    }

    const project = await projectModel.create({
      data: {
        name,
        code: code || null,
        description: description || null,
        status: status || 'ACTIVE',
        leadId: leadId || null,
        startDate: startDate ? new Date(startDate) : null,
        endDate: endDate ? new Date(endDate) : null,
      },
      include: {
        lead: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    })

    return NextResponse.json(project, { status: 201 })
  } catch (e: any) {
    if (e.code === 'P2002') {
      return NextResponse.json({ error: 'Project name already exists' }, { status: 400 })
    }
    if (e.code === 'P2021' || e.message?.includes('does not exist')) {
      return NextResponse.json({ error: 'Projects feature not available. Please run database migration.' }, { status: 503 })
    }
    console.error('[Projects] Error:', e)
    return NextResponse.json({ error: 'Failed to create project' }, { status: 500 })
  }
}
</file>

<file path="apps/hrms/app/api/setup/departments/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../lib/prisma'
import { withRateLimit } from '@/lib/api-helpers'

/**
 * One-time setup endpoint to:
 * 1. Run department schema migration (add columns if missing)
 * 2. Seed department hierarchy with heads and KPIs
 *
 * This is safe to run multiple times - it uses upserts and IF NOT EXISTS
 */
export async function POST(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  const results: string[] = []

  try {
    // Step 1: Run migration SQL to add new columns
    results.push('Running schema migration...')

    try {
      await prisma.$executeRawUnsafe(`
        ALTER TABLE "Department" ADD COLUMN IF NOT EXISTS "kpi" TEXT;
      `)
      results.push('Added kpi column')
    } catch (e: any) {
      if (!e.message?.includes('already exists')) {
        results.push(`kpi column: ${e.message}`)
      }
    }

    try {
      await prisma.$executeRawUnsafe(`
        ALTER TABLE "Department" ADD COLUMN IF NOT EXISTS "headId" TEXT;
      `)
      results.push('Added headId column')
    } catch (e: any) {
      if (!e.message?.includes('already exists')) {
        results.push(`headId column: ${e.message}`)
      }
    }

    try {
      await prisma.$executeRawUnsafe(`
        ALTER TABLE "Department" ADD COLUMN IF NOT EXISTS "parentId" TEXT;
      `)
      results.push('Added parentId column')
    } catch (e: any) {
      if (!e.message?.includes('already exists')) {
        results.push(`parentId column: ${e.message}`)
      }
    }

    // Add foreign keys (ignore if already exist)
    try {
      await prisma.$executeRawUnsafe(`
        ALTER TABLE "Department"
        ADD CONSTRAINT "Department_headId_fkey"
        FOREIGN KEY ("headId") REFERENCES "Employee"("id")
        ON DELETE SET NULL ON UPDATE CASCADE;
      `)
      results.push('Added headId foreign key')
    } catch (e: any) {
      if (e.message?.includes('already exists')) {
        results.push('headId foreign key already exists')
      }
    }

    try {
      await prisma.$executeRawUnsafe(`
        ALTER TABLE "Department"
        ADD CONSTRAINT "Department_parentId_fkey"
        FOREIGN KEY ("parentId") REFERENCES "Department"("id")
        ON DELETE SET NULL ON UPDATE CASCADE;
      `)
      results.push('Added parentId foreign key')
    } catch (e: any) {
      if (e.message?.includes('already exists')) {
        results.push('parentId foreign key already exists')
      }
    }

    // Add indexes
    try {
      await prisma.$executeRawUnsafe(`
        CREATE INDEX IF NOT EXISTS "Department_headId_idx" ON "Department"("headId");
      `)
      results.push('Added headId index')
    } catch (e: any) {
      results.push(`headId index: ${e.message}`)
    }

    try {
      await prisma.$executeRawUnsafe(`
        CREATE INDEX IF NOT EXISTS "Department_parentId_idx" ON "Department"("parentId");
      `)
      results.push('Added parentId index')
    } catch (e: any) {
      results.push(`parentId index: ${e.message}`)
    }

    results.push('Schema migration complete!')

    // Step 2: Seed department data
    results.push('\nSeeding departments...')

    // Get all employees to find heads
    const employees = await prisma.employee.findMany({
      select: { id: true, firstName: true, lastName: true, email: true },
    })

    const findEmployee = (firstName: string) => {
      return employees.find((e: { id: string; firstName: string; lastName: string; email: string }) =>
        e.firstName.toLowerCase() === firstName.toLowerCase()
      )
    }

    // Find key people
    const jarrar = findEmployee('Jarrar')
    const mehdi = findEmployee('Mehdi')
    const hamad = findEmployee('Hamad')
    const zeeshan = findEmployee('Zeeshan')

    results.push(`Found employees: Jarrar=${!!jarrar}, Mehdi=${!!mehdi}, Hamad=${!!hamad}, Zeeshan=${!!zeeshan}`)

    // Create/update Targon LLC (root)
    const company = await prisma.department.upsert({
      where: { name: 'Targon LLC' },
      update: {
        kpi: 'Company performance',
        headId: jarrar?.id || null,
      },
      create: {
        name: 'Targon LLC',
        code: 'TARGON',
        kpi: 'Company performance',
        headId: jarrar?.id || null,
      },
    })
    results.push(`Upserted: Targon LLC (head: ${jarrar?.firstName || 'none'})`)

    // Executive Supervision (under Mehdi)
    await prisma.department.upsert({
      where: { name: 'Executive Supervision' },
      update: {
        kpi: 'Management cadence',
        headId: mehdi?.id || null,
        parentId: company.id,
      },
      create: {
        name: 'Executive Supervision',
        code: 'EXEC',
        kpi: 'Management cadence',
        headId: mehdi?.id || null,
        parentId: company.id,
      },
    })
    results.push(`Upserted: Executive Supervision (head: ${mehdi?.firstName || 'none'})`)

    // HR & Training (under Mehdi)
    await prisma.department.upsert({
      where: { name: 'HR & Training' },
      update: {
        kpi: 'People readiness',
        headId: mehdi?.id || null,
        parentId: company.id,
      },
      create: {
        name: 'HR & Training',
        code: 'HR',
        kpi: 'People readiness',
        headId: mehdi?.id || null,
        parentId: company.id,
      },
    })
    results.push(`Upserted: HR & Training (head: ${mehdi?.firstName || 'none'})`)

    // Operations (under Hamad)
    await prisma.department.upsert({
      where: { name: 'Operations' },
      update: {
        kpi: 'Process reliability',
        headId: hamad?.id || null,
        parentId: company.id,
      },
      create: {
        name: 'Operations',
        code: 'OPS',
        kpi: 'Process reliability',
        headId: hamad?.id || null,
        parentId: company.id,
      },
    })
    results.push(`Upserted: Operations (head: ${hamad?.firstName || 'none'})`)

    // Sales & Marketing (under Hamad)
    await prisma.department.upsert({
      where: { name: 'Sales & Marketing' },
      update: {
        kpi: 'Order volume',
        headId: hamad?.id || null,
        parentId: company.id,
      },
      create: {
        name: 'Sales & Marketing',
        code: 'SALES',
        kpi: 'Order volume',
        headId: hamad?.id || null,
        parentId: company.id,
      },
    })
    results.push(`Upserted: Sales & Marketing (head: ${hamad?.firstName || 'none'})`)

    // Finance (under Zeeshan)
    await prisma.department.upsert({
      where: { name: 'Finance' },
      update: {
        kpi: 'Cashflow management',
        headId: zeeshan?.id || null,
        parentId: company.id,
      },
      create: {
        name: 'Finance',
        code: 'FIN',
        kpi: 'Cashflow management',
        headId: zeeshan?.id || null,
        parentId: company.id,
      },
    })
    results.push(`Upserted: Finance (head: ${zeeshan?.firstName || 'none'})`)

    // Legal (under Zeeshan)
    await prisma.department.upsert({
      where: { name: 'Legal' },
      update: {
        kpi: 'Contracts & compliance',
        headId: zeeshan?.id || null,
        parentId: company.id,
      },
      create: {
        name: 'Legal',
        code: 'LEGAL',
        kpi: 'Contracts & compliance',
        headId: zeeshan?.id || null,
        parentId: company.id,
      },
    })
    results.push(`Upserted: Legal (head: ${zeeshan?.firstName || 'none'})`)

    // Link any orphan departments to company
    const existingDepts = await prisma.department.findMany()
    for (const dept of existingDepts) {
      if (!dept.parentId && dept.name !== 'Targon LLC') {
        await prisma.department.update({
          where: { id: dept.id },
          data: { parentId: company.id },
        })
        results.push(`Linked orphan department "${dept.name}" to Targon LLC`)
      }
    }

    results.push('\nDepartment seeding complete!')

    // Step 3: Set up reporting hierarchy
    results.push('\nSetting up reporting hierarchy...')

    // Jarrar is CEO - no manager
    // Mehdi, Hamad, Zeeshan report to Jarrar
    if (jarrar) {
      if (mehdi) {
        await prisma.employee.update({
          where: { id: mehdi.id },
          data: { reportsToId: jarrar.id },
        })
        results.push(`${mehdi.firstName} now reports to ${jarrar.firstName}`)
      }
      if (hamad) {
        await prisma.employee.update({
          where: { id: hamad.id },
          data: { reportsToId: jarrar.id },
        })
        results.push(`${hamad.firstName} now reports to ${jarrar.firstName}`)
      }
      if (zeeshan) {
        await prisma.employee.update({
          where: { id: zeeshan.id },
          data: { reportsToId: jarrar.id },
        })
        results.push(`${zeeshan.firstName} now reports to ${jarrar.firstName}`)
      }
    }

    // Umair reports to Hamad
    const umair = findEmployee('Umair')
    if (umair && hamad) {
      await prisma.employee.update({
        where: { id: umair.id },
        data: { reportsToId: hamad.id },
      })
      results.push(`${umair.firstName} now reports to ${hamad.firstName}`)
    }

    results.push('\nReporting hierarchy complete!')
    results.push('\n✅ All setup complete!')

    return NextResponse.json({
      success: true,
      results,
    })
  } catch (e) {
    console.error('[Setup Departments] Error:', e)
    return NextResponse.json({
      success: false,
      error: e instanceof Error ? e.message : 'Unknown error',
      results,
    }, { status: 500 })
  }
}

export async function GET(req: Request) {
  return NextResponse.json({
    message: 'POST to this endpoint to run department setup (migration + seed + hierarchy)',
    warning: 'This will modify the database',
  })
}
</file>

<file path="apps/hrms/components/leave/LeaveBalanceCards.tsx">
'use client'

import { type LeaveBalance } from '@/lib/api-client'
import { CalendarDaysIcon } from '@/components/ui/Icons'

const LEAVE_TYPE_LABELS: Record<string, string> = {
  ANNUAL: 'Annual Leave',
  SICK: 'Sick Leave',
  PERSONAL: 'Personal Leave',
  UNPAID: 'Unpaid Leave',
  MATERNITY: 'Maternity Leave',
  PATERNITY: 'Paternity Leave',
  BEREAVEMENT: 'Bereavement',
  COMP_TIME: 'Comp Time',
}

const LEAVE_TYPE_COLORS: Record<string, { bg: string; text: string; progress: string }> = {
  ANNUAL: { bg: 'bg-cyan-50', text: 'text-cyan-700', progress: 'bg-cyan-500' },
  SICK: { bg: 'bg-rose-50', text: 'text-rose-700', progress: 'bg-rose-500' },
  PERSONAL: { bg: 'bg-violet-50', text: 'text-violet-700', progress: 'bg-violet-500' },
  UNPAID: { bg: 'bg-slate-50', text: 'text-slate-700', progress: 'bg-slate-500' },
  MATERNITY: { bg: 'bg-pink-50', text: 'text-pink-700', progress: 'bg-pink-500' },
  PATERNITY: { bg: 'bg-blue-50', text: 'text-blue-700', progress: 'bg-blue-500' },
  BEREAVEMENT: { bg: 'bg-amber-50', text: 'text-amber-700', progress: 'bg-amber-500' },
  COMP_TIME: { bg: 'bg-emerald-50', text: 'text-emerald-700', progress: 'bg-emerald-500' },
}

type LeaveBalanceCardsProps = {
  balances: LeaveBalance[]
}

export function LeaveBalanceCards({ balances }: LeaveBalanceCardsProps) {
  if (!balances || balances.length === 0) {
    return (
      <div className="text-center py-8">
        <CalendarDaysIcon className="h-10 w-10 text-slate-300 mx-auto mb-2" />
        <p className="text-slate-500 text-sm">No leave balance data available</p>
      </div>
    )
  }

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
      {balances.map((balance) => {
        const colors = LEAVE_TYPE_COLORS[balance.leaveType] || LEAVE_TYPE_COLORS.UNPAID
        const label = LEAVE_TYPE_LABELS[balance.leaveType] || balance.leaveType.replace(/_/g, ' ')
        const available = balance.available
        const total = balance.allocated
        const usedPercent = total > 0 ? ((total - available) / total) * 100 : 0

        return (
          <div
            key={balance.leaveType}
            className={`${colors.bg} rounded-xl p-4 border border-slate-100`}
          >
            <div className="flex items-center justify-between mb-3">
              <h4 className={`text-sm font-medium ${colors.text}`}>{label}</h4>
              <span className={`text-xs ${colors.text} opacity-75`}>
                {balance.pending > 0 && `${balance.pending} pending`}
              </span>
            </div>
            <div className="flex items-baseline gap-1 mb-2">
              <span className={`text-2xl font-bold ${colors.text}`}>{available}</span>
              <span className="text-sm text-slate-500">/ {total} days</span>
            </div>
            <div className="h-2 bg-white rounded-full overflow-hidden">
              <div
                className={`h-full ${colors.progress} transition-all duration-300`}
                style={{ width: `${usedPercent}%` }}
              />
            </div>
            <p className="text-xs text-slate-500 mt-2">
              {balance.used} used
              {balance.pending > 0 && ` + ${balance.pending} pending`}
            </p>
          </div>
        )
      })}
    </div>
  )
}
</file>

<file path="apps/hrms/components/leave/LeaveHistoryTable.tsx">
'use client'

import { type LeaveRequest } from '@/lib/api-client'
import { CalendarDaysIcon, XIcon } from '@/components/ui/Icons'
import { StatusBadge } from '@/components/ui/Badge'

const LEAVE_TYPE_LABELS: Record<string, string> = {
  ANNUAL: 'Annual Leave',
  SICK: 'Sick Leave',
  PERSONAL: 'Personal Leave',
  UNPAID: 'Unpaid Leave',
  MATERNITY: 'Maternity Leave',
  PATERNITY: 'Paternity Leave',
  BEREAVEMENT: 'Bereavement',
  COMP_TIME: 'Comp Time',
}

function formatDate(dateString: string): string {
  if (!dateString) return '—'
  const date = new Date(dateString)
  if (isNaN(date.getTime())) return '—'
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  })
}

type LeaveHistoryTableProps = {
  requests: LeaveRequest[]
  loading?: boolean
  onCancel?: (id: string) => void
}

export function LeaveHistoryTable({ requests, loading, onCancel }: LeaveHistoryTableProps) {
  if (loading) {
    return (
      <div className="animate-pulse space-y-3">
        {[1, 2, 3].map((i) => (
          <div key={i} className="h-16 bg-slate-100 rounded-lg" />
        ))}
      </div>
    )
  }

  if (!requests || requests.length === 0) {
    return (
      <div className="text-center py-8">
        <CalendarDaysIcon className="h-10 w-10 text-slate-300 mx-auto mb-2" />
        <p className="text-slate-500 text-sm">No leave requests</p>
      </div>
    )
  }

  return (
    <div className="space-y-3">
      {requests.map((request) => (
        <div
          key={request.id}
          className="p-4 bg-slate-50 rounded-lg border border-slate-100"
        >
          <div className="flex items-start justify-between">
            <div className="flex-1">
              <div className="flex items-center gap-2 mb-1">
                <span className="font-medium text-slate-900">
                  {LEAVE_TYPE_LABELS[request.leaveType] || request.leaveType.replace(/_/g, ' ')}
                </span>
                <StatusBadge status={request.status} />
              </div>
              <p className="text-sm text-slate-600">
                {formatDate(request.startDate)} — {formatDate(request.endDate)}
                <span className="text-slate-400 mx-2">·</span>
                {request.totalDays} day{request.totalDays !== 1 ? 's' : ''}
              </p>
              {request.reason && (
                <p className="text-xs text-slate-500 mt-1 line-clamp-2">{request.reason}</p>
              )}
              {request.reviewedBy && (
                <p className="text-xs text-slate-400 mt-1">
                  {request.status === 'APPROVED' ? 'Approved' : 'Reviewed'} by {request.reviewedBy.firstName} {request.reviewedBy.lastName}
                </p>
              )}
            </div>
            {request.status === 'PENDING' && onCancel && (
              <button
                onClick={() => onCancel(request.id)}
                className="p-1.5 text-slate-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition-colors"
                title="Cancel request"
              >
                <XIcon className="h-4 w-4" />
              </button>
            )}
          </div>
        </div>
      ))}
    </div>
  )
}
</file>

<file path="apps/hrms/components/leave/LeaveRequestForm.tsx">
'use client'

import { useState } from 'react'
import { LeavesApi } from '@/lib/api-client'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'

const LEAVE_TYPES = [
  { value: 'ANNUAL', label: 'Annual Leave' },
  { value: 'SICK', label: 'Sick Leave' },
  { value: 'PERSONAL', label: 'Personal Leave' },
  { value: 'UNPAID', label: 'Unpaid Leave' },
  { value: 'MATERNITY', label: 'Maternity Leave' },
  { value: 'PATERNITY', label: 'Paternity Leave' },
  { value: 'BEREAVEMENT', label: 'Bereavement Leave' },
  { value: 'COMP_TIME', label: 'Compensatory Time' },
]

function calculateBusinessDays(startDate: string, endDate: string): number {
  if (!startDate || !endDate) return 0
  const start = new Date(startDate)
  const end = new Date(endDate)
  if (isNaN(start.getTime()) || isNaN(end.getTime())) return 0
  if (start > end) return 0

  let count = 0
  const current = new Date(start)
  while (current <= end) {
    const day = current.getDay()
    if (day !== 0 && day !== 6) {
      count++
    }
    current.setDate(current.getDate() + 1)
  }
  return count
}

type LeaveRequestFormProps = {
  employeeId: string
  onSuccess?: () => void
  onCancel?: () => void
}

export function LeaveRequestForm({ employeeId, onSuccess, onCancel }: LeaveRequestFormProps) {
  const [leaveType, setLeaveType] = useState('ANNUAL')
  const [startDate, setStartDate] = useState('')
  const [endDate, setEndDate] = useState('')
  const [reason, setReason] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const totalDays = calculateBusinessDays(startDate, endDate)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!startDate || !endDate) {
      setError('Please select start and end dates')
      return
    }
    if (totalDays <= 0) {
      setError('End date must be after start date')
      return
    }

    try {
      setLoading(true)
      setError(null)
      await LeavesApi.create({
        employeeId,
        leaveType,
        startDate,
        endDate,
        totalDays,
        reason: reason || undefined,
      })
      onSuccess?.()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to submit leave request')
    } finally {
      setLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && <Alert variant="error">{error}</Alert>}

      <div>
        <label className="block text-sm font-medium text-slate-700 mb-1">
          Leave Type
        </label>
        <select
          value={leaveType}
          onChange={(e) => setLeaveType(e.target.value)}
          className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent"
        >
          {LEAVE_TYPES.map((type) => (
            <option key={type.value} value={type.value}>
              {type.label}
            </option>
          ))}
        </select>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-slate-700 mb-1">
            Start Date
          </label>
          <input
            type="date"
            value={startDate}
            onChange={(e) => setStartDate(e.target.value)}
            className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent"
            required
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-slate-700 mb-1">
            End Date
          </label>
          <input
            type="date"
            value={endDate}
            onChange={(e) => setEndDate(e.target.value)}
            min={startDate}
            className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent"
            required
          />
        </div>
      </div>

      {totalDays > 0 && (
        <div className="text-sm text-slate-600 bg-slate-50 px-3 py-2 rounded-lg">
          Total: <span className="font-medium">{totalDays} business day{totalDays !== 1 ? 's' : ''}</span>
        </div>
      )}

      <div>
        <label className="block text-sm font-medium text-slate-700 mb-1">
          Reason (optional)
        </label>
        <textarea
          value={reason}
          onChange={(e) => setReason(e.target.value)}
          rows={3}
          className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent resize-none"
          placeholder="Briefly describe the reason for your leave..."
        />
      </div>

      <div className="flex gap-3 justify-end">
        {onCancel && (
          <Button type="button" variant="ghost" onClick={onCancel}>
            Cancel
          </Button>
        )}
        <Button type="submit" disabled={loading || totalDays <= 0}>
          {loading ? 'Submitting...' : 'Submit Request'}
        </Button>
      </div>
    </form>
  )
}
</file>

<file path="apps/hrms/components/organogram/ProjectOrgChart.tsx">
'use client'

import { useState, useMemo, useCallback } from 'react'
import Link from 'next/link'
import { Project } from '@/lib/api-client'
import { Avatar } from '@/components/ui/Avatar'
import { MinusIcon, PlusIcon, UsersIcon, FolderIcon } from '@/components/ui/Icons'

type Props = {
  projects: Project[]
}

// Status badge colors
const statusColors: Record<string, { bg: string; text: string }> = {
  PLANNING: { bg: 'bg-amber-100', text: 'text-amber-700' },
  ACTIVE: { bg: 'bg-green-100', text: 'text-green-700' },
  ON_HOLD: { bg: 'bg-slate-100', text: 'text-slate-600' },
  COMPLETED: { bg: 'bg-blue-100', text: 'text-blue-700' },
  CANCELLED: { bg: 'bg-red-100', text: 'text-red-700' },
}

// Project card component
function ProjectCard({
  project,
  hasMembers,
  isExpanded,
  onToggle,
}: {
  project: Project
  hasMembers: boolean
  isExpanded: boolean
  onToggle: () => void
}) {
  const hasLead = !!project.lead
  const memberCount = project._count?.members ?? 0
  const statusStyle = statusColors[project.status] ?? statusColors.ACTIVE

  return (
    <div
      className={`relative flex flex-col rounded-xl p-4 min-w-[220px] max-w-[260px] transition-all duration-200 ${
        hasLead
          ? 'border border-slate-200 bg-white shadow-sm hover:shadow-md'
          : 'border border-dashed border-slate-300 bg-slate-50'
      }`}
      data-project-id={project.id}
    >
      {/* Project Name */}
      <h3 className="font-semibold text-center leading-tight mb-1 text-slate-800 text-sm">
        {project.name}
      </h3>

      {/* Project Code */}
      {project.code && (
        <p className="text-[10px] text-slate-400 text-center mb-2">{project.code}</p>
      )}

      {/* Status Badge */}
      <div className="flex justify-center mb-2">
        <span className={`inline-flex items-center px-2 py-0.5 rounded-full text-[10px] font-medium ${statusStyle.bg} ${statusStyle.text}`}>
          {project.status.replace('_', ' ')}
        </span>
      </div>

      {/* Project Lead */}
      {project.lead ? (
        <div className="flex items-center gap-2 p-2 bg-slate-50 rounded-lg">
          <Avatar
            src={project.lead.avatar}
            alt={`${project.lead.firstName} ${project.lead.lastName}`}
            size="sm"
          />
          <div className="flex-1 min-w-0">
            <Link
              href={`/employees/${project.lead.id}`}
              className="text-xs font-semibold text-slate-900 hover:text-cyan-600 truncate block"
            >
              {project.lead.firstName} {project.lead.lastName}
            </Link>
            <p className="text-[10px] text-slate-500 truncate">{project.lead.position}</p>
          </div>
        </div>
      ) : (
        <div className="flex items-center justify-center gap-1.5 p-2 text-slate-400 text-xs">
          <UsersIcon className="h-3.5 w-3.5" />
          <span>No lead assigned</span>
        </div>
      )}

      {/* Member count */}
      <div className="flex items-center justify-center gap-1 mt-2 text-[11px] text-slate-500">
        <UsersIcon className="h-3.5 w-3.5" />
        <span>{memberCount} {memberCount === 1 ? 'member' : 'members'}</span>
      </div>

      {/* Expand/collapse button */}
      {hasMembers && (
        <button
          onClick={onToggle}
          className="absolute -bottom-3 left-1/2 -translate-x-1/2 w-6 h-6 rounded-full bg-white border border-slate-200 shadow-sm flex items-center justify-center hover:bg-slate-50 hover:border-slate-300 transition-colors z-10"
        >
          {isExpanded ? (
            <MinusIcon className="h-3 w-3 text-slate-500" />
          ) : (
            <PlusIcon className="h-3 w-3 text-slate-500" />
          )}
        </button>
      )}
    </div>
  )
}

// Member card component
function MemberCard({
  member,
}: {
  member: NonNullable<Project['members']>[number]
}) {
  return (
    <div className="flex flex-col items-center rounded-lg p-3 min-w-[140px] max-w-[160px] border border-slate-200 bg-white shadow-sm">
      <Avatar
        src={member.employee.avatar}
        alt={`${member.employee.firstName} ${member.employee.lastName}`}
        size="md"
      />
      <Link
        href={`/employees/${member.employee.id}`}
        className="mt-1.5 font-semibold text-center text-xs leading-tight text-slate-900 hover:text-cyan-600"
      >
        {member.employee.firstName} {member.employee.lastName}
      </Link>
      {member.role && (
        <p className="text-[10px] text-cyan-600 text-center mt-0.5 font-medium">{member.role}</p>
      )}
      <p className="text-[10px] text-slate-500 text-center">{member.employee.position}</p>
      <p className="text-[10px] text-slate-400 text-center">{member.employee.department}</p>
    </div>
  )
}

// Project node with members
function ProjectNode({
  project,
  expandedNodes,
  toggleNode,
}: {
  project: Project
  expandedNodes: Set<string>
  toggleNode: (id: string) => void
}) {
  const hasMembers = (project.members?.length ?? 0) > 0
  const isExpanded = expandedNodes.has(project.id)

  return (
    <div className="flex flex-col items-center">
      {/* Project Card */}
      <ProjectCard
        project={project}
        hasMembers={hasMembers}
        isExpanded={isExpanded}
        onToggle={() => toggleNode(project.id)}
      />

      {/* Members */}
      {hasMembers && isExpanded && (
        <div className="flex flex-col items-center mt-10">
          {/* Vertical line down from project */}
          <div className="w-0.5 h-8 bg-gradient-to-b from-cyan-300 to-slate-300 rounded-full" />

          {/* Horizontal connector line */}
          {(project.members?.length ?? 0) > 1 && (
            <div
              className="h-0.5 bg-slate-300 rounded-full"
              style={{
                width: `calc(${((project.members?.length ?? 1) - 1) * 180}px)`,
                marginBottom: '-1px'
              }}
            />
          )}

          {/* Members row */}
          <div className="flex gap-4 flex-wrap justify-center">
            {project.members?.map((member) => (
              <div key={member.id} className="flex flex-col items-center">
                {/* Vertical line to member */}
                <div className="w-0.5 h-8 bg-slate-300 rounded-full mb-2" />
                <MemberCard member={member} />
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}

export function ProjectOrgChart({ projects }: Props) {
  // Initialize expanded nodes - expand all by default since projects are flat
  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(() => {
    const initial = new Set<string>()
    for (const project of projects) {
      initial.add(project.id)
    }
    return initial
  })

  const toggleNode = useCallback((id: string) => {
    setExpandedNodes(prev => {
      const next = new Set(prev)
      if (next.has(id)) {
        next.delete(id)
      } else {
        next.add(id)
      }
      return next
    })
  }, [])

  const expandAll = useCallback(() => {
    const allIds = new Set<string>()
    for (const project of projects) {
      allIds.add(project.id)
    }
    setExpandedNodes(allIds)
  }, [projects])

  const collapseAll = useCallback(() => {
    setExpandedNodes(new Set())
  }, [])

  if (projects.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-16 text-slate-500">
        <div className="w-16 h-16 rounded-full bg-slate-100 flex items-center justify-center mb-4">
          <FolderIcon className="h-8 w-8 text-slate-400" />
        </div>
        <p className="text-lg font-medium text-slate-700">No projects found</p>
        <p className="text-sm mt-2 text-slate-500">Create projects and assign team members to see the organization structure.</p>
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {/* Controls */}
      <div className="flex items-center justify-end gap-2">
        <button
          onClick={expandAll}
          className="px-3 py-1.5 text-sm text-slate-600 hover:text-slate-900 hover:bg-slate-100 rounded-lg transition-colors flex items-center gap-1"
        >
          <PlusIcon className="h-4 w-4" />
          Expand All
        </button>
        <button
          onClick={collapseAll}
          className="px-3 py-1.5 text-sm text-slate-600 hover:text-slate-900 hover:bg-slate-100 rounded-lg transition-colors flex items-center gap-1"
        >
          <MinusIcon className="h-4 w-4" />
          Collapse All
        </button>
      </div>

      {/* Chart container - no inner scroll, page scrolls */}
      <div className="pb-8 -mx-6 px-6">
        <div className="inline-flex flex-col items-center min-w-full py-6">
          {/* Projects grid */}
          <div className="flex flex-wrap gap-10 justify-center items-start">
            {projects.map((project) => (
              <ProjectNode
                key={project.id}
                project={project}
                expandedNodes={expandedNodes}
                toggleNode={toggleNode}
              />
            ))}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="apps/hrms/components/ui/Avatar.tsx">
'use client'

type AvatarProps = {
  src?: string | null
  alt?: string
  size?: 'sm' | 'md' | 'lg'
  className?: string
}

const sizeClasses = {
  sm: 'h-8 w-8 text-xs',
  md: 'h-10 w-10 text-sm',
  lg: 'h-12 w-12 text-base',
}

export function Avatar({ src, alt = '', size = 'md', className = '' }: AvatarProps) {
  const sizeClass = sizeClasses[size]

  // Get initials from alt text
  const initials = alt
    .split(' ')
    .map((word) => word[0])
    .join('')
    .slice(0, 2)
    .toUpperCase()

  if (src) {
    return (
      <img
        src={src}
        alt={alt}
        className={`${sizeClass} rounded-full object-cover ${className}`}
      />
    )
  }

  return (
    <div
      className={`${sizeClass} rounded-full bg-slate-200 flex items-center justify-center font-medium text-slate-600 ${className}`}
    >
      {initials || '?'}
    </div>
  )
}
</file>

<file path="apps/hrms/lib/constants.ts">
// Shared constants for HRMS

export const employmentTypeOptions = [
  { value: 'FULL_TIME', label: 'Employee' },
  { value: 'PART_TIME', label: 'Employee (Part-Time)' },
  { value: 'CONTRACT', label: 'Contractor' },
  { value: 'WORKING_PARTNER', label: 'Working Partner' },
  { value: 'INTERN', label: 'Intern' },
]

export const statusOptions = [
  { value: 'ACTIVE', label: 'Active' },
  { value: 'ON_LEAVE', label: 'On Leave' },
  { value: 'TERMINATED', label: 'Terminated' },
  { value: 'RESIGNED', label: 'Resigned' },
]

// Map employment type value to label
export const employmentTypeLabels: Record<string, string> = {
  FULL_TIME: 'Employee',
  PART_TIME: 'Employee (Part-Time)',
  CONTRACT: 'Contractor',
  WORKING_PARTNER: 'Working Partner',
  INTERN: 'Intern',
}

// Map status value to label
export const statusLabels: Record<string, string> = {
  ACTIVE: 'Active',
  ON_LEAVE: 'On Leave',
  TERMINATED: 'Terminated',
  RESIGNED: 'Resigned',
}
</file>

<file path="apps/hrms/lib/current-user.ts">
import { headers } from 'next/headers'
import { decodePortalSession, type PortalJwtPayload } from '@ecom-os/auth'
import { prisma } from './prisma'

export type CurrentEmployee = {
  id: string
  employeeId: string
  firstName: string
  lastName: string
  email: string
  department: string
  position: string
  reportsToId: string | null
  avatar: string | null
}

export type CurrentUser = {
  session: PortalJwtPayload
  employee: CurrentEmployee | null
}

export async function getCurrentUser(): Promise<CurrentUser | null> {
  const headersList = await headers()
  const cookieHeader = headersList.get('cookie')

  const session = await decodePortalSession({
    cookieHeader,
    appId: 'hrms',
  })

  if (!session?.email) {
    return null
  }

  const employee = await prisma.employee.findUnique({
    where: { email: session.email.toLowerCase() },
    select: {
      id: true,
      employeeId: true,
      firstName: true,
      lastName: true,
      email: true,
      department: true,
      position: true,
      reportsToId: true,
      avatar: true,
    },
  })

  return {
    session,
    employee,
  }
}

export async function getCurrentEmployeeId(): Promise<string | null> {
  const user = await getCurrentUser()
  return user?.employee?.id ?? null
}
</file>

<file path="apps/hrms/lib/google-admin-sync.ts">
import { prisma } from './prisma'
import { listAllUsers, isAdminConfigured, type GoogleUser } from './google-admin'

export type SyncResult = {
  created: number
  updated: number
  deactivated: number
  errors: string[]
}

function generateEmployeeId(index: number): string {
  return `EMP-${String(index).padStart(3, '0')}`
}

export async function syncGoogleAdminUsers(): Promise<SyncResult> {
  if (!isAdminConfigured()) {
    return { created: 0, updated: 0, deactivated: 0, errors: ['Google Admin not configured'] }
  }

  const result: SyncResult = { created: 0, updated: 0, deactivated: 0, errors: [] }

  try {
    // Fetch all users from Google Admin
    const googleUsers = await listAllUsers()

    // Filter out suspended/archived users
    const activeGoogleUsers = googleUsers.filter(u => !u.suspended && !u.archived)
    const googleUserIds = new Set(activeGoogleUsers.map(u => u.id))
    const googleEmails = new Set(activeGoogleUsers.map(u => u.primaryEmail.toLowerCase()))

    // Get all current employees with override flags
    type ExistingEmployee = {
      id: string
      googleId: string | null
      email: string
      employeeId: string
      departmentLocalOverride: boolean
      positionLocalOverride: boolean
    }
    const existingEmployees: ExistingEmployee[] = await prisma.employee.findMany({
      select: {
        id: true,
        googleId: true,
        email: true,
        employeeId: true,
        departmentLocalOverride: true,
        positionLocalOverride: true,
      }
    })

    // Find the highest employee ID number for generating new IDs
    let maxEmployeeNum = 0
    for (const emp of existingEmployees) {
      const match = emp.employeeId.match(/EMP-(\d+)/)
      if (match) {
        const num = parseInt(match[1], 10)
        if (num > maxEmployeeNum) maxEmployeeNum = num
      }
    }

    // Create maps for quick lookup
    const employeeByGoogleId = new Map(existingEmployees.filter((e) => e.googleId).map((e) => [e.googleId, e]))
    const employeeByEmail = new Map(existingEmployees.map((e) => [e.email.toLowerCase(), e]))

    // Process each Google user
    for (const gUser of activeGoogleUsers) {
      try {
        const email = gUser.primaryEmail.toLowerCase()
        const existingByGoogleId = employeeByGoogleId.get(gUser.id)
        const existingByEmail = employeeByEmail.get(email)
        const existing = existingByGoogleId || existingByEmail

        // Base data that always syncs from Google
        const baseData = {
          googleId: gUser.id,
          firstName: gUser.name?.givenName || gUser.primaryEmail.split('@')[0],
          lastName: gUser.name?.familyName || '',
          email: gUser.primaryEmail,
          phone: gUser.phones?.[0]?.value || null,
          avatar: gUser.thumbnailPhotoUrl || null,
        }

        if (existing) {
          // Build update data respecting local overrides
          const updateData: Record<string, unknown> = {
            ...baseData,
            status: 'ACTIVE',
          }

          // Only update department if local override is NOT set AND Google has a value
          if (!existing.departmentLocalOverride && gUser.organizations?.[0]?.department) {
            updateData.department = gUser.organizations[0].department
          }

          // Only update position if local override is NOT set AND Google has a value
          if (!existing.positionLocalOverride && gUser.organizations?.[0]?.title) {
            updateData.position = gUser.organizations[0].title
          }

          await prisma.employee.update({
            where: { id: existing.id },
            data: updateData,
          })
          result.updated++
        } else {
          // Create new employee with Google values (no overrides yet)
          maxEmployeeNum++
          await prisma.employee.create({
            data: {
              ...baseData,
              department: gUser.organizations?.[0]?.department || '',
              position: gUser.organizations?.[0]?.title || 'Employee',
              employeeId: generateEmployeeId(maxEmployeeNum),
              employmentType: 'FULL_TIME',
              joinDate: new Date(gUser.creationTime),
              status: 'ACTIVE',
              departmentLocalOverride: false,
              positionLocalOverride: false,
            },
          })
          result.created++
        }
      } catch (e: any) {
        result.errors.push(`Failed to sync ${gUser.primaryEmail}: ${e.message}`)
      }
    }

    // Deactivate employees not in Google Workspace (only those with googleId)
    for (const emp of existingEmployees) {
      if (emp.googleId && !googleUserIds.has(emp.googleId)) {
        try {
          await prisma.employee.update({
            where: { id: emp.id },
            data: { status: 'TERMINATED' },
          })
          result.deactivated++
        } catch (e: any) {
          result.errors.push(`Failed to deactivate ${emp.email}: ${e.message}`)
        }
      }
    }

    // Delete employees without googleId that don't match any Google email (bogus users)
    for (const emp of existingEmployees) {
      if (!emp.googleId && !googleEmails.has(emp.email.toLowerCase())) {
        try {
          await prisma.employee.delete({
            where: { id: emp.id },
          })
          result.deactivated++
        } catch (e: any) {
          result.errors.push(`Failed to delete bogus employee ${emp.email}: ${e.message}`)
        }
      }
    }

    console.log(`[Google Admin Sync] Created: ${result.created}, Updated: ${result.updated}, Deactivated: ${result.deactivated}`)
    if (result.errors.length > 0) {
      console.error(`[Google Admin Sync] Errors:`, result.errors)
    }

    return result
  } catch (e: any) {
    console.error('[Google Admin Sync] Failed:', e)
    result.errors.push(e.message)
    return result
  }
}
</file>

<file path="apps/hrms/lib/google-admin.ts">
import { google } from 'googleapis'

const CLIENT_ID = process.env.GOOGLE_CLIENT_ID || ''
const CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET || ''
const ADMIN_REFRESH_TOKEN = process.env.GOOGLE_ADMIN_REFRESH_TOKEN || ''
const ADMIN_DOMAIN = process.env.GOOGLE_ADMIN_DOMAIN || 'targonglobal.com'

const REQUEST_TIMEOUT = 15000 // 15 seconds timeout

export function isAdminConfigured() {
  return Boolean(CLIENT_ID && CLIENT_SECRET && ADMIN_REFRESH_TOKEN)
}

function getOAuth2Client() {
  if (!isAdminConfigured()) {
    throw new Error('Google Admin not configured. Set GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_ADMIN_REFRESH_TOKEN')
  }
  const oAuth2Client = new google.auth.OAuth2({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET })
  oAuth2Client.setCredentials({ refresh_token: ADMIN_REFRESH_TOKEN })
  return oAuth2Client
}

export type GoogleUser = {
  id: string
  primaryEmail: string
  name: {
    givenName: string
    familyName: string
    fullName: string
  }
  isAdmin: boolean
  isDelegatedAdmin: boolean
  suspended: boolean
  archived: boolean
  orgUnitPath: string
  creationTime: string
  lastLoginTime: string
  phones?: { value: string; type: string }[]
  organizations?: { title?: string; department?: string; primary?: boolean }[]
  thumbnailPhotoUrl?: string
}

export async function listAllUsers(): Promise<GoogleUser[]> {
  const auth = getOAuth2Client()
  const admin = google.admin({ version: 'directory_v1', auth })

  const allUsers: GoogleUser[] = []
  let pageToken: string | undefined = undefined

  let hasMore = true
  while (hasMore) {
    const res: Awaited<ReturnType<typeof admin.users.list>> = await admin.users.list({
      domain: ADMIN_DOMAIN,
      maxResults: 500,
      pageToken,
      projection: 'full',
    }, { timeout: REQUEST_TIMEOUT })

    if (res.data.users) {
      allUsers.push(...(res.data.users as GoogleUser[]))
    }
    pageToken = res.data.nextPageToken || undefined
    hasMore = !!pageToken
  }

  return allUsers
}

export async function getUser(userKey: string): Promise<GoogleUser> {
  const auth = getOAuth2Client()
  const admin = google.admin({ version: 'directory_v1', auth })

  const res = await admin.users.get({
    userKey,
    projection: 'full',
  }, { timeout: REQUEST_TIMEOUT })

  return res.data as GoogleUser
}
</file>

<file path="apps/hrms/lib/notification-service.ts">
import { prisma } from './prisma'

type EmployeeProfileFields = {
  id: string
  firstName: string
  reportsToId: string | null
  department: string
  position: string
  phone: string | null
  dateOfBirth: Date | null
  address: string | null
  city: string | null
  country: string | null
  emergencyContact: string | null
  emergencyPhone: string | null
}

type RequiredField = {
  field: keyof EmployeeProfileFields
  label: string
  skipValue?: string
}

const REQUIRED_FIELDS: RequiredField[] = [
  { field: 'reportsToId', label: 'Manager' },
  { field: 'department', label: 'Department', skipValue: 'General' },
  { field: 'position', label: 'Position', skipValue: 'Employee' },
  { field: 'phone', label: 'Phone Number' },
  { field: 'dateOfBirth', label: 'Date of Birth' },
  { field: 'address', label: 'Address' },
  { field: 'city', label: 'City' },
  { field: 'country', label: 'Country' },
  { field: 'emergencyContact', label: 'Emergency Contact Name' },
  { field: 'emergencyPhone', label: 'Emergency Contact Phone' },
]

export function getMissingFields(employee: EmployeeProfileFields): string[] {
  const missing: string[] = []

  for (const { field, label, skipValue } of REQUIRED_FIELDS) {
    const value = employee[field as keyof EmployeeProfileFields]

    // Check if field is null, undefined, or empty string
    if (value === null || value === undefined || value === '') {
      missing.push(label)
      continue
    }

    // Check if value matches a "default" value we should treat as incomplete
    if (skipValue && value === skipValue) {
      missing.push(label)
    }
  }

  return missing
}

export async function checkAndNotifyMissingFields(employeeId: string): Promise<void> {
  const employee = await prisma.employee.findUnique({
    where: { id: employeeId },
    select: {
      id: true,
      firstName: true,
      reportsToId: true,
      department: true,
      position: true,
      phone: true,
      dateOfBirth: true,
      address: true,
      city: true,
      country: true,
      emergencyContact: true,
      emergencyPhone: true,
    },
  })

  if (!employee) return

  const missingFields = getMissingFields(employee)

  if (missingFields.length > 0) {
    // Check if an unread profile notification already exists
    const existingNotification = await prisma.notification.findFirst({
      where: {
        employeeId: employee.id,
        type: 'PROFILE_INCOMPLETE',
        isRead: false,
      },
    })

    if (!existingNotification) {
      await prisma.notification.create({
        data: {
          type: 'PROFILE_INCOMPLETE',
          title: 'Complete Your Profile',
          message: `Please update the following information: ${missingFields.join(', ')}`,
          link: `/employees/${employee.id}/edit`,
          employeeId: employee.id,
        },
      })
    } else {
      // Update the existing notification with current missing fields
      await prisma.notification.update({
        where: { id: existingNotification.id },
        data: {
          message: `Please update the following information: ${missingFields.join(', ')}`,
        },
      })
    }
  } else {
    // Profile is complete - delete any existing profile incomplete notifications
    await prisma.notification.deleteMany({
      where: {
        employeeId: employee.id,
        type: 'PROFILE_INCOMPLETE',
      },
    })
  }
}

export async function runProfileCompletionCheckForAll(): Promise<{ checked: number; notified: number }> {
  const employees = await prisma.employee.findMany({
    where: { status: 'ACTIVE' },
    select: { id: true },
  })

  let notified = 0

  for (const emp of employees) {
    const employee = await prisma.employee.findUnique({
      where: { id: emp.id },
      select: {
        id: true,
        firstName: true,
        reportsToId: true,
        department: true,
        position: true,
        phone: true,
        dateOfBirth: true,
        address: true,
        city: true,
        country: true,
        emergencyContact: true,
        emergencyPhone: true,
      },
    })

    if (employee) {
      const missingFields = getMissingFields(employee)
      if (missingFields.length > 0) {
        await checkAndNotifyMissingFields(emp.id)
        notified++
      }
    }
  }

  console.log(`[Profile Check] Checked ${employees.length} employees, ${notified} need to complete profile`)

  return { checked: employees.length, notified }
}
</file>

<file path="apps/hrms/lib/permissions.ts">
import { prisma } from './prisma'

export type PermissionCheckResult = {
  canManage: boolean
  reason?: string
}

/**
 * Check if a user can manage (review/discipline) an employee
 *
 * A user can manage an employee if:
 * 1. They are the direct manager (employee.reportsToId === currentUserId)
 * 2. They are in the management chain (manager's manager, etc.)
 * 3. They are the head of the employee's department
 * 4. They have an ADMIN role
 */
export async function canManageEmployee(
  currentUserId: string,
  targetEmployeeId: string
): Promise<PermissionCheckResult> {
  // Can't manage yourself
  if (currentUserId === targetEmployeeId) {
    return { canManage: false, reason: 'Cannot manage yourself' }
  }

  // Get target employee details
  const targetEmployee = await prisma.employee.findUnique({
    where: { id: targetEmployeeId },
    select: {
      id: true,
      reportsToId: true,
      departmentId: true,
    },
  })

  if (!targetEmployee) {
    return { canManage: false, reason: 'Employee not found' }
  }

  // Check 1: Direct manager
  if (targetEmployee.reportsToId === currentUserId) {
    return { canManage: true, reason: 'Direct manager' }
  }

  // Check 2: In management chain (walk up the tree)
  let managerId = targetEmployee.reportsToId
  const visited = new Set<string>()
  while (managerId) {
    if (visited.has(managerId)) break // Prevent infinite loops
    visited.add(managerId)

    if (managerId === currentUserId) {
      return { canManage: true, reason: 'In management chain' }
    }

    const manager = await prisma.employee.findUnique({
      where: { id: managerId },
      select: { reportsToId: true },
    })
    managerId = manager?.reportsToId ?? null
  }

  // Check 3: Department head
  if (targetEmployee.departmentId) {
    const department = await prisma.department.findUnique({
      where: { id: targetEmployee.departmentId },
      select: { headId: true },
    })
    if (department?.headId === currentUserId) {
      return { canManage: true, reason: 'Department head' }
    }
  }

  // Check 4: Has ADMIN role
  const currentUser = await prisma.employee.findUnique({
    where: { id: currentUserId },
    select: {
      roles: {
        where: { name: { in: ['ADMIN', 'Admin', 'admin', 'HR_ADMIN', 'HR Admin'] } },
        select: { name: true },
      },
    },
  })
  if (currentUser?.roles && currentUser.roles.length > 0) {
    return { canManage: true, reason: 'Admin role' }
  }

  return { canManage: false, reason: 'No management relationship' }
}

/**
 * Get all employees that a user can manage
 */
export async function getManageableEmployees(currentUserId: string) {
  const currentUser = await prisma.employee.findUnique({
    where: { id: currentUserId },
    select: {
      id: true,
      roles: {
        where: { name: { in: ['ADMIN', 'Admin', 'admin', 'HR_ADMIN', 'HR Admin'] } },
        select: { name: true },
      },
    },
  })

  // If admin, return all employees except self
  if (currentUser?.roles && currentUser.roles.length > 0) {
    return prisma.employee.findMany({
      where: {
        id: { not: currentUserId },
        status: 'ACTIVE',
      },
      select: {
        id: true,
        employeeId: true,
        firstName: true,
        lastName: true,
        department: true,
        position: true,
      },
      orderBy: [{ firstName: 'asc' }, { lastName: 'asc' }],
    })
  }

  // Get direct reports
  const directReports = await prisma.employee.findMany({
    where: {
      reportsToId: currentUserId,
      status: 'ACTIVE',
    },
    select: {
      id: true,
      employeeId: true,
      firstName: true,
      lastName: true,
      department: true,
      position: true,
    },
  })

  // Get indirect reports (reports of direct reports, recursively)
  const allReports = new Map<string, typeof directReports[0]>()
  for (const report of directReports) {
    allReports.set(report.id, report)
  }

  // BFS to find all indirect reports
  const queue = directReports.map(r => r.id)
  while (queue.length > 0) {
    const managerId = queue.shift()!
    const indirectReports = await prisma.employee.findMany({
      where: {
        reportsToId: managerId,
        status: 'ACTIVE',
      },
      select: {
        id: true,
        employeeId: true,
        firstName: true,
        lastName: true,
        department: true,
        position: true,
      },
    })
    for (const report of indirectReports) {
      if (!allReports.has(report.id)) {
        allReports.set(report.id, report)
        queue.push(report.id)
      }
    }
  }

  // Get employees in departments led by current user
  const ledDepartments = await prisma.department.findMany({
    where: { headId: currentUserId },
    select: { id: true },
  })

  if (ledDepartments.length > 0) {
    const deptEmployees = await prisma.employee.findMany({
      where: {
        departmentId: { in: ledDepartments.map(d => d.id) },
        id: { not: currentUserId },
        status: 'ACTIVE',
      },
      select: {
        id: true,
        employeeId: true,
        firstName: true,
        lastName: true,
        department: true,
        position: true,
      },
    })
    for (const emp of deptEmployees) {
      allReports.set(emp.id, emp)
    }
  }

  // Sort and return
  return Array.from(allReports.values()).sort((a, b) =>
    `${a.firstName} ${a.lastName}`.localeCompare(`${b.firstName} ${b.lastName}`)
  )
}

/**
 * Check if user has admin role
 */
export async function isAdmin(userId: string): Promise<boolean> {
  const user = await prisma.employee.findUnique({
    where: { id: userId },
    select: {
      roles: {
        where: { name: { in: ['ADMIN', 'Admin', 'admin', 'HR_ADMIN', 'HR Admin'] } },
        select: { name: true },
      },
    },
  })
  return (user?.roles?.length ?? 0) > 0
}
</file>

<file path="apps/hrms/lib/startup.ts">
import { syncGoogleAdminUsers } from './google-admin-sync'
import { isAdminConfigured } from './google-admin'
import { runProfileCompletionCheckForAll } from './notification-service'

let syncInitialized = false

export async function initializeGoogleAdminSync() {
  if (syncInitialized) return
  syncInitialized = true

  if (!isAdminConfigured()) {
    console.log('[Startup] Google Admin not configured, skipping sync')
    return
  }

  console.log('[Startup] Running initial Google Admin sync...')
  try {
    const result = await syncGoogleAdminUsers()
    console.log(`[Startup] Sync complete - Created: ${result.created}, Updated: ${result.updated}, Deactivated: ${result.deactivated}`)

    // Run profile completion check after sync (wrapped to handle errors gracefully)
    runProfileCompletionCheckForAll()
      .then((result) => console.log(`[Profile Check] Checked: ${result.checked}, Notified: ${result.notified}`))
      .catch((err) => console.error('[Profile Check] Failed:', err))
  } catch (e) {
    console.error('[Startup] Google Admin sync failed:', e)
  }
}

// Auto-sync every 30 minutes
let syncInterval: NodeJS.Timeout | null = null

export function startPeriodicSync(intervalMs = 30 * 60 * 1000) {
  if (syncInterval) return

  syncInterval = setInterval(async () => {
    if (!isAdminConfigured()) return
    console.log('[Periodic Sync] Running Google Admin sync...')
    try {
      const result = await syncGoogleAdminUsers()
      console.log(`[Periodic Sync] Sync complete - Created: ${result.created}, Updated: ${result.updated}, Deactivated: ${result.deactivated}`)

      // Run profile completion check after sync
      runProfileCompletionCheckForAll()
        .then((profileResult) => console.log(`[Periodic Sync] Profile check - Checked: ${profileResult.checked}, Notified: ${profileResult.notified}`))
        .catch((err) => console.error('[Periodic Sync] Profile check failed:', err))
    } catch (e) {
      console.error('[Periodic Sync] Google Admin sync failed:', e)
    }
  }, intervalMs)

  console.log(`[Startup] Periodic sync scheduled every ${intervalMs / 60000} minutes`)
}

export function stopPeriodicSync() {
  if (syncInterval) {
    clearInterval(syncInterval)
    syncInterval = null
  }
}
</file>

<file path="apps/hrms/prisma/migrations/20251213050000_add_department_hierarchy/migration.sql">
-- Add department hierarchy fields
ALTER TABLE "Department" ADD COLUMN IF NOT EXISTS "kpi" TEXT;
ALTER TABLE "Department" ADD COLUMN IF NOT EXISTS "headId" TEXT;
ALTER TABLE "Department" ADD COLUMN IF NOT EXISTS "parentId" TEXT;

-- Add foreign key for department head
ALTER TABLE "Department" ADD CONSTRAINT "Department_headId_fkey" FOREIGN KEY ("headId") REFERENCES "Employee"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- Add self-referential foreign key for department hierarchy
ALTER TABLE "Department" ADD CONSTRAINT "Department_parentId_fkey" FOREIGN KEY ("parentId") REFERENCES "Department"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- Add indexes
CREATE INDEX IF NOT EXISTS "Department_headId_idx" ON "Department"("headId");
CREATE INDEX IF NOT EXISTS "Department_parentId_idx" ON "Department"("parentId");
</file>

<file path="apps/hrms/instrumentation.ts">
export async function register() {
  // Only run on server
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    const { initializeGoogleAdminSync, startPeriodicSync } = await import('./lib/startup')

    // Run initial sync after a short delay to let the server fully start
    setTimeout(async () => {
      await initializeGoogleAdminSync()
      startPeriodicSync() // Every 30 minutes
    }, 5000)
  }
}
</file>

<file path="apps/hrms/leave_policy_backup.csv">
id,title,region,summary,content,fileUrl,version,effectiveDate,status,createdAt,updatedAt
cmj0j838h0000xvxs09z305vv,Leave Policy Pakistan,Pakistan,Standard Leave Policy for Pakistan,"# Leave Policy — Pakistan

## Leave Entitlements

| Leave Type | Days | Paid/Unpaid |
|------------|------|-------------|
| PTO (Vacation + Personal + Sick) | 15 days/year | Paid |
| Public Holidays | 15 days/year | Paid |
| Maternity Leave (statutory) | 90 days | Paid |
| Paternity Leave | 2 weeks | Paid |
| Bereavement (Immediate Family) | 5 days | Paid |
| Bereavement (Extended Family) | 2 days | Paid |
| **Total (excl. Parental)** | **37 days** | |

## PTO Rules

| Rule | Details |
|------|---------|
| Usage | Vacation, sick days, personal — no reason required |
| Carryover | Up to 5 unused days roll over to next year |
| Encashment | Paid out on termination only if notice period completed |

## Public Holidays

| Holiday | Date |
|---------|------|
| Kashmir Day | February 5 |
| Pakistan Day | March 23 |
| Labour Day | May 1 |
| Independence Day | August 14 |
| Iqbal Day | November 9 |
| Quaid-e-Azam Day | December 25 |
| Eid ul-Fitr | 3 days |
| Eid ul-Adha | 3 days |
| Eid Milad-un-Nabi | 1 day |
| Ashura (9th & 10th Muharram) | 2 days |

## Parental Leave

| Type | Days |
|------|------|
| Maternity | 90 days (statutory) |
| Paternity | 2 weeks |

## Bereavement

| Category | Days | Includes |
|----------|------|----------|
| Immediate Family | 5 days | Spouse, children, parents, siblings |
| Extended Family | 2 days | Other relatives |

## Leave Request Notice

| Situation | Notice Required |
|-----------|-----------------|
| Emergency/Illness | As soon as possible |
| 1-2 days | 48 hours |
| 3+ days | 1 week |

## Important

**All leave requests must be explicitly approved by your manager before you proceed. Taking leave without prior approval is not permitted. Unapproved absences may result in disciplinary action as the company sees fit, up to and including termination.**",,1.0,2025-12-10 00:00:00,ACTIVE,2025-12-10 21:39:24.638,2025-12-10 21:49:02.357
cmj0jlfyb0000xv5zdy1gtg74,Leave Policy Kansas,Kansas (USA),Standard Leave Policy for Kansas,"# Leave Policy — US (Kansas)

## Leave Entitlements

| Leave Type | Days | Paid/Unpaid |
|------------|------|-------------|
| PTO (Vacation + Personal + Sick) | 15 days/year | Paid |
| Public Holidays | 10 days/year | Paid |
| Parental Leave | 4 weeks | Paid |
| Bereavement (Immediate Family) | 5 days | Paid |
| Bereavement (Extended Family) | 2 days | Paid |
| Jury Duty | As needed | Unpaid |
| **Total (excl. Jury Duty)** | **32 days** | |

## PTO Rules

| Rule | Details |
|------|---------|
| Usage | Vacation, sick days, personal — no reason required |
| Carryover | Up to 5 unused days roll over to next year |
| Payout | No payout if notice period not completed |

## Public Holidays

| Holiday | Date |
|---------|------|
| New Year's Day | January 1 |
| Martin Luther King Jr. Day | 3rd Monday of January |
| Memorial Day | Last Monday of May |
| Independence Day | July 4 |
| Labor Day | 1st Monday of September |
| Thanksgiving Day | 4th Thursday of November |
| Day after Thanksgiving | 4th Friday of November |
| Christmas Eve | December 24 |
| Christmas Day | December 25 |
| New Year's Eve | December 31 |

## Bereavement

| Category | Days | Includes |
|----------|------|----------|
| Immediate Family | 5 days | Spouse, children, parents, siblings, grandparents |
| Extended Family | 2 days | Other relatives |

## Leave Request Notice

| Situation | Notice Required |
|-----------|-----------------|
| Emergency/Illness | As soon as possible |
| 1-2 days | 48 hours |
| 3+ days | 1 week |

## Important

**All leave requests must be explicitly approved by your manager before you proceed. Taking leave without prior approval is not permitted. Unapproved absences may result in disciplinary action as the company sees fit, up to and including termination.**",,1.0,2025-12-10 00:00:00,ACTIVE,2025-12-10 21:49:47.651,2025-12-10 21:49:56.254
</file>

<file path="apps/hrms/leave_policy_content_backup.txt">
Leave Policy Pakistan|Pakistan|# Leave Policy — Pakistan

## Leave Entitlements

| Leave Type | Days | Paid/Unpaid |
|------------|------|-------------|
| PTO (Vacation + Personal + Sick) | 15 days/year | Paid |
| Public Holidays | 15 days/year | Paid |
| Maternity Leave (statutory) | 90 days | Paid |
| Paternity Leave | 2 weeks | Paid |
| Bereavement (Immediate Family) | 5 days | Paid |
| Bereavement (Extended Family) | 2 days | Paid |
| **Total (excl. Parental)** | **37 days** | |

## PTO Rules

| Rule | Details |
|------|---------|
| Usage | Vacation, sick days, personal — no reason required |
| Carryover | Up to 5 unused days roll over to next year |
| Encashment | Paid out on termination only if notice period completed |

## Public Holidays

| Holiday | Date |
|---------|------|
| Kashmir Day | February 5 |
| Pakistan Day | March 23 |
| Labour Day | May 1 |
| Independence Day | August 14 |
| Iqbal Day | November 9 |
| Quaid-e-Azam Day | December 25 |
| Eid ul-Fitr | 3 days |
| Eid ul-Adha | 3 days |
| Eid Milad-un-Nabi | 1 day |
| Ashura (9th & 10th Muharram) | 2 days |

## Parental Leave

| Type | Days |
|------|------|
| Maternity | 90 days (statutory) |
| Paternity | 2 weeks |

## Bereavement

| Category | Days | Includes |
|----------|------|----------|
| Immediate Family | 5 days | Spouse, children, parents, siblings |
| Extended Family | 2 days | Other relatives |

## Leave Request Notice

| Situation | Notice Required |
|-----------|-----------------|
| Emergency/Illness | As soon as possible |
| 1-2 days | 48 hours |
| 3+ days | 1 week |

## Important

**All leave requests must be explicitly approved by your manager before you proceed. Taking leave without prior approval is not permitted. Unapproved absences may result in disciplinary action as the company sees fit, up to and including termination.**
Leave Policy Kansas|Kansas (USA)|# Leave Policy — US (Kansas)

## Leave Entitlements

| Leave Type | Days | Paid/Unpaid |
|------------|------|-------------|
| PTO (Vacation + Personal + Sick) | 15 days/year | Paid |
| Public Holidays | 10 days/year | Paid |
| Parental Leave | 4 weeks | Paid |
| Bereavement (Immediate Family) | 5 days | Paid |
| Bereavement (Extended Family) | 2 days | Paid |
| Jury Duty | As needed | Unpaid |
| **Total (excl. Jury Duty)** | **32 days** | |

## PTO Rules

| Rule | Details |
|------|---------|
| Usage | Vacation, sick days, personal — no reason required |
| Carryover | Up to 5 unused days roll over to next year |
| Payout | No payout if notice period not completed |

## Public Holidays

| Holiday | Date |
|---------|------|
| New Year's Day | January 1 |
| Martin Luther King Jr. Day | 3rd Monday of January |
| Memorial Day | Last Monday of May |
| Independence Day | July 4 |
| Labor Day | 1st Monday of September |
| Thanksgiving Day | 4th Thursday of November |
| Day after Thanksgiving | 4th Friday of November |
| Christmas Eve | December 24 |
| Christmas Day | December 25 |
| New Year's Eve | December 31 |

## Bereavement

| Category | Days | Includes |
|----------|------|----------|
| Immediate Family | 5 days | Spouse, children, parents, siblings, grandparents |
| Extended Family | 2 days | Other relatives |

## Leave Request Notice

| Situation | Notice Required |
|-----------|-----------------|
| Emergency/Illness | As soon as possible |
| 1-2 days | 48 hours |
| 3+ days | 1 week |

## Important

**All leave requests must be explicitly approved by your manager before you proceed. Taking leave without prior approval is not permitted. Unapproved absences may result in disciplinary action as the company sees fit, up to and including termination.**
</file>

<file path="apps/hrms/middleware.ts">
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { hasPortalSession } from '@ecom-os/auth'
import { portalUrl } from '@/lib/portal'

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  const basePath = process.env.BASE_PATH || ''
  const normalizedPath = basePath && pathname.startsWith(basePath)
    ? pathname.slice(basePath.length) || '/'
    : pathname

  // Public routes - only specific endpoints, NOT all /api/ routes
  const PUBLIC_PREFIXES = ['/_next', '/favicon.ico']
  const PUBLIC_ROUTES = ['/', '/health', '/api/health', '/api/setup/departments']
  const isPublic =
    PUBLIC_ROUTES.includes(normalizedPath) ||
    PUBLIC_PREFIXES.some((p) => normalizedPath.startsWith(p))

  if (!isPublic) {
    const debug = process.env.NODE_ENV !== 'production'
    const hasSession = await hasPortalSession({
      request,
      appId: 'hrms',
      portalUrl: process.env.PORTAL_AUTH_URL,
      debug,
    })

    if (!hasSession) {
      // For API routes, return 401 instead of redirect
      if (normalizedPath.startsWith('/api/')) {
        return NextResponse.json(
          { error: 'Authentication required' },
          { status: 401 }
        )
      }

      const login = portalUrl('/login', request)
      if (debug) {
        console.log('[hrms middleware] missing session, redirecting to', login.toString())
      }
      login.searchParams.set('callbackUrl', request.nextUrl.toString())
      return NextResponse.redirect(login)
    }
  }

  return NextResponse.next()
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}
</file>

<file path="apps/hrms/next.config.js">
const path = require('path')

const basePath = process.env.BASE_PATH || '/hrms'
const { version } = require('./package.json')
const resolvedVersion = process.env.NEXT_PUBLIC_VERSION || version

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  poweredByHeader: false,
  basePath,
  assetPrefix: basePath,
  env: {
    NEXT_PUBLIC_VERSION: resolvedVersion,
  },
  outputFileTracingRoot: path.join(__dirname, '../..'),
  trailingSlash: false,
  // Turbopack is the default bundler in Next.js 16
  turbopack: {},
}

module.exports = nextConfig
</file>

<file path="packages/auth/dist/index.d.ts">
import type { NextAuthConfig } from 'next-auth';
import { z } from 'zod';
export type NextAuthOptions = NextAuthConfig;
export type SameSite = 'lax' | 'strict' | 'none';
export interface CookieDomainOptions {
    domain: string;
    secure?: boolean;
    sameSite?: SameSite;
    appId?: string;
}
/**
 * Build consistent cookie names and options for NextAuth across apps.
 * - In production (secure), uses __Secure- prefix for session/callback and __Host- for csrf (no domain).
 * - In development, optionally prefixes cookie names with `${appId}.` to avoid collisions on localhost.
 */
export declare function buildCookieOptions(opts: CookieDomainOptions): NextAuthConfig["cookies"];
export declare const AuthEnvSchema: z.ZodObject<{
    NEXTAUTH_SECRET: z.ZodString;
    NEXTAUTH_URL: z.ZodOptional<z.ZodString>;
    COOKIE_DOMAIN: z.ZodString;
}, "strip", z.ZodTypeAny, {
    NEXTAUTH_SECRET: string;
    COOKIE_DOMAIN: string;
    NEXTAUTH_URL?: string | undefined;
}, {
    NEXTAUTH_SECRET: string;
    COOKIE_DOMAIN: string;
    NEXTAUTH_URL?: string | undefined;
}>;
export interface SharedAuthOptions {
    cookieDomain: string;
    appId?: string;
}
export interface DevAuthDefaultsOptions {
    appId?: string;
    port?: string | number;
    baseUrl?: string;
    cookieDomain?: string;
    portalUrl?: string;
    publicPortalUrl?: string;
    allowDefaults?: boolean;
}
/**
 * Provide sane defaults for local development so NextAuth stops warning about missing env vars.
 */
export declare function applyDevAuthDefaults(options?: DevAuthDefaultsOptions): void;
export declare function withSharedAuth(base: NextAuthConfig, optsOrDomain: SharedAuthOptions | string): NextAuthConfig;
/**
 * Helper to derive the likely session cookie names to probe in middleware.
 * Always include both secure (__Secure-) and non-secure variants because
 * different environments flip between dev/prod cookie prefixes.
 */
export declare function getCandidateSessionCookieNames(appId?: string): string[];
export interface PortalJwtPayload extends Record<string, unknown> {
    sub?: string;
    email?: string;
    name?: string;
    roles?: RolesClaim;
    apps?: string[];
    exp?: number;
}
export interface DecodePortalSessionOptions {
    cookieHeader?: string | null;
    cookieNames?: string[];
    appId?: string;
    secret?: string;
    debug?: boolean;
}
export declare function decodePortalSession(options?: DecodePortalSessionOptions): Promise<PortalJwtPayload | null>;
export type PortalUrlRequestLike = {
    headers: Headers;
    url: string;
};
export interface PortalUrlOptions {
    request?: PortalUrlRequestLike;
    fallbackOrigin?: string;
}
export interface PortalSessionProbeOptions {
    request: Request;
    appId?: string;
    cookieNames?: string[];
    secret?: string;
    portalUrl?: string;
    debug?: boolean;
    fetchImpl?: typeof fetch;
}
export declare function resolvePortalAuthOrigin(options?: PortalUrlOptions): string;
export declare function buildPortalUrl(path: string, options?: PortalUrlOptions): URL;
/**
 * Determine whether a request already carries a valid portal NextAuth session.
 * - Tries to decode the session cookie locally using the shared secret.
 * - Falls back to probing the portal `/api/auth/session` endpoint to handle
 *   environments where app-specific secrets differ from the portal.
 */
export declare function hasPortalSession(options: PortalSessionProbeOptions): Promise<boolean>;
export type AppEntitlement = {
    role: string;
    departments?: string[];
    depts?: string[];
};
export type RolesClaim = Record<string, AppEntitlement>;
export declare function getAppEntitlement(roles: unknown, appId: string): AppEntitlement | undefined;
</file>

<file path="packages/auth/dist/index.js">
import { decode } from 'next-auth/jwt';
import { z } from 'zod';
/**
 * Build consistent cookie names and options for NextAuth across apps.
 * - In production (secure), uses __Secure- prefix for session/callback and __Host- for csrf (no domain).
 * - In development, optionally prefixes cookie names with `${appId}.` to avoid collisions on localhost.
 */
export function buildCookieOptions(opts) {
    const secure = opts.secure ?? (process.env.NODE_ENV === 'production');
    const sameSite = opts.sameSite ?? 'lax';
    const appPrefix = !secure && opts.appId ? `${opts.appId}.` : '';
    const sessionTokenName = secure
        ? '__Secure-next-auth.session-token'
        : `${appPrefix}next-auth.session-token`;
    const callbackUrlName = secure
        ? '__Secure-next-auth.callback-url'
        : `${appPrefix}next-auth.callback-url`;
    const csrfTokenName = secure
        ? '__Host-next-auth.csrf-token'
        : `${appPrefix}next-auth.csrf-token`;
    // Determine if we should set the Domain attribute on cookies.
    // On localhost / 127.0.0.1, setting Domain causes cookies to be rejected by browsers.
    const rawDomain = (opts.domain || '').trim().toLowerCase();
    const isIPv4 = /^\d+\.\d+\.\d+\.\d+$/.test(rawDomain);
    const isLocalhost = rawDomain === 'localhost' || rawDomain.endsWith('.localhost');
    const shouldSetDomain = !!rawDomain && !isIPv4 && !isLocalhost;
    const domainOption = shouldSetDomain ? { domain: rawDomain } : {};
    return {
        sessionToken: {
            name: sessionTokenName,
            options: {
                httpOnly: true,
                sameSite,
                path: '/',
                secure,
                // Only set Domain when valid (never on localhost/IP). Host-only cookies work in dev.
                ...domainOption,
            },
        },
        callbackUrl: {
            name: callbackUrlName,
            options: {
                sameSite,
                path: '/',
                secure,
                ...domainOption,
            },
        },
        csrfToken: {
            name: csrfTokenName,
            options: {
                httpOnly: true,
                sameSite,
                path: '/',
                secure,
                // Important: __Host- cookies cannot set domain in secure mode.
                // In dev, also avoid Domain on localhost/IP to ensure cookie is accepted.
                ...(secure ? {} : domainOption),
            },
        },
    };
}
function parseCookieHeader(header) {
    const map = new Map();
    if (!header)
        return map;
    const parts = header.split(';');
    for (const part of parts) {
        const [rawName, ...rawValue] = part.split('=');
        if (!rawName)
            continue;
        const name = rawName.trim();
        if (!name)
            continue;
        const value = rawValue.join('=').trim();
        const list = map.get(name);
        if (list) {
            list.push(value);
        }
        else {
            map.set(name, [value]);
        }
    }
    return map;
}
export const AuthEnvSchema = z.object({
    NEXTAUTH_SECRET: z.string().min(16),
    NEXTAUTH_URL: z.string().url().optional(),
    COOKIE_DOMAIN: z.string().min(1), // e.g. .targonglobal.com
});
/**
 * Compose app-specific NextAuth options with shared, secure defaults.
 */
const truthyValues = new Set(['1', 'true', 'yes', 'on']);
/**
 * Provide sane defaults for local development so NextAuth stops warning about missing env vars.
 */
export function applyDevAuthDefaults(options = {}) {
    const env = process.env.NODE_ENV ?? 'development';
    const isDevLike = env === 'development' || env === 'test';
    if (!isDevLike)
        return;
    const allowDefaultsEnv = truthyValues.has(String(process.env.ALLOW_DEV_AUTH_DEFAULTS ?? '').toLowerCase());
    const allowDefaults = options.allowDefaults ?? allowDefaultsEnv;
    const missing = [];
    const resolveSecret = () => {
        const existingSecret = process.env.PORTAL_AUTH_SECRET ?? process.env.NEXTAUTH_SECRET;
        if (existingSecret) {
            if (!process.env.NEXTAUTH_SECRET) {
                process.env.NEXTAUTH_SECRET = existingSecret;
            }
            return;
        }
        if (allowDefaults) {
            const suffix = options.appId ? `-${options.appId}` : '';
            process.env.NEXTAUTH_SECRET = `dev-only-nextauth-secret${suffix}-change-me`;
            return;
        }
        missing.push('PORTAL_AUTH_SECRET or NEXTAUTH_SECRET');
    };
    const ensureValue = (current, label, fallback) => {
        if (current && current.trim() !== '') {
            return current;
        }
        if (allowDefaults && fallback) {
            return fallback;
        }
        missing.push(label);
        return undefined;
    };
    resolveSecret();
    const port = options.port ?? process.env.PORT ?? 3000;
    const computedBaseUrl = options.baseUrl ?? `http://localhost:${port}`;
    const nextAuthUrl = ensureValue(process.env.NEXTAUTH_URL, 'NEXTAUTH_URL', allowDefaults ? String(computedBaseUrl) : undefined);
    if (nextAuthUrl && !process.env.NEXTAUTH_URL) {
        process.env.NEXTAUTH_URL = nextAuthUrl;
    }
    const portalUrl = ensureValue(process.env.PORTAL_AUTH_URL, 'PORTAL_AUTH_URL', allowDefaults ? options.portalUrl ?? nextAuthUrl : undefined);
    if (portalUrl && !process.env.PORTAL_AUTH_URL) {
        process.env.PORTAL_AUTH_URL = portalUrl;
    }
    const publicPortalUrl = ensureValue(process.env.NEXT_PUBLIC_PORTAL_AUTH_URL, 'NEXT_PUBLIC_PORTAL_AUTH_URL', allowDefaults ? options.publicPortalUrl ?? portalUrl ?? nextAuthUrl : undefined);
    if (publicPortalUrl && !process.env.NEXT_PUBLIC_PORTAL_AUTH_URL) {
        process.env.NEXT_PUBLIC_PORTAL_AUTH_URL = publicPortalUrl;
    }
    const cookieDomain = ensureValue(process.env.COOKIE_DOMAIN, 'COOKIE_DOMAIN', allowDefaults ? options.cookieDomain : undefined);
    if (cookieDomain && !process.env.COOKIE_DOMAIN) {
        process.env.COOKIE_DOMAIN = cookieDomain;
    }
    if (missing.length > 0) {
        throw new Error(`[auth] Missing required auth environment variables: ${missing.join(', ')}`);
    }
    if (process.env.NEXTAUTH_DEBUG === undefined) {
        // Default to off; callers can opt-in with NEXTAUTH_DEBUG=1 if needed.
        process.env.NEXTAUTH_DEBUG = '0';
    }
}
export function withSharedAuth(base, optsOrDomain) {
    const opts = typeof optsOrDomain === 'string'
        ? { cookieDomain: optsOrDomain }
        : optsOrDomain;
    const envDebug = process.env.NEXTAUTH_DEBUG ? truthyValues.has(process.env.NEXTAUTH_DEBUG.toLowerCase()) : undefined;
    const baseDebug = typeof base.debug === 'boolean' ? base.debug : undefined;
    const debug = envDebug ?? baseDebug ?? false;
    const resolvedSecret = process.env.NEXTAUTH_SECRET ?? base.secret;
    const envMode = process.env.NODE_ENV ?? 'development';
    const isDevLike = envMode === 'development' || envMode === 'test';
    if (!resolvedSecret) {
        throw new Error('NEXTAUTH_SECRET (or PORTAL_AUTH_SECRET) must be provided for shared auth.');
    }
    if (!isDevLike) {
        const result = AuthEnvSchema.safeParse({
            NEXTAUTH_SECRET: resolvedSecret,
            NEXTAUTH_URL: process.env.NEXTAUTH_URL,
            COOKIE_DOMAIN: process.env.COOKIE_DOMAIN ?? opts.cookieDomain,
        });
        if (!result.success) {
            const detail = result.error.issues
                .map((issue) => `${issue.path.join('.') || 'config'}: ${issue.message}`)
                .join('; ');
            throw new Error(`Missing required auth configuration: ${detail}`);
        }
    }
    return {
        // Keep base providers/callbacks etc. from app
        ...base,
        session: {
            strategy: 'jwt',
            maxAge: 30 * 24 * 60 * 60,
            ...base.session,
        },
        debug,
        secret: resolvedSecret,
        cookies: {
            ...buildCookieOptions({ domain: opts.cookieDomain, sameSite: 'lax', appId: opts.appId }),
            ...base.cookies,
        },
    };
}
/**
 * Helper to derive the likely session cookie names to probe in middleware.
 * Always include both secure (__Secure-) and non-secure variants because
 * different environments flip between dev/prod cookie prefixes.
 */
export function getCandidateSessionCookieNames(appId) {
    const names = new Set([
        '__Secure-next-auth.session-token',
        'next-auth.session-token',
    ]);
    const portalAppIdRaw = typeof process !== 'undefined' && process.env
        ? (process.env.PORTAL_APP_ID ?? 'ecomos')
        : 'ecomos';
    const normalizedPortalAppId = portalAppIdRaw.trim();
    const addNamesFor = (id) => {
        const normalized = id?.trim();
        if (!normalized)
            return;
        names.add(`${normalized}.next-auth.session-token`);
        names.add(`__Secure-${normalized}.next-auth.session-token`);
    };
    addNamesFor(appId);
    const normalizedAppId = appId?.trim() ?? '';
    if (normalizedPortalAppId && normalizedPortalAppId !== normalizedAppId) {
        addNamesFor(normalizedPortalAppId);
    }
    return Array.from(names);
}
export async function decodePortalSession(options = {}) {
    const { cookieHeader, cookieNames, appId, secret, debug = truthyValues.has(String(process.env.NEXTAUTH_DEBUG ?? '').toLowerCase()), } = options;
    const header = cookieHeader ?? '';
    if (!header) {
        if (debug) {
            console.warn('[auth] decodePortalSession: missing cookie header');
        }
        return null;
    }
    const names = Array.from(new Set((cookieNames && cookieNames.length > 0)
        ? cookieNames
        : getCandidateSessionCookieNames(appId)));
    const resolvedSecret = secret
        || process.env.PORTAL_AUTH_SECRET
        || process.env.NEXTAUTH_SECRET;
    if (!resolvedSecret) {
        if (debug) {
            console.warn('[auth] decodePortalSession: missing shared secret');
        }
        return null;
    }
    const cookies = parseCookieHeader(header);
    for (const name of names) {
        const values = cookies.get(name);
        if (!values?.length) {
            continue;
        }
        for (const raw of values) {
            if (!raw)
                continue;
            try {
                // In v5, salt is required - use the cookie name as salt (typical pattern)
                const decoded = await decode({
                    token: raw,
                    secret: resolvedSecret,
                    salt: name, // Use the cookie name as salt
                });
                if (decoded && typeof decoded === 'object') {
                    return decoded;
                }
            }
            catch (error) {
                if (debug) {
                    const detail = error instanceof Error ? error.message : String(error);
                    console.warn('[auth] decodePortalSession: failed to decode token', name, 'value length', raw.length, detail);
                }
            }
        }
    }
    return null;
}
const DEFAULT_PORTAL_DEV = 'http://localhost:3000';
const missingSecretWarnings = new Set();
function normalizeOrigin(raw) {
    if (!raw)
        return undefined;
    const trimmed = raw.trim();
    if (!trimmed)
        return undefined;
    const hasScheme = /^[a-z][a-z0-9+.-]*:\/\//i.test(trimmed);
    const candidates = hasScheme ? [trimmed] : [`https://${trimmed}`, `http://${trimmed}`];
    for (const candidate of candidates) {
        try {
            const url = new URL(candidate);
            return url.origin;
        }
        catch {
            continue;
        }
    }
    return undefined;
}
function originFromRequestLike(request) {
    if (!request)
        return undefined;
    const headers = request.headers;
    const forwardedProto = headers.get('x-forwarded-proto');
    const forwardedHost = headers.get('x-forwarded-host');
    const primaryHost = forwardedHost ? forwardedHost.split(',')[0]?.trim() : undefined;
    const host = primaryHost || headers.get('host');
    const url = request.url ? new URL(request.url) : null;
    const fallbackProto = url?.protocol ? url.protocol.replace(/:$/, '') : undefined;
    const protocol = forwardedProto?.split(',')[0]?.trim() || fallbackProto || 'http';
    const candidate = host ? `${protocol}://${host}` : url?.origin;
    return normalizeOrigin(candidate ?? undefined);
}
function originFromGlobalScope() {
    if (typeof globalThis === 'undefined') {
        return undefined;
    }
    const maybeLocation = globalThis?.location;
    if (maybeLocation && typeof maybeLocation.origin === 'string') {
        return normalizeOrigin(maybeLocation.origin);
    }
    return undefined;
}
export function resolvePortalAuthOrigin(options) {
    const envCandidates = [
        process.env.NEXT_PUBLIC_PORTAL_AUTH_URL,
        process.env.PORTAL_AUTH_URL,
        process.env.NEXTAUTH_URL,
    ];
    for (const candidate of envCandidates) {
        const normalized = normalizeOrigin(candidate);
        if (normalized) {
            return normalized;
        }
    }
    const requestOrigin = originFromRequestLike(options?.request);
    if (requestOrigin) {
        return requestOrigin;
    }
    const fallbackOrigin = normalizeOrigin(options?.fallbackOrigin);
    if (fallbackOrigin) {
        return fallbackOrigin;
    }
    const globalOrigin = originFromGlobalScope();
    if (globalOrigin) {
        return globalOrigin;
    }
    const allowDefaults = truthyValues.has(String(process.env.ALLOW_DEV_AUTH_DEFAULTS ?? '').toLowerCase());
    if (allowDefaults && process.env.NODE_ENV !== 'production') {
        return DEFAULT_PORTAL_DEV;
    }
    throw new Error('Portal auth origin is not configured. Set PORTAL_AUTH_URL or NEXT_PUBLIC_PORTAL_AUTH_URL.');
}
export function buildPortalUrl(path, options) {
    const origin = resolvePortalAuthOrigin(options);
    return new URL(path, origin);
}
/**
 * Determine whether a request already carries a valid portal NextAuth session.
 * - Tries to decode the session cookie locally using the shared secret.
 * - Falls back to probing the portal `/api/auth/session` endpoint to handle
 *   environments where app-specific secrets differ from the portal.
 */
export async function hasPortalSession(options) {
    const { request, appId, cookieNames, debug = options.debug ?? truthyValues.has(String(process.env.NEXTAUTH_DEBUG ?? '').toLowerCase()), fetchImpl, } = options;
    const names = Array.from(new Set((cookieNames && cookieNames.length > 0)
        ? cookieNames
        : getCandidateSessionCookieNames(appId)));
    const cookieHeader = request.headers.get('cookie');
    const sharedSecret = options.secret
        || process.env.PORTAL_AUTH_SECRET
        || process.env.NEXTAUTH_SECRET;
    const decoded = await decodePortalSession({
        cookieHeader,
        cookieNames: names,
        appId,
        secret: sharedSecret,
        debug,
    });
    if (decoded) {
        return true;
    }
    if (!sharedSecret && debug) {
        const warnKey = names.join('|') || 'global';
        if (!missingSecretWarnings.has(warnKey)) {
            missingSecretWarnings.add(warnKey);
            console.warn('[auth] missing shared NEXTAUTH_SECRET; falling back to portal probe');
        }
    }
    if (!cookieHeader) {
        return false;
    }
    const hasCandidateCookie = names.some((name) => cookieHeader.includes(`${name}=`));
    if (!hasCandidateCookie) {
        return false;
    }
    let portalBase = options.portalUrl ? normalizeOrigin(options.portalUrl) : undefined;
    if (!portalBase) {
        try {
            portalBase = resolvePortalAuthOrigin({ request: options.request });
        }
        catch (error) {
            if (debug) {
                const detail = error instanceof Error ? error.message : String(error);
                console.warn('[auth] unable to resolve portal origin', detail);
            }
            portalBase = undefined;
        }
    }
    if (!portalBase) {
        return false;
    }
    try {
        const endpoint = new URL('/api/auth/session', portalBase);
        const res = await (fetchImpl ?? fetch)(endpoint, {
            method: 'GET',
            headers: {
                cookie: cookieHeader,
                accept: 'application/json',
                'x-ecomos-session-probe': '1',
            },
            cache: 'no-store',
        });
        if (!res.ok) {
            if (debug) {
                console.warn('[auth] portal session probe returned status', res.status);
            }
            return false;
        }
        const data = await res.json().catch(() => null);
        if (data?.user) {
            return true;
        }
        const allowDevProbeBypass = process.env.NODE_ENV !== 'production' &&
            (truthyValues.has(String(process.env.ALLOW_DEV_AUTH_SESSION_BYPASS ?? '').toLowerCase()) ||
                truthyValues.has(String(process.env.ALLOW_DEV_AUTH_DEFAULTS ?? '').toLowerCase()));
        if (allowDevProbeBypass) {
            if (debug) {
                console.warn('[auth] portal session probe returned 200 but no user; allowing due to dev override', data);
            }
            return true;
        }
        if (debug) {
            console.warn('[auth] portal session probe returned 200 but no user payload; treating as unauthenticated', data);
        }
        return false;
    }
    catch (error) {
        if (debug) {
            const detail = error instanceof Error ? error.message : String(error);
            console.warn('[auth] portal session probe failed', detail);
        }
        return false;
    }
}
export function getAppEntitlement(roles, appId) {
    if (!roles || typeof roles !== 'object')
        return undefined;
    const rec = roles;
    const ent = rec[appId];
    if (!ent || typeof ent !== 'object')
        return undefined;
    const departments = Array.isArray(ent.departments)
        ? ent.departments.map(String)
        : Array.isArray(ent.depts)
            ? ent.depts.map(String)
            : undefined;
    return {
        role: String(ent.role ?? ''),
        departments,
        depts: departments,
    };
}
</file>

<file path="packages/auth/dist/user-service.js">
import bcrypt from 'bcryptjs';
import { z } from 'zod';
import { getPortalAuthPrisma } from './db.js';
const DEFAULT_DEMO_USERNAME = 'demo-admin';
const DEFAULT_DEMO_PASSWORD = 'demo-password';
const DEMO_ADMIN_UUID = '00000000-0000-4000-a000-000000000001';
const credentialsSchema = z.object({
    emailOrUsername: z.string().min(1),
    password: z.string().min(1),
});
const userSelect = {
    id: true,
    email: true,
    username: true,
    firstName: true,
    lastName: true,
    passwordHash: true,
    roles: {
        select: {
            role: {
                select: {
                    name: true,
                },
            },
        },
    },
    appAccess: {
        select: {
            accessLevel: true,
            departments: true,
            app: {
                select: {
                    slug: true,
                },
            },
        },
    },
};
export async function authenticateWithPortalDirectory(input) {
    const { emailOrUsername, password } = credentialsSchema.parse(input);
    const loginValue = emailOrUsername.trim().toLowerCase();
    if (!process.env.PORTAL_DB_URL) {
        return process.env.NODE_ENV !== 'production'
            ? handleDevFallback(loginValue, password)
            : null;
    }
    const prisma = getPortalAuthPrisma();
    const user = await prisma.user.findFirst({
        where: {
            OR: [
                { email: loginValue },
                { username: loginValue },
            ],
            isActive: true,
        },
        select: userSelect,
    });
    if (!user) {
        return null;
    }
    const isMatch = await bcrypt.compare(password, user.passwordHash);
    if (!isMatch) {
        return null;
    }
    return mapPortalUser(user);
}
function handleDevFallback(emailOrUsername, password) {
    const demoUsername = (process.env.DEMO_ADMIN_USERNAME || DEFAULT_DEMO_USERNAME).toLowerCase();
    const demoPassword = process.env.DEMO_ADMIN_PASSWORD || DEFAULT_DEMO_PASSWORD;
    if (emailOrUsername !== demoUsername) {
        return null;
    }
    if (password !== demoPassword) {
        return null;
    }
    return buildDemoUser();
}
function buildDemoUser() {
    const demoUsername = (process.env.DEMO_ADMIN_USERNAME || DEFAULT_DEMO_USERNAME).toLowerCase();
    const entitlements = {
        wms: { role: 'admin', departments: ['Ops'] },
        fcc: { role: 'admin', departments: ['Finance'] },
        hrms: { role: 'admin', departments: ['People Ops'] },
        'margin-master': { role: 'admin', departments: ['Product'] },
    };
    return {
        id: DEMO_ADMIN_UUID,
        email: process.env.DEMO_ADMIN_EMAIL || 'dev-admin@targonglobal.com',
        username: demoUsername,
        fullName: 'Development Admin',
        roles: ['admin'],
        entitlements,
    };
}
export async function getUserEntitlements(userId) {
    if (!process.env.PORTAL_DB_URL) {
        return {};
    }
    const prisma = getPortalAuthPrisma();
    const assignments = await prisma.userApp.findMany({
        where: { userId },
        select: {
            accessLevel: true,
            departments: true,
            app: {
                select: {
                    slug: true,
                },
            },
        },
    });
    const entitlements = {};
    for (const assignment of assignments) {
        entitlements[assignment.app.slug] = {
            role: assignment.accessLevel,
            departments: Array.isArray(assignment.departments) ? assignment.departments : [],
        };
    }
    return entitlements;
}
export async function getUserByEmail(email) {
    const normalizedEmail = email.trim().toLowerCase();
    if (!normalizedEmail)
        return null;
    if (!process.env.PORTAL_DB_URL) {
        const demoUser = buildDemoUser();
        if (demoUser.email.toLowerCase() === normalizedEmail) {
            return demoUser;
        }
        return null;
    }
    const prisma = getPortalAuthPrisma();
    const user = await prisma.user.findFirst({
        where: {
            email: normalizedEmail,
            isActive: true,
        },
        select: userSelect,
    });
    if (!user)
        return null;
    return mapPortalUser(user);
}
function mapPortalUser(user) {
    const entitlements = user.appAccess.reduce((acc, assignment) => {
        acc[assignment.app.slug] = {
            role: assignment.accessLevel,
            departments: Array.isArray(assignment.departments)
                ? assignment.departments
                : [],
        };
        return acc;
    }, {});
    return {
        id: user.id,
        email: user.email,
        username: user.username,
        fullName: [user.firstName, user.lastName].filter(Boolean).join(' ') || null,
        roles: user.roles.map((role) => role.role.name),
        entitlements,
    };
}
</file>

<file path="packages/auth/src/index.ts">
import type { NextAuthConfig } from 'next-auth';
import { decode } from 'next-auth/jwt';
import { z } from 'zod';

// Backward compatibility alias
export type NextAuthOptions = NextAuthConfig;

export type SameSite = 'lax' | 'strict' | 'none';

export interface CookieDomainOptions {
  domain: string; // e.g. .targonglobal.com
  secure?: boolean; // default true in production
  sameSite?: SameSite; // default 'lax'
  appId?: string; // used to namespace cookies in dev (e.g., 'wms')
}

/**
 * Build consistent cookie names and options for NextAuth across apps.
 * - In production (secure), uses __Secure- prefix for session/callback and __Host- for csrf (no domain).
 * - In development, optionally prefixes cookie names with `${appId}.` to avoid collisions on localhost.
 */
export function buildCookieOptions(opts: CookieDomainOptions) {
  const secure = opts.secure ?? (process.env.NODE_ENV === 'production');
  const sameSite: SameSite = opts.sameSite ?? 'lax';
  const appPrefix = !secure && opts.appId ? `${opts.appId}.` : '';

  const sessionTokenName = secure
    ? '__Secure-next-auth.session-token'
    : `${appPrefix}next-auth.session-token`;
  const callbackUrlName = secure
    ? '__Secure-next-auth.callback-url'
    : `${appPrefix}next-auth.callback-url`;
  const csrfTokenName = secure
    ? '__Host-next-auth.csrf-token'
    : `${appPrefix}next-auth.csrf-token`;

  // Determine if we should set the Domain attribute on cookies.
  // On localhost / 127.0.0.1, setting Domain causes cookies to be rejected by browsers.
  const rawDomain = (opts.domain || '').trim().toLowerCase();
  const isIPv4 = /^\d+\.\d+\.\d+\.\d+$/.test(rawDomain);
  const isLocalhost = rawDomain === 'localhost' || rawDomain.endsWith('.localhost');
  const shouldSetDomain = !!rawDomain && !isIPv4 && !isLocalhost;
  const domainOption = shouldSetDomain ? { domain: rawDomain } : {};

  return {
    sessionToken: {
      name: sessionTokenName,
      options: {
        httpOnly: true,
        sameSite,
        path: '/',
        secure,
        // Only set Domain when valid (never on localhost/IP). Host-only cookies work in dev.
        ...domainOption,
      },
    },
    callbackUrl: {
      name: callbackUrlName,
      options: {
        sameSite,
        path: '/',
        secure,
        ...domainOption,
      },
    },
    csrfToken: {
      name: csrfTokenName,
      options: {
        httpOnly: true,
        sameSite,
        path: '/',
        secure,
        // Important: __Host- cookies cannot set domain in secure mode.
        // In dev, also avoid Domain on localhost/IP to ensure cookie is accepted.
        ...(secure ? {} : domainOption),
      },
    },
  } as NextAuthConfig['cookies'];
}

function parseCookieHeader(header: string | undefined | null): Map<string, string[]> {
  const map = new Map<string, string[]>();
  if (!header) return map;
  const parts = header.split(';');
  for (const part of parts) {
    const [rawName, ...rawValue] = part.split('=');
    if (!rawName) continue;
    const name = rawName.trim();
    if (!name) continue;
    const value = rawValue.join('=').trim();
    const list = map.get(name);
    if (list) {
      list.push(value);
    } else {
      map.set(name, [value]);
    }
  }
  return map;
}

export const AuthEnvSchema = z.object({
  NEXTAUTH_SECRET: z.string().min(16),
  NEXTAUTH_URL: z.string().url().optional(),
  COOKIE_DOMAIN: z.string().min(1), // e.g. .targonglobal.com
});

export interface SharedAuthOptions {
  cookieDomain: string;
  appId?: string;
}

/**
 * Compose app-specific NextAuth options with shared, secure defaults.
 */
const truthyValues = new Set(['1', 'true', 'yes', 'on']);

export interface DevAuthDefaultsOptions {
  appId?: string;
  port?: string | number;
  baseUrl?: string;
  cookieDomain?: string;
  portalUrl?: string;
  publicPortalUrl?: string;
  allowDefaults?: boolean;
}

/**
 * Provide sane defaults for local development so NextAuth stops warning about missing env vars.
 */
export function applyDevAuthDefaults(options: DevAuthDefaultsOptions = {}) {
  const env = process.env.NODE_ENV ?? 'development';
  const isDevLike = env === 'development' || env === 'test';
  if (!isDevLike) return;

  const allowDefaultsEnv = truthyValues.has(String(process.env.ALLOW_DEV_AUTH_DEFAULTS ?? '').toLowerCase());
  const allowDefaults = options.allowDefaults ?? allowDefaultsEnv;

  const missing: string[] = [];

  const resolveSecret = () => {
    const existingSecret = process.env.PORTAL_AUTH_SECRET ?? process.env.NEXTAUTH_SECRET;
    if (existingSecret) {
      if (!process.env.NEXTAUTH_SECRET) {
        process.env.NEXTAUTH_SECRET = existingSecret;
      }
      return;
    }

    if (allowDefaults) {
      const suffix = options.appId ? `-${options.appId}` : '';
      process.env.NEXTAUTH_SECRET = `dev-only-nextauth-secret${suffix}-change-me`;
      return;
    }

    missing.push('PORTAL_AUTH_SECRET or NEXTAUTH_SECRET');
  };

  const ensureValue = (current: string | undefined, label: string, fallback?: string) => {
    if (current && current.trim() !== '') {
      return current;
    }
    if (allowDefaults && fallback) {
      return fallback;
    }
    missing.push(label);
    return undefined;
  };

  resolveSecret();

  const port = options.port ?? process.env.PORT ?? 3000;
  const computedBaseUrl = options.baseUrl ?? `http://localhost:${port}`;

  const nextAuthUrl = ensureValue(process.env.NEXTAUTH_URL, 'NEXTAUTH_URL', allowDefaults ? String(computedBaseUrl) : undefined);
  if (nextAuthUrl && !process.env.NEXTAUTH_URL) {
    process.env.NEXTAUTH_URL = nextAuthUrl;
  }

  const portalUrl = ensureValue(
    process.env.PORTAL_AUTH_URL,
    'PORTAL_AUTH_URL',
    allowDefaults ? options.portalUrl ?? nextAuthUrl : undefined,
  );
  if (portalUrl && !process.env.PORTAL_AUTH_URL) {
    process.env.PORTAL_AUTH_URL = portalUrl;
  }

  const publicPortalUrl = ensureValue(
    process.env.NEXT_PUBLIC_PORTAL_AUTH_URL,
    'NEXT_PUBLIC_PORTAL_AUTH_URL',
    allowDefaults ? options.publicPortalUrl ?? portalUrl ?? nextAuthUrl : undefined,
  );
  if (publicPortalUrl && !process.env.NEXT_PUBLIC_PORTAL_AUTH_URL) {
    process.env.NEXT_PUBLIC_PORTAL_AUTH_URL = publicPortalUrl;
  }

  const cookieDomain = ensureValue(
    process.env.COOKIE_DOMAIN,
    'COOKIE_DOMAIN',
    allowDefaults ? options.cookieDomain : undefined,
  );
  if (cookieDomain && !process.env.COOKIE_DOMAIN) {
    process.env.COOKIE_DOMAIN = cookieDomain;
  }

  if (missing.length > 0) {
    throw new Error(`[auth] Missing required auth environment variables: ${missing.join(', ')}`);
  }

  if (process.env.NEXTAUTH_DEBUG === undefined) {
    // Default to off; callers can opt-in with NEXTAUTH_DEBUG=1 if needed.
    process.env.NEXTAUTH_DEBUG = '0';
  }
}

export function withSharedAuth(base: NextAuthConfig, optsOrDomain: SharedAuthOptions | string): NextAuthConfig {
  const opts: SharedAuthOptions = typeof optsOrDomain === 'string'
    ? { cookieDomain: optsOrDomain }
    : optsOrDomain;

  const envDebug = process.env.NEXTAUTH_DEBUG ? truthyValues.has(process.env.NEXTAUTH_DEBUG.toLowerCase()) : undefined;
  const baseDebug = typeof base.debug === 'boolean' ? base.debug : undefined;
  const debug = envDebug ?? baseDebug ?? false;

  const resolvedSecret = process.env.NEXTAUTH_SECRET ?? base.secret;

  const envMode = process.env.NODE_ENV ?? 'development';
  const isDevLike = envMode === 'development' || envMode === 'test';

  if (!resolvedSecret) {
    throw new Error('NEXTAUTH_SECRET (or PORTAL_AUTH_SECRET) must be provided for shared auth.');
  }

  if (!isDevLike) {
    const result = AuthEnvSchema.safeParse({
      NEXTAUTH_SECRET: resolvedSecret,
      NEXTAUTH_URL: process.env.NEXTAUTH_URL,
      COOKIE_DOMAIN: process.env.COOKIE_DOMAIN ?? opts.cookieDomain,
    });
    if (!result.success) {
      const detail = result.error.issues
        .map((issue) => `${issue.path.join('.') || 'config'}: ${issue.message}`)
        .join('; ');
      throw new Error(`Missing required auth configuration: ${detail}`);
    }
  }

  return {
    // Keep base providers/callbacks etc. from app
    ...base,
    session: {
      strategy: 'jwt',
      maxAge: 30 * 24 * 60 * 60,
      ...base.session,
    },
    debug,
    secret: resolvedSecret,
    cookies: {
      ...buildCookieOptions({ domain: opts.cookieDomain, sameSite: 'lax', appId: opts.appId }),
      ...base.cookies,
    },
  } satisfies NextAuthConfig;
}

/**
 * Helper to derive the likely session cookie names to probe in middleware.
 * Always include both secure (__Secure-) and non-secure variants because
 * different environments flip between dev/prod cookie prefixes.
 */
export function getCandidateSessionCookieNames(appId?: string): string[] {
  const names = new Set<string>([
    '__Secure-next-auth.session-token',
    'next-auth.session-token',
  ]);

  const portalAppIdRaw =
    typeof process !== 'undefined' && process.env
      ? (process.env.PORTAL_APP_ID ?? 'ecomos')
      : 'ecomos';
  const normalizedPortalAppId = portalAppIdRaw.trim();

  const addNamesFor = (id?: string) => {
    const normalized = id?.trim();
    if (!normalized) return;
    names.add(`${normalized}.next-auth.session-token`);
    names.add(`__Secure-${normalized}.next-auth.session-token`);
  };

  addNamesFor(appId);
  const normalizedAppId = appId?.trim() ?? '';
  if (normalizedPortalAppId && normalizedPortalAppId !== normalizedAppId) {
    addNamesFor(normalizedPortalAppId);
  }

  return Array.from(names);
}

export interface PortalJwtPayload extends Record<string, unknown> {
  sub?: string;
  email?: string;
  name?: string;
  roles?: RolesClaim;
  apps?: string[];
  exp?: number;
}

export interface DecodePortalSessionOptions {
  cookieHeader?: string | null;
  cookieNames?: string[];
  appId?: string;
  secret?: string;
  debug?: boolean;
}

export async function decodePortalSession(options: DecodePortalSessionOptions = {}): Promise<PortalJwtPayload | null> {
  const {
    cookieHeader,
    cookieNames,
    appId,
    secret,
    debug = truthyValues.has(String(process.env.NEXTAUTH_DEBUG ?? '').toLowerCase()),
  } = options;

  const header = cookieHeader ?? '';
  if (!header) {
    if (debug) {
      console.warn('[auth] decodePortalSession: missing cookie header');
    }
    return null;
  }

  const names = Array.from(new Set((cookieNames && cookieNames.length > 0)
    ? cookieNames
    : getCandidateSessionCookieNames(appId)));

 const resolvedSecret = secret
    || process.env.PORTAL_AUTH_SECRET
    || process.env.NEXTAUTH_SECRET;

  if (!resolvedSecret) {
    if (debug) {
      console.warn('[auth] decodePortalSession: missing shared secret');
    }
    return null;
  }

  const cookies = parseCookieHeader(header);
  for (const name of names) {
    const values = cookies.get(name);
    if (!values?.length) {
      continue;
    }
    for (const raw of values) {
      if (!raw) continue;
      try {
        // In v5, salt is required - use the cookie name as salt (typical pattern)
        const decoded = await decode({
          token: raw,
          secret: resolvedSecret,
          salt: name, // Use the cookie name as salt
        });
        if (decoded && typeof decoded === 'object') {
          return decoded as PortalJwtPayload;
        }
      } catch (error) {
        if (debug) {
          const detail = error instanceof Error ? error.message : String(error);
          console.warn('[auth] decodePortalSession: failed to decode token', name, 'value length', raw.length, detail);
        }
      }
    }
  }

  return null;
}


export type PortalUrlRequestLike = {
  headers: Headers;
  url: string;
};

export interface PortalUrlOptions {
  request?: PortalUrlRequestLike;
  fallbackOrigin?: string;
}

export interface PortalSessionProbeOptions {
  request: Request;
  appId?: string;
  cookieNames?: string[];
  secret?: string;
  portalUrl?: string;
  debug?: boolean;
  fetchImpl?: typeof fetch;
}

const DEFAULT_PORTAL_DEV = 'http://localhost:3000';
const missingSecretWarnings = new Set<string>();

function normalizeOrigin(raw: string | undefined | null): string | undefined {
  if (!raw) return undefined;
  const trimmed = raw.trim();
  if (!trimmed) return undefined;

  const hasScheme = /^[a-z][a-z0-9+.-]*:\/\//i.test(trimmed);
  const candidates = hasScheme ? [trimmed] : [`https://${trimmed}`, `http://${trimmed}`];

  for (const candidate of candidates) {
    try {
      const url = new URL(candidate);
      return url.origin;
    } catch {
      continue;
    }
  }

  return undefined;
}

function originFromRequestLike(request: PortalUrlRequestLike | undefined): string | undefined {
  if (!request) return undefined;
  const headers = request.headers;
  const forwardedProto = headers.get('x-forwarded-proto');
  const forwardedHost = headers.get('x-forwarded-host');
  const primaryHost = forwardedHost ? forwardedHost.split(',')[0]?.trim() : undefined;
  const host = primaryHost || headers.get('host');
  const url = request.url ? new URL(request.url) : null;

  const fallbackProto = url?.protocol ? url.protocol.replace(/:$/, '') : undefined;
  const protocol = forwardedProto?.split(',')[0]?.trim() || fallbackProto || 'http';
  const candidate = host ? `${protocol}://${host}` : url?.origin;
  return normalizeOrigin(candidate ?? undefined);
}

function originFromGlobalScope(): string | undefined {
  if (typeof globalThis === 'undefined') {
    return undefined;
  }
  const maybeLocation = (globalThis as any)?.location;
  if (maybeLocation && typeof maybeLocation.origin === 'string') {
    return normalizeOrigin(maybeLocation.origin);
  }
  return undefined;
}

export function resolvePortalAuthOrigin(options?: PortalUrlOptions): string {
  const envCandidates = [
    process.env.NEXT_PUBLIC_PORTAL_AUTH_URL,
    process.env.PORTAL_AUTH_URL,
    process.env.NEXTAUTH_URL,
  ];

  for (const candidate of envCandidates) {
    const normalized = normalizeOrigin(candidate);
    if (normalized) {
      return normalized;
    }
  }

  const requestOrigin = originFromRequestLike(options?.request);
  if (requestOrigin) {
    return requestOrigin;
  }

  const fallbackOrigin = normalizeOrigin(options?.fallbackOrigin);
  if (fallbackOrigin) {
    return fallbackOrigin;
  }

  const globalOrigin = originFromGlobalScope();
  if (globalOrigin) {
    return globalOrigin;
  }

  const allowDefaults = truthyValues.has(String(process.env.ALLOW_DEV_AUTH_DEFAULTS ?? '').toLowerCase());
  if (allowDefaults && process.env.NODE_ENV !== 'production') {
    return DEFAULT_PORTAL_DEV;
  }

  throw new Error('Portal auth origin is not configured. Set PORTAL_AUTH_URL or NEXT_PUBLIC_PORTAL_AUTH_URL.');
}

export function buildPortalUrl(path: string, options?: PortalUrlOptions): URL {
  const origin = resolvePortalAuthOrigin(options);
  return new URL(path, origin);
}

/**
 * Determine whether a request already carries a valid portal NextAuth session.
 * - Tries to decode the session cookie locally using the shared secret.
 * - Falls back to probing the portal `/api/auth/session` endpoint to handle
 *   environments where app-specific secrets differ from the portal.
 */
export async function hasPortalSession(options: PortalSessionProbeOptions): Promise<boolean> {
  const {
    request,
    appId,
    cookieNames,
    debug = options.debug ?? truthyValues.has(String(process.env.NEXTAUTH_DEBUG ?? '').toLowerCase()),
    fetchImpl,
  } = options;

  const names = Array.from(new Set((cookieNames && cookieNames.length > 0)
    ? cookieNames
    : getCandidateSessionCookieNames(appId)));

  const cookieHeader = request.headers.get('cookie');
  const sharedSecret = options.secret
    || process.env.PORTAL_AUTH_SECRET
    || process.env.NEXTAUTH_SECRET;

  const decoded = await decodePortalSession({
    cookieHeader,
    cookieNames: names,
    appId,
    secret: sharedSecret,
    debug,
  });

  if (decoded) {
    return true;
  }

  if (!sharedSecret && debug) {
    const warnKey = names.join('|') || 'global';
    if (!missingSecretWarnings.has(warnKey)) {
      missingSecretWarnings.add(warnKey);
      console.warn('[auth] missing shared NEXTAUTH_SECRET; falling back to portal probe');
    }
  }

  if (!cookieHeader) {
    return false;
  }

  const hasCandidateCookie = names.some((name) => cookieHeader.includes(`${name}=`));
  if (!hasCandidateCookie) {
    return false;
  }

  let portalBase: string | undefined = options.portalUrl ? normalizeOrigin(options.portalUrl) : undefined;
  if (!portalBase) {
    try {
      portalBase = resolvePortalAuthOrigin({ request: options.request as unknown as PortalUrlRequestLike });
    } catch (error) {
      if (debug) {
        const detail = error instanceof Error ? error.message : String(error);
        console.warn('[auth] unable to resolve portal origin', detail);
      }
      portalBase = undefined;
    }
  }

  if (!portalBase) {
    return false;
  }

  try {
    const endpoint = new URL('/api/auth/session', portalBase);
    const res = await (fetchImpl ?? fetch)(endpoint, {
      method: 'GET',
      headers: {
        cookie: cookieHeader,
        accept: 'application/json',
        'x-ecomos-session-probe': '1',
      },
      cache: 'no-store',
    });
   if (!res.ok) {
     if (debug) {
       console.warn('[auth] portal session probe returned status', res.status);
     }
     return false;
   }
   const data = await res.json().catch(() => null);
    if (data?.user) {
      return true;
    }

    const allowDevProbeBypass =
      process.env.NODE_ENV !== 'production' &&
      (truthyValues.has(String(process.env.ALLOW_DEV_AUTH_SESSION_BYPASS ?? '').toLowerCase()) ||
        truthyValues.has(String(process.env.ALLOW_DEV_AUTH_DEFAULTS ?? '').toLowerCase()));

    if (allowDevProbeBypass) {
      if (debug) {
        console.warn(
          '[auth] portal session probe returned 200 but no user; allowing due to dev override',
          data
        );
      }
      return true;
    }

    if (debug) {
      console.warn('[auth] portal session probe returned 200 but no user payload; treating as unauthenticated', data);
    }
    return false;
 } catch (error) {
   if (debug) {
     const detail = error instanceof Error ? error.message : String(error);
     console.warn('[auth] portal session probe failed', detail);
   }
    return false;
  }
}

// ===== Entitlement / Roles claim helpers =====
export type AppEntitlement = {
  role: string;
  departments?: string[];
  depts?: string[];
};

export type RolesClaim = Record<string, AppEntitlement>; // { wms: { role, depts }, fcc: { ... } }

export function getAppEntitlement(roles: unknown, appId: string): AppEntitlement | undefined {
  if (!roles || typeof roles !== 'object') return undefined;
  const rec = roles as Record<string, any>;
  const ent = rec[appId];
  if (!ent || typeof ent !== 'object') return undefined;
  const departments = Array.isArray(ent.departments)
    ? ent.departments.map(String)
    : Array.isArray(ent.depts)
      ? ent.depts.map(String)
      : undefined;
  return {
    role: String(ent.role ?? ''),
    departments,
    depts: departments,
  };
}
</file>

<file path="packages/auth/src/user-service.ts">
import bcrypt from 'bcryptjs'
import { z } from 'zod'

import { getPortalAuthPrisma } from './db.js'

type AppEntitlementMap = Record<string, { role: string; departments: string[] }>

const DEFAULT_DEMO_USERNAME = 'demo-admin'
const DEFAULT_DEMO_PASSWORD = 'demo-password'
const DEMO_ADMIN_UUID = '00000000-0000-4000-a000-000000000001'

const credentialsSchema = z.object({
  emailOrUsername: z.string().min(1),
  password: z.string().min(1),
})

export type AuthenticatedUser = {
  id: string
  email: string
  username: string | null
  fullName: string | null
  roles: string[]
  entitlements: Record<string, { role: string; departments: string[] }>
}

const userSelect = {
  id: true,
  email: true,
  username: true,
  firstName: true,
  lastName: true,
  passwordHash: true,
  roles: {
    select: {
      role: {
        select: {
          name: true,
        },
      },
    },
  },
  appAccess: {
    select: {
      accessLevel: true,
      departments: true,
      app: {
        select: {
          slug: true,
        },
      },
    },
  },
} as const

type PortalUserRecord = {
  id: string
  email: string
  username: string | null
  firstName: string | null
  lastName: string | null
  passwordHash: string
  roles: Array<{ role: { name: string } }>
  appAccess: Array<{ accessLevel: string; departments: unknown; app: { slug: string } }>
}

export async function authenticateWithPortalDirectory(input: unknown): Promise<AuthenticatedUser | null> {
  const { emailOrUsername, password } = credentialsSchema.parse(input)

  const loginValue = emailOrUsername.trim().toLowerCase()

  if (!process.env.PORTAL_DB_URL) {
    return process.env.NODE_ENV !== 'production'
      ? handleDevFallback(loginValue, password)
      : null
  }

  const prisma = getPortalAuthPrisma()

  const user = await prisma.user.findFirst({
    where: {
      OR: [
        { email: loginValue },
        { username: loginValue },
      ],
      isActive: true,
    },
    select: userSelect,
  }) as (PortalUserRecord | null)

  if (!user) {
    return null
  }

  const isMatch = await bcrypt.compare(password, user.passwordHash)
  if (!isMatch) {
    return null
  }

  return mapPortalUser(user)
}

function handleDevFallback(emailOrUsername: string, password: string): AuthenticatedUser | null {
  const demoUsername = (process.env.DEMO_ADMIN_USERNAME || DEFAULT_DEMO_USERNAME).toLowerCase()
  const demoPassword = process.env.DEMO_ADMIN_PASSWORD || DEFAULT_DEMO_PASSWORD

  if (emailOrUsername !== demoUsername) {
    return null
  }

  if (password !== demoPassword) {
    return null
  }

  return buildDemoUser()
}

function buildDemoUser(): AuthenticatedUser {
  const demoUsername = (process.env.DEMO_ADMIN_USERNAME || DEFAULT_DEMO_USERNAME).toLowerCase()
  const entitlements: AppEntitlementMap = {
    wms: { role: 'admin', departments: ['Ops'] },
    fcc: { role: 'admin', departments: ['Finance'] },
    hrms: { role: 'admin', departments: ['People Ops'] },
    'margin-master': { role: 'admin', departments: ['Product'] },
  }

  return {
    id: DEMO_ADMIN_UUID,
    email: process.env.DEMO_ADMIN_EMAIL || 'dev-admin@targonglobal.com',
    username: demoUsername,
    fullName: 'Development Admin',
    roles: ['admin'],
    entitlements,
  }
}

export async function getUserEntitlements(userId: string) {
  if (!process.env.PORTAL_DB_URL) {
    return {}
  }

  const prisma = getPortalAuthPrisma()

  const assignments = await prisma.userApp.findMany({
    where: { userId },
    select: {
      accessLevel: true,
      departments: true,
      app: {
        select: {
          slug: true,
        },
      },
    },
  })

  const entitlements: AppEntitlementMap = {}
  for (const assignment of assignments) {
    entitlements[assignment.app.slug] = {
      role: assignment.accessLevel,
      departments: Array.isArray(assignment.departments) ? (assignment.departments as string[]) : [],
    }
  }

  return entitlements
}

export async function getUserByEmail(email: string): Promise<AuthenticatedUser | null> {
  const normalizedEmail = email.trim().toLowerCase()
  if (!normalizedEmail) return null

  if (!process.env.PORTAL_DB_URL) {
    const demoUser = buildDemoUser()
    if (demoUser.email.toLowerCase() === normalizedEmail) {
      return demoUser
    }
    return null
  }

  const prisma = getPortalAuthPrisma()
  const user = await prisma.user.findFirst({
    where: {
      email: normalizedEmail,
      isActive: true,
    },
    select: userSelect,
  }) as (PortalUserRecord | null)
  if (!user) return null
  return mapPortalUser(user)
}

function mapPortalUser(user: PortalUserRecord): AuthenticatedUser {
  const entitlements = user.appAccess.reduce<AppEntitlementMap>((acc, assignment) => {
    acc[assignment.app.slug] = {
      role: assignment.accessLevel,
      departments: Array.isArray(assignment.departments)
        ? (assignment.departments as string[])
        : [],
    }
    return acc
  }, {} as AppEntitlementMap)

  return {
    id: user.id,
    email: user.email,
    username: user.username,
    fullName: [user.firstName, user.lastName].filter(Boolean).join(' ') || null,
    roles: user.roles.map((role) => role.role.name),
    entitlements,
  }
}
</file>

<file path="pnpm-workspace.yaml">
packages:
  - apps/*
  - '!apps/archived'
  - packages/*

onlyBuiltDependencies:
  - '@scarf/scarf'
  - '@tree-sitter-grammars/tree-sitter-yaml'
  - core-js
  - core-js-pure
  - esbuild
  - msgpackr-extract
  - puppeteer
  - tree-sitter
  - tree-sitter-json
  - unrs-resolver
</file>

<file path="apps/hrms/app/(hrms)/employees/add/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { EmployeesApi, DepartmentsApi, type Department } from '@/lib/api-client'
import { UsersIcon } from '@/components/ui/Icons'
import { PageHeader } from '@/components/ui/PageHeader'
import { Card, CardDivider } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import {
  FormField,
  SelectField,
  FormSection,
  FormActions,
} from '@/components/ui/FormField'
import { useNavigationHistory } from '@/lib/navigation-history'
import { employmentTypeOptions, statusOptions } from '@/lib/constants'

export default function AddEmployeePage() {
  const router = useRouter()
  const { goBack } = useNavigationHistory()
  const [submitting, setSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [departments, setDepartments] = useState<Department[]>([])
  const [loadingDepts, setLoadingDepts] = useState(true)

  useEffect(() => {
    async function loadDepartments() {
      try {
        const data = await DepartmentsApi.list()
        setDepartments(data.items)
      } catch (e) {
        console.error('Failed to load departments:', e)
      } finally {
        setLoadingDepts(false)
      }
    }
    loadDepartments()
  }, [])

  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault()
    setSubmitting(true)
    setError(null)
    const fd = new FormData(e.currentTarget)
    const payload = Object.fromEntries(fd.entries()) as any

    try {
      await EmployeesApi.create({
        firstName: String(payload.firstName),
        lastName: String(payload.lastName),
        email: String(payload.email),
        phone: payload.phone ? String(payload.phone) : undefined,
        department: String(payload.department || ''),
        position: String(payload.position),
        joinDate: String(payload.joinDate),
        employmentType: String(payload.employmentType || 'FULL_TIME'),
        status: String(payload.status || 'ACTIVE'),
      })
      router.push('/employees')
    } catch (e: any) {
      setError(e.message || 'Failed to create employee')
    } finally {
      setSubmitting(false)
    }
  }

  return (
    <>
      <PageHeader
        title="Add Employee"
        description="People"
        icon={<UsersIcon className="h-6 w-6 text-white" />}
        showBack
      />

      <div className="max-w-3xl">
        <Card padding="lg">
          {error && (
            <Alert variant="error" className="mb-6" onDismiss={() => setError(null)}>
              {error}
            </Alert>
          )}

          <form onSubmit={onSubmit} className="space-y-8">
            {/* Basic Info */}
            <FormSection title="Basic Information" description="Personal details of the employee">
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
                <FormField
                  label="First Name"
                  name="firstName"
                  required
                  placeholder="John"
                />
                <FormField
                  label="Last Name"
                  name="lastName"
                  required
                  placeholder="Doe"
                />
                <FormField
                  label="Email"
                  name="email"
                  type="email"
                  required
                  placeholder="employee@company.com"
                />
                <FormField
                  label="Phone"
                  name="phone"
                  type="tel"
                  placeholder="+1 (555) 000-0000"
                />
              </div>
            </FormSection>

            <CardDivider />

            {/* Work Info */}
            <FormSection title="Work Information" description="Job-related details">
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
                <SelectField
                  label="Department"
                  name="department"
                  required
                  options={departments.map((dept) => ({
                    value: dept.name,
                    label: dept.name,
                  }))}
                  placeholder={loadingDepts ? 'Loading departments...' : 'Select department...'}
                />
                <FormField
                  label="Position"
                  name="position"
                  required
                  placeholder="e.g., Software Engineer"
                />
                <FormField
                  label="Join Date"
                  name="joinDate"
                  type="date"
                  required
                />
                <SelectField
                  label="Employment Type"
                  name="employmentType"
                  required
                  options={employmentTypeOptions}
                  defaultValue="FULL_TIME"
                />
                <SelectField
                  label="Status"
                  name="status"
                  required
                  options={statusOptions}
                  defaultValue="ACTIVE"
                />
              </div>
            </FormSection>

            {/* Actions */}
            <FormActions>
              <Button variant="secondary" onClick={goBack}>
                Cancel
              </Button>
              <Button type="submit" loading={submitting}>
                {submitting ? 'Saving...' : 'Save Employee'}
              </Button>
            </FormActions>
          </form>
        </Card>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/employees/page.tsx">
'use client'

import { useCallback, useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { EmployeesApi, DashboardApi, type Employee } from '@/lib/api-client'
import { UsersIcon, PlusIcon, ChevronUpIcon, ChevronDownIcon, SpinnerIcon } from '@/components/ui/Icons'
import { ListPageHeader } from '@/components/ui/PageHeader'
import { Button } from '@/components/ui/Button'
import { StatusBadge } from '@/components/ui/Badge'
import { Card } from '@/components/ui/Card'
import { SearchForm } from '@/components/ui/SearchForm'
import {
  Table,
  TableHeader,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  ResultsCount,
} from '@/components/ui/Table'
import { TableEmptyState } from '@/components/ui/EmptyState'

type SortField = 'employeeId' | 'name' | 'department' | 'joinDate'
type SortDirection = 'asc' | 'desc'

function EmployeeAvatar({ firstName, lastName }: { firstName: string; lastName: string }) {
  return (
    <div className="h-9 w-9 rounded-full bg-cyan-100 text-cyan-700 flex items-center justify-center text-sm font-medium">
      {firstName?.charAt(0)}{lastName?.charAt(0)}
    </div>
  )
}

function formatDate(dateString: string): string {
  if (!dateString) return '—'
  const date = new Date(dateString)
  if (isNaN(date.getTime())) return '—'
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  })
}

function SortableHeader({
  children,
  field,
  currentSort,
  currentDirection,
  onSort,
}: {
  children: React.ReactNode
  field: SortField
  currentSort: SortField
  currentDirection: SortDirection
  onSort: (field: SortField) => void
}) {
  const isActive = currentSort === field
  return (
    <button
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-slate-900 transition-colors group"
    >
      {children}
      <span className={`transition-opacity ${isActive ? 'opacity-100' : 'opacity-0 group-hover:opacity-50'}`}>
        {isActive && currentDirection === 'asc' ? (
          <ChevronUpIcon className="h-4 w-4" />
        ) : (
          <ChevronDownIcon className="h-4 w-4" />
        )}
      </span>
    </button>
  )
}

function TableRowSkeleton() {
  return (
    <>
      {[...Array(5)].map((_, i) => (
        <tr key={i} className="animate-pulse">
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-16" /></td>
          <td className="px-4 py-4">
            <div className="flex items-center gap-3">
              <div className="h-9 w-9 rounded-full bg-slate-200" />
              <div className="space-y-1.5">
                <div className="h-4 bg-slate-200 rounded w-28" />
                <div className="h-3 bg-slate-200 rounded w-36" />
              </div>
            </div>
          </td>
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-20" /></td>
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-28" /></td>
          <td className="px-4 py-4"><div className="h-5 bg-slate-200 rounded w-16" /></td>
          <td className="px-4 py-4"><div className="h-4 bg-slate-200 rounded w-24" /></td>
        </tr>
      ))}
    </>
  )
}

export default function EmployeesPage() {
  const router = useRouter()
  const [items, setItems] = useState<Employee[]>([])
  const [q, setQ] = useState('')
  const [loading, setLoading] = useState(true)
  const [accessChecking, setAccessChecking] = useState(true)
  const [hasAccess, setHasAccess] = useState(false)
  const [sortField, setSortField] = useState<SortField>('employeeId')
  const [sortDirection, setSortDirection] = useState<SortDirection>('asc')

  // Check if user has access
  // For now, all authenticated users can access the employees list
  // TODO: Implement proper RBAC when reporting hierarchy is fully set up
  useEffect(() => {
    async function checkAccess() {
      try {
        const dashboardData = await DashboardApi.get()
        // Allow access for all authenticated users
        // In future, can restrict to managers only: if (!dashboardData.isManager) { redirect }
        if (dashboardData.currentEmployee) {
          setHasAccess(true)
        } else {
          // No employee profile - redirect to home
          router.replace('/')
          return
        }
      } catch (err) {
        console.error('Error checking access:', err)
        router.replace('/')
      } finally {
        setAccessChecking(false)
      }
    }
    checkAccess()
  }, [router])

  const load = useCallback(async () => {
    if (!hasAccess) return
    try {
      setLoading(true)
      const data = await EmployeesApi.list({ q })
      setItems(data.items || [])
    } catch (err) {
      console.error('Error fetching employees:', err)
      setItems([])
    } finally {
      setLoading(false)
    }
  }, [q, hasAccess])

  useEffect(() => {
    if (hasAccess) {
      load()
    }
  }, [load, hasAccess])

  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc')
    } else {
      setSortField(field)
      setSortDirection('asc')
    }
  }

  // Sort items client-side
  const sortedItems = [...items].sort((a, b) => {
    const direction = sortDirection === 'asc' ? 1 : -1

    switch (sortField) {
      case 'employeeId': {
        // Extract numeric part for proper sorting (EMP-001, EMP-002, etc.)
        const numA = parseInt(a.employeeId.replace(/\D/g, ''), 10) || 0
        const numB = parseInt(b.employeeId.replace(/\D/g, ''), 10) || 0
        return (numA - numB) * direction
      }
      case 'name':
        return `${a.firstName} ${a.lastName}`.localeCompare(`${b.firstName} ${b.lastName}`) * direction
      case 'department':
        return (a.department || '').localeCompare(b.department || '') * direction
      case 'joinDate':
        return (new Date(a.joinDate).getTime() - new Date(b.joinDate).getTime()) * direction
      default:
        return 0
    }
  })

  // Show loading while checking access
  if (accessChecking) {
    return (
      <>
        <ListPageHeader
          title="Employees"
          description="Manage your team members"
          icon={<UsersIcon className="h-6 w-6 text-white" />}
        />
        <div className="flex items-center justify-center h-64">
          <SpinnerIcon className="h-8 w-8 animate-spin text-cyan-600" />
        </div>
      </>
    )
  }

  // Don't render content if user doesn't have access (will redirect)
  if (!hasAccess) {
    return null
  }

  return (
    <>
      <ListPageHeader
        title="Employees"
        description="Manage your team members"
        icon={<UsersIcon className="h-6 w-6 text-white" />}
        action={
          <Button href="/employees/add" icon={<PlusIcon className="h-4 w-4" />}>
            Add Employee
          </Button>
        }
      />

      <div className="space-y-6">
        {/* Search */}
        <Card padding="md">
          <SearchForm
            value={q}
            onChange={setQ}
            onSubmit={load}
            placeholder="Search by name, email, or ID..."
          />
        </Card>

        {/* Results count */}
        <ResultsCount
          count={items.length}
          singular="employee"
          plural="employees"
          loading={loading}
        />

        {/* Table */}
        <Table>
          <TableHeader>
            <TableHead className="w-24">
              <SortableHeader
                field="employeeId"
                currentSort={sortField}
                currentDirection={sortDirection}
                onSort={handleSort}
              >
                ID
              </SortableHeader>
            </TableHead>
            <TableHead>
              <SortableHeader
                field="name"
                currentSort={sortField}
                currentDirection={sortDirection}
                onSort={handleSort}
              >
                Employee
              </SortableHeader>
            </TableHead>
            <TableHead>
              <SortableHeader
                field="department"
                currentSort={sortField}
                currentDirection={sortDirection}
                onSort={handleSort}
              >
                Department
              </SortableHeader>
            </TableHead>
            <TableHead>Position</TableHead>
            <TableHead>Status</TableHead>
            <TableHead>
              <SortableHeader
                field="joinDate"
                currentSort={sortField}
                currentDirection={sortDirection}
                onSort={handleSort}
              >
                Join Date
              </SortableHeader>
            </TableHead>
          </TableHeader>
          <TableBody>
            {loading ? (
              <TableRowSkeleton />
            ) : sortedItems.length === 0 ? (
              <TableEmptyState
                colSpan={6}
                icon={<UsersIcon className="h-10 w-10" />}
                title="No employees found"
                action={{
                  label: 'Add your first employee',
                  href: '/employees/add',
                }}
              />
            ) : (
              sortedItems.map((e) => (
                <TableRow
                  key={e.id}
                  onClick={() => router.push(`/employees/${e.id}`)}
                >
                  <TableCell className="font-mono text-sm text-slate-600">
                    {e.employeeId}
                  </TableCell>
                  <TableCell>
                    <div className="flex items-center gap-3">
                      <EmployeeAvatar firstName={e.firstName} lastName={e.lastName} />
                      <div>
                        <p className="font-medium text-slate-900">{e.firstName} {e.lastName}</p>
                        <p className="text-xs text-slate-500">{e.email}</p>
                      </div>
                    </div>
                  </TableCell>
                  <TableCell className="text-slate-600">{e.department || '—'}</TableCell>
                  <TableCell className="text-slate-600">{e.position}</TableCell>
                  <TableCell>
                    <StatusBadge status={e.status.replace('_', ' ')} />
                  </TableCell>
                  <TableCell className="text-slate-500">{formatDate(e.joinDate)}</TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/organogram/page.tsx">
'use client'

import { useState, useEffect, Suspense } from 'react'
import { useSearchParams, useRouter } from 'next/navigation'
import { HierarchyApi, DepartmentsApi, ProjectsApi, HierarchyEmployee, Department, Project } from '@/lib/api-client'
import { ListPageHeader } from '@/components/ui/PageHeader'
import { Card } from '@/components/ui/Card'
import { OrgChartIcon, SpinnerIcon, SearchIcon, XIcon, UsersIcon, BuildingIcon, FolderIcon } from '@/components/ui/Icons'
import { Alert } from '@/components/ui/Alert'
import { Button } from '@/components/ui/Button'
import { OrgChart } from '@/components/organogram/OrgChart'
import { DepartmentOrgChart } from '@/components/organogram/DepartmentOrgChart'
import { ProjectOrgChart } from '@/components/organogram/ProjectOrgChart'

interface HierarchyData {
  items: HierarchyEmployee[]
  currentEmployeeId: string | null
  managerChainIds: string[]
  directReportIds: string[]
}

type ViewMode = 'person' | 'department' | 'project'

function OrganogramContent() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [hierarchyData, setHierarchyData] = useState<HierarchyData | null>(null)
  const [departmentData, setDepartmentData] = useState<Department[] | null>(null)
  const [projectData, setProjectData] = useState<Project[] | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Get view mode and search query from URL
  const viewMode = (searchParams.get('view') as ViewMode) || 'person'
  const searchQuery = searchParams.get('q') ?? ''

  const setViewMode = (mode: ViewMode) => {
    const params = new URLSearchParams(searchParams.toString())
    params.set('view', mode)
    router.replace(`/organogram?${params.toString()}`, { scroll: false })
  }

  const setSearchQuery = (query: string) => {
    const params = new URLSearchParams(searchParams.toString())
    if (query) {
      params.set('q', query)
    } else {
      params.delete('q')
    }
    router.replace(`/organogram?${params.toString()}`, { scroll: false })
  }

  useEffect(() => {
    fetchData()
  }, [])

  const fetchData = async () => {
    try {
      setLoading(true)
      setError(null)

      // Fetch hierarchy, department, and project data in parallel
      const [hierarchy, departments, projects] = await Promise.all([
        HierarchyApi.getFull(),
        DepartmentsApi.getHierarchy(),
        ProjectsApi.getHierarchy(),
      ])

      setHierarchyData(hierarchy)
      setDepartmentData(departments.items)
      setProjectData(projects.items)
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Failed to load org chart'
      setError(message)
    } finally {
      setLoading(false)
    }
  }

  // Filter employees based on search query
  const filteredEmployees = hierarchyData?.items.filter((emp) => {
    if (!searchQuery.trim()) return true
    const query = searchQuery.toLowerCase()
    return (
      emp.firstName.toLowerCase().includes(query) ||
      emp.lastName.toLowerCase().includes(query) ||
      emp.email.toLowerCase().includes(query) ||
      emp.department.toLowerCase().includes(query) ||
      emp.position.toLowerCase().includes(query) ||
      emp.employeeId.toLowerCase().includes(query)
    )
  }) ?? []

  // Filter departments based on search query
  const filteredDepartments = departmentData?.filter((dept) => {
    if (!searchQuery.trim()) return true
    const query = searchQuery.toLowerCase()
    return (
      dept.name.toLowerCase().includes(query) ||
      (dept.kpi && dept.kpi.toLowerCase().includes(query)) ||
      (dept.head && `${dept.head.firstName} ${dept.head.lastName}`.toLowerCase().includes(query))
    )
  }) ?? []

  // Filter projects based on search query
  const filteredProjects = projectData?.filter((proj) => {
    if (!searchQuery.trim()) return true
    const query = searchQuery.toLowerCase()
    return (
      proj.name.toLowerCase().includes(query) ||
      (proj.code && proj.code.toLowerCase().includes(query)) ||
      (proj.description && proj.description.toLowerCase().includes(query)) ||
      (proj.lead && `${proj.lead.firstName} ${proj.lead.lastName}`.toLowerCase().includes(query)) ||
      (proj.members?.some(m =>
        `${m.employee.firstName} ${m.employee.lastName}`.toLowerCase().includes(query) ||
        (m.role && m.role.toLowerCase().includes(query))
      ))
    )
  }) ?? []

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <SpinnerIcon className="h-8 w-8 animate-spin text-cyan-600" />
      </div>
    )
  }

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center h-64">
        <Alert variant="error" className="max-w-md mb-4">
          {error}
        </Alert>
        <Button onClick={fetchData}>Retry</Button>
      </div>
    )
  }

  return (
    <Card>
      {/* View Toggle & Search */}
      <div className="mb-6 space-y-4">
        {/* View Mode Toggle */}
        <div className="flex items-center gap-2 p-1 bg-slate-100 rounded-lg w-fit">
          <button
            onClick={() => setViewMode('person')}
            className={`flex items-center gap-2 px-4 py-2 rounded-md text-sm font-medium transition-all ${
              viewMode === 'person'
                ? 'bg-white text-slate-900 shadow-sm'
                : 'text-slate-600 hover:text-slate-900'
            }`}
          >
            <UsersIcon className="h-4 w-4" />
            By Person
          </button>
          <button
            onClick={() => setViewMode('department')}
            className={`flex items-center gap-2 px-4 py-2 rounded-md text-sm font-medium transition-all ${
              viewMode === 'department'
                ? 'bg-white text-slate-900 shadow-sm'
                : 'text-slate-600 hover:text-slate-900'
            }`}
          >
            <BuildingIcon className="h-4 w-4" />
            By Department
          </button>
          <button
            onClick={() => setViewMode('project')}
            className={`flex items-center gap-2 px-4 py-2 rounded-md text-sm font-medium transition-all ${
              viewMode === 'project'
                ? 'bg-white text-slate-900 shadow-sm'
                : 'text-slate-600 hover:text-slate-900'
            }`}
          >
            <FolderIcon className="h-4 w-4" />
            By Project
          </button>
        </div>

        {/* Search */}
        <div className="relative">
          <SearchIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-400" />
          <input
            type="text"
            placeholder={
              viewMode === 'person'
                ? "Search by name, department, position..."
                : viewMode === 'department'
                  ? "Search by department, head..."
                  : "Search by project, lead, member..."
            }
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full pl-10 pr-10 py-2.5 border border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent"
          />
          {searchQuery && (
            <button
              onClick={() => setSearchQuery('')}
              className="absolute right-3 top-1/2 -translate-y-1/2 p-1 hover:bg-slate-100 rounded-full"
            >
              <XIcon className="h-4 w-4 text-slate-400" />
            </button>
          )}
        </div>
        {searchQuery && (
          <p className="text-sm text-slate-500">
            Showing{' '}
            {viewMode === 'person'
              ? filteredEmployees.length
              : viewMode === 'department'
                ? filteredDepartments.length
                : filteredProjects.length}{' '}
            of{' '}
            {viewMode === 'person'
              ? hierarchyData?.items.length
              : viewMode === 'department'
                ? departmentData?.length
                : projectData?.length}{' '}
            {viewMode === 'person' ? 'employees' : viewMode === 'department' ? 'departments' : 'projects'}
          </p>
        )}
      </div>

      {/* Org Chart based on view mode */}
      {viewMode === 'person' ? (
        <OrgChart
          employees={filteredEmployees}
          currentEmployeeId={hierarchyData?.currentEmployeeId ?? null}
          managerChainIds={hierarchyData?.managerChainIds ?? []}
          directReportIds={hierarchyData?.directReportIds ?? []}
        />
      ) : viewMode === 'department' ? (
        <DepartmentOrgChart
          departments={filteredDepartments}
        />
      ) : (
        <ProjectOrgChart
          projects={filteredProjects}
        />
      )}
    </Card>
  )
}

export default function OrganogramPage() {
  return (
    <>
      <ListPageHeader
        title="Organization Chart"
        description="View company structure by person or department"
        icon={<OrgChartIcon className="h-6 w-6 text-white" />}
      />

      <Suspense
        fallback={
          <div className="flex items-center justify-center h-64">
            <SpinnerIcon className="h-8 w-8 animate-spin text-cyan-600" />
          </div>
        }
      >
        <OrganogramContent />
      </Suspense>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/performance/disciplinary/[id]/page.tsx">
'use client'

import { useEffect, useState } from 'react'
import { useRouter, useParams } from 'next/navigation'
import { DisciplinaryActionsApi, type DisciplinaryAction } from '@/lib/api-client'
import { ShieldExclamationIcon, PencilIcon, TrashIcon } from '@/components/ui/Icons'
import { PageHeader } from '@/components/ui/PageHeader'
import { Card, CardDivider } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import { StatusBadge } from '@/components/ui/Badge'

const VIOLATION_TYPE_LABELS: Record<string, string> = {
  ATTENDANCE: 'Attendance',
  CONDUCT: 'Conduct',
  PERFORMANCE: 'Performance',
  POLICY_VIOLATION: 'Policy Violation',
  SAFETY: 'Safety',
  HARASSMENT: 'Harassment',
  INSUBORDINATION: 'Insubordination',
  THEFT_FRAUD: 'Theft/Fraud',
  SUBSTANCE_ABUSE: 'Substance Abuse',
  OTHER: 'Other',
}

const VIOLATION_REASON_LABELS: Record<string, string> = {
  EXCESSIVE_ABSENCES: 'Excessive Absences',
  TARDINESS: 'Tardiness',
  UNAUTHORIZED_LEAVE: 'Unauthorized Leave',
  NO_CALL_NO_SHOW: 'No Call/No Show',
  UNPROFESSIONAL_BEHAVIOR: 'Unprofessional Behavior',
  DISRUPTIVE_CONDUCT: 'Disruptive Conduct',
  INAPPROPRIATE_LANGUAGE: 'Inappropriate Language',
  DRESS_CODE_VIOLATION: 'Dress Code Violation',
  POOR_QUALITY_WORK: 'Poor Quality Work',
  MISSED_DEADLINES: 'Missed Deadlines',
  FAILURE_TO_FOLLOW_INSTRUCTIONS: 'Failure to Follow Instructions',
  NEGLIGENCE: 'Negligence',
  CONFIDENTIALITY_BREACH: 'Confidentiality Breach',
  DATA_SECURITY_VIOLATION: 'Data Security Violation',
  EXPENSE_POLICY_VIOLATION: 'Expense Policy Violation',
  IT_POLICY_VIOLATION: 'IT Policy Violation',
  SAFETY_PROTOCOL_VIOLATION: 'Safety Protocol Violation',
  EQUIPMENT_MISUSE: 'Equipment Misuse',
  HARASSMENT_DISCRIMINATION: 'Harassment/Discrimination',
  WORKPLACE_VIOLENCE: 'Workplace Violence',
  THEFT: 'Theft',
  FRAUD: 'Fraud',
  FALSIFICATION: 'Falsification of Records',
  SUBSTANCE_USE_AT_WORK: 'Substance Use at Work',
  OTHER: 'Other',
}

const SEVERITY_LABELS: Record<string, string> = {
  MINOR: 'Minor',
  MODERATE: 'Moderate',
  MAJOR: 'Major',
  CRITICAL: 'Critical',
}

const SEVERITY_COLORS: Record<string, string> = {
  MINOR: 'bg-slate-100 text-slate-700',
  MODERATE: 'bg-amber-100 text-amber-700',
  MAJOR: 'bg-orange-100 text-orange-700',
  CRITICAL: 'bg-red-100 text-red-700',
}

const ACTION_LABELS: Record<string, string> = {
  VERBAL_WARNING: 'Verbal Warning',
  WRITTEN_WARNING: 'Written Warning',
  FINAL_WARNING: 'Final Warning',
  SUSPENSION: 'Suspension',
  DEMOTION: 'Demotion',
  TERMINATION: 'Termination',
  PIP: 'Performance Improvement Plan',
  TRAINING_REQUIRED: 'Training Required',
  NO_ACTION: 'No Action',
}

const STATUS_LABELS: Record<string, string> = {
  OPEN: 'Open',
  UNDER_INVESTIGATION: 'Under Investigation',
  ACTION_TAKEN: 'Action Taken',
  APPEALED: 'Appealed',
  CLOSED: 'Closed',
  DISMISSED: 'Dismissed',
}

function DetailRow({ label, value }: { label: string; value: React.ReactNode }) {
  if (!value) return null
  return (
    <div className="py-3 sm:grid sm:grid-cols-3 sm:gap-4">
      <dt className="text-sm font-medium text-slate-500">{label}</dt>
      <dd className="mt-1 text-sm text-slate-900 sm:col-span-2 sm:mt-0">{value}</dd>
    </div>
  )
}

function SeverityBadge({ severity }: { severity: string }) {
  const colorClass = SEVERITY_COLORS[severity] || 'bg-slate-100 text-slate-700'
  return (
    <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${colorClass}`}>
      {SEVERITY_LABELS[severity] || severity}
    </span>
  )
}

export default function ViewDisciplinaryPage() {
  const router = useRouter()
  const params = useParams()
  const id = params.id as string

  const [action, setAction] = useState<DisciplinaryAction | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [deleting, setDeleting] = useState(false)

  useEffect(() => {
    async function load() {
      try {
        const data = await DisciplinaryActionsApi.get(id)
        setAction(data)
      } catch (e: any) {
        setError(e.message || 'Failed to load record')
      } finally {
        setLoading(false)
      }
    }
    load()
  }, [id])

  async function handleDelete() {
    if (!confirm('Are you sure you want to delete this disciplinary record?')) return
    setDeleting(true)
    try {
      await DisciplinaryActionsApi.delete(id)
      router.push('/performance/disciplinary')
    } catch (e: any) {
      setError(e.message || 'Failed to delete record')
      setDeleting(false)
    }
  }

  const formatDate = (dateStr?: string | null) => {
    if (!dateStr) return '—'
    return new Date(dateStr).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    })
  }

  if (loading) {
    return (
      <>
        <PageHeader
          title="Disciplinary Record"
          description="Loading..."
          icon={<ShieldExclamationIcon className="h-6 w-6 text-white" />}
          showBack
        />
        <div className="max-w-3xl">
          <Card padding="lg">
            <div className="animate-pulse space-y-6">
              <div className="h-6 bg-slate-200 rounded w-1/3" />
              <div className="h-4 bg-slate-200 rounded w-2/3" />
              <div className="h-4 bg-slate-200 rounded w-1/2" />
            </div>
          </Card>
        </div>
      </>
    )
  }

  if (!action) {
    return (
      <>
        <PageHeader
          title="Disciplinary Record"
          description="Not Found"
          icon={<ShieldExclamationIcon className="h-6 w-6 text-white" />}
          showBack
        />
        <div className="max-w-3xl">
          <Card padding="lg">
            <Alert variant="error">{error || 'Record not found'}</Alert>
          </Card>
        </div>
      </>
    )
  }

  return (
    <>
      <PageHeader
        title="Disciplinary Record"
        description={`${action.employee?.firstName} ${action.employee?.lastName}`}
        icon={<ShieldExclamationIcon className="h-6 w-6 text-white" />}
        showBack
      />

      <div className="max-w-3xl space-y-6">
        {error && (
          <Alert variant="error" onDismiss={() => setError(null)}>
            {error}
          </Alert>
        )}

        <Card padding="lg">
          <div className="flex items-start justify-between mb-6">
            <div>
              <h2 className="text-xl font-semibold text-slate-900">
                {action.employee?.firstName} {action.employee?.lastName}
              </h2>
              <p className="text-sm text-slate-500">
                {action.employee?.position} • {action.employee?.department}
              </p>
            </div>
            <div className="flex items-center gap-2">
              <SeverityBadge severity={action.severity} />
              <StatusBadge status={STATUS_LABELS[action.status] || action.status} />
            </div>
          </div>

          <dl className="divide-y divide-slate-100">
            <DetailRow label="Violation Type" value={VIOLATION_TYPE_LABELS[action.violationType] || action.violationType} />
            <DetailRow label="Specific Reason" value={VIOLATION_REASON_LABELS[action.violationReason] || action.violationReason} />
            <DetailRow label="Incident Date" value={formatDate(action.incidentDate)} />
            <DetailRow label="Reported Date" value={formatDate(action.reportedDate)} />
            <DetailRow label="Reported By" value={action.reportedBy} />
          </dl>
        </Card>

        <Card padding="lg">
          <h3 className="text-lg font-medium text-slate-900 mb-4">Incident Details</h3>
          <dl className="space-y-4">
            <div>
              <dt className="text-sm font-medium text-slate-500 mb-1">Description</dt>
              <dd className="text-sm text-slate-900 whitespace-pre-wrap bg-slate-50 p-3 rounded-lg">{action.description}</dd>
            </div>
            {action.witnesses && (
              <div>
                <dt className="text-sm font-medium text-slate-500 mb-1">Witnesses</dt>
                <dd className="text-sm text-slate-900">{action.witnesses}</dd>
              </div>
            )}
            {action.evidence && (
              <div>
                <dt className="text-sm font-medium text-slate-500 mb-1">Evidence</dt>
                <dd className="text-sm text-slate-900">{action.evidence}</dd>
              </div>
            )}
          </dl>
        </Card>

        <Card padding="lg">
          <h3 className="text-lg font-medium text-slate-900 mb-4">Action Taken</h3>
          <dl className="divide-y divide-slate-100">
            <DetailRow label="Action Type" value={ACTION_LABELS[action.actionTaken] || action.actionTaken} />
            <DetailRow label="Action Date" value={formatDate(action.actionDate)} />
            {action.actionDetails && (
              <div className="py-3">
                <dt className="text-sm font-medium text-slate-500 mb-1">Action Details</dt>
                <dd className="text-sm text-slate-900 whitespace-pre-wrap">{action.actionDetails}</dd>
              </div>
            )}
          </dl>
        </Card>

        {(action.followUpDate || action.followUpNotes || action.resolution) && (
          <Card padding="lg">
            <h3 className="text-lg font-medium text-slate-900 mb-4">Follow-up & Resolution</h3>
            <dl className="divide-y divide-slate-100">
              <DetailRow label="Follow-up Date" value={formatDate(action.followUpDate)} />
              {action.followUpNotes && (
                <div className="py-3">
                  <dt className="text-sm font-medium text-slate-500 mb-1">Follow-up Notes</dt>
                  <dd className="text-sm text-slate-900 whitespace-pre-wrap">{action.followUpNotes}</dd>
                </div>
              )}
              {action.resolution && (
                <div className="py-3">
                  <dt className="text-sm font-medium text-slate-500 mb-1">Resolution</dt>
                  <dd className="text-sm text-slate-900 whitespace-pre-wrap">{action.resolution}</dd>
                </div>
              )}
            </dl>
          </Card>
        )}

        <div className="flex justify-end gap-3">
          <Button
            variant="secondary"
            onClick={handleDelete}
            loading={deleting}
            icon={<TrashIcon className="h-4 w-4" />}
          >
            Delete
          </Button>
          <Button
            href={`/performance/disciplinary/${id}/edit`}
            icon={<PencilIcon className="h-4 w-4" />}
          >
            Edit Record
          </Button>
        </div>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/performance/reviews/[id]/page.tsx">
'use client'

import { useEffect, useState } from 'react'
import { useRouter, useParams } from 'next/navigation'
import { PerformanceReviewsApi, type PerformanceReview } from '@/lib/api-client'
import { ClipboardDocumentCheckIcon, PencilIcon, TrashIcon, StarFilledIcon } from '@/components/ui/Icons'
import { PageHeader } from '@/components/ui/PageHeader'
import { Card, CardDivider } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import { StatusBadge } from '@/components/ui/Badge'

const REVIEW_TYPE_LABELS: Record<string, string> = {
  PROBATION: 'Probation (90-day)',
  QUARTERLY: 'Quarterly',
  SEMI_ANNUAL: 'Semi-Annual',
  ANNUAL: 'Annual',
  PROMOTION: 'Promotion',
  PIP: 'Performance Improvement Plan',
}

const STATUS_LABELS: Record<string, string> = {
  DRAFT: 'Draft',
  PENDING_REVIEW: 'Pending Review',
  COMPLETED: 'Completed',
  ACKNOWLEDGED: 'Acknowledged',
}

function RatingDisplay({ label, value }: { label: string; value: number | null | undefined }) {
  if (value == null) return null
  return (
    <div className="flex items-center justify-between py-2">
      <span className="text-sm text-slate-600">{label}</span>
      <div className="flex items-center gap-0.5">
        {[1, 2, 3, 4, 5].map((star) => (
          <StarFilledIcon
            key={star}
            className={`h-4 w-4 ${star <= value ? 'text-amber-400' : 'text-slate-200'}`}
          />
        ))}
        <span className="ml-2 text-sm font-medium text-slate-700">{value}/5</span>
      </div>
    </div>
  )
}

function DetailRow({ label, value }: { label: string; value: React.ReactNode }) {
  if (!value) return null
  return (
    <div className="py-3 sm:grid sm:grid-cols-3 sm:gap-4">
      <dt className="text-sm font-medium text-slate-500">{label}</dt>
      <dd className="mt-1 text-sm text-slate-900 sm:col-span-2 sm:mt-0">{value}</dd>
    </div>
  )
}

export default function ViewReviewPage() {
  const router = useRouter()
  const params = useParams()
  const id = params.id as string

  const [review, setReview] = useState<PerformanceReview | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [deleting, setDeleting] = useState(false)

  useEffect(() => {
    async function load() {
      try {
        const data = await PerformanceReviewsApi.get(id)
        setReview(data)
      } catch (e: any) {
        setError(e.message || 'Failed to load review')
      } finally {
        setLoading(false)
      }
    }
    load()
  }, [id])

  async function handleDelete() {
    if (!confirm('Are you sure you want to delete this review?')) return
    setDeleting(true)
    try {
      await PerformanceReviewsApi.delete(id)
      router.push('/performance/reviews')
    } catch (e: any) {
      setError(e.message || 'Failed to delete review')
      setDeleting(false)
    }
  }

  const formatDate = (dateStr?: string) => {
    if (!dateStr) return '—'
    return new Date(dateStr).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    })
  }

  if (loading) {
    return (
      <>
        <PageHeader
          title="Performance Review"
          description="Loading..."
          icon={<ClipboardDocumentCheckIcon className="h-6 w-6 text-white" />}
          showBack
        />
        <div className="max-w-3xl">
          <Card padding="lg">
            <div className="animate-pulse space-y-6">
              <div className="h-6 bg-slate-200 rounded w-1/3" />
              <div className="h-4 bg-slate-200 rounded w-2/3" />
              <div className="h-4 bg-slate-200 rounded w-1/2" />
            </div>
          </Card>
        </div>
      </>
    )
  }

  if (!review) {
    return (
      <>
        <PageHeader
          title="Performance Review"
          description="Not Found"
          icon={<ClipboardDocumentCheckIcon className="h-6 w-6 text-white" />}
          showBack
        />
        <div className="max-w-3xl">
          <Card padding="lg">
            <Alert variant="error">{error || 'Review not found'}</Alert>
          </Card>
        </div>
      </>
    )
  }

  return (
    <>
      <PageHeader
        title="Performance Review"
        description={`${review.employee?.firstName} ${review.employee?.lastName}`}
        icon={<ClipboardDocumentCheckIcon className="h-6 w-6 text-white" />}
        showBack
      />

      <div className="max-w-3xl space-y-6">
        {error && (
          <Alert variant="error" onDismiss={() => setError(null)}>
            {error}
          </Alert>
        )}

        <Card padding="lg">
          <div className="flex items-start justify-between mb-6">
            <div>
              <h2 className="text-xl font-semibold text-slate-900">
                {review.employee?.firstName} {review.employee?.lastName}
              </h2>
              <p className="text-sm text-slate-500">
                {review.employee?.position} • {review.employee?.department}
              </p>
            </div>
            <StatusBadge status={STATUS_LABELS[review.status] || review.status} />
          </div>

          <dl className="divide-y divide-slate-100">
            <DetailRow label="Review Type" value={REVIEW_TYPE_LABELS[review.reviewType] || review.reviewType} />
            <DetailRow label="Review Period" value={review.reviewPeriod} />
            <DetailRow label="Review Date" value={formatDate(review.reviewDate)} />
            <DetailRow label="Reviewer" value={review.reviewerName} />
          </dl>
        </Card>

        <Card padding="lg">
          <h3 className="text-lg font-medium text-slate-900 mb-4">Performance Ratings</h3>
          <div className="bg-amber-50 rounded-lg p-4 mb-4">
            <div className="flex items-center justify-between">
              <span className="font-medium text-slate-900">Overall Rating</span>
              <div className="flex items-center gap-1">
                {[1, 2, 3, 4, 5].map((star) => (
                  <StarFilledIcon
                    key={star}
                    className={`h-6 w-6 ${star <= review.overallRating ? 'text-amber-400' : 'text-slate-200'}`}
                  />
                ))}
                <span className="ml-2 text-lg font-semibold text-slate-900">{review.overallRating}/5</span>
              </div>
            </div>
          </div>
          <div className="divide-y divide-slate-100">
            <RatingDisplay label="Quality of Work" value={review.qualityOfWork} />
            <RatingDisplay label="Productivity" value={review.productivity} />
            <RatingDisplay label="Communication" value={review.communication} />
            <RatingDisplay label="Teamwork" value={review.teamwork} />
            <RatingDisplay label="Initiative" value={review.initiative} />
            <RatingDisplay label="Attendance" value={review.attendance} />
          </div>
        </Card>

        {(review.strengths || review.areasToImprove || review.goals || review.comments) && (
          <Card padding="lg">
            <h3 className="text-lg font-medium text-slate-900 mb-4">Feedback</h3>
            <dl className="space-y-4">
              {review.strengths && (
                <div>
                  <dt className="text-sm font-medium text-slate-500 mb-1">Strengths</dt>
                  <dd className="text-sm text-slate-900 whitespace-pre-wrap">{review.strengths}</dd>
                </div>
              )}
              {review.areasToImprove && (
                <div>
                  <dt className="text-sm font-medium text-slate-500 mb-1">Areas to Improve</dt>
                  <dd className="text-sm text-slate-900 whitespace-pre-wrap">{review.areasToImprove}</dd>
                </div>
              )}
              {review.goals && (
                <div>
                  <dt className="text-sm font-medium text-slate-500 mb-1">Goals for Next Period</dt>
                  <dd className="text-sm text-slate-900 whitespace-pre-wrap">{review.goals}</dd>
                </div>
              )}
              {review.comments && (
                <div>
                  <dt className="text-sm font-medium text-slate-500 mb-1">Additional Comments</dt>
                  <dd className="text-sm text-slate-900 whitespace-pre-wrap">{review.comments}</dd>
                </div>
              )}
            </dl>
          </Card>
        )}

        <div className="flex justify-end gap-3">
          <Button
            variant="secondary"
            onClick={handleDelete}
            loading={deleting}
            icon={<TrashIcon className="h-4 w-4" />}
          >
            Delete
          </Button>
          <Button
            href={`/performance/reviews/${id}/edit`}
            icon={<PencilIcon className="h-4 w-4" />}
          >
            Edit Review
          </Button>
        </div>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/policies/[id]/page.tsx">
'use client'

import { useEffect, useState } from 'react'
import { useParams } from 'next/navigation'
import Link from 'next/link'
import ReactMarkdown from 'react-markdown'
import remarkGfm from 'remark-gfm'
import { PoliciesApi, type Policy } from '@/lib/api-client'
import { DocumentIcon, PencilIcon } from '@/components/ui/Icons'
import { PageHeader } from '@/components/ui/PageHeader'
import { Card } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { StatusBadge } from '@/components/ui/Badge'
import { EmptyState } from '@/components/ui/EmptyState'

function formatDate(dateStr: string | null | undefined) {
  if (!dateStr) return '—'
  try {
    return new Date(dateStr).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    })
  } catch {
    return dateStr
  }
}

function getCategoryLabel(category: string) {
  const map: Record<string, string> = {
    LEAVE: 'Leave',
    PERFORMANCE: 'Performance',
    CONDUCT: 'Conduct',
    SECURITY: 'Security',
    COMPENSATION: 'Compensation',
    OTHER: 'Other',
  }
  return map[category] || category
}

function getRegionLabel(region: string) {
  const map: Record<string, string> = {
    KANSAS_US: 'US (Kansas)',
    PAKISTAN: 'Pakistan',
  }
  return map[region] || region
}

function MetaItem({ label, children }: { label: string; children: React.ReactNode }) {
  return (
    <div>
      <p className="text-xs font-medium text-slate-500 uppercase tracking-wide mb-1">{label}</p>
      <div className="text-sm text-slate-900">{children}</div>
    </div>
  )
}

export default function ViewPolicyPage() {
  const params = useParams()
  const id = params.id as string

  const [policy, setPolicy] = useState<Policy | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    async function load() {
      try {
        const data = await PoliciesApi.get(id)
        setPolicy(data)
      } catch (e: any) {
        setError(e.message || 'Failed to load policy')
      } finally {
        setLoading(false)
      }
    }
    load()
  }, [id])

  if (loading) {
    return (
      <div className="animate-pulse space-y-6">
        <div className="h-8 bg-slate-200 rounded w-1/3" />
        <div className="h-4 bg-slate-200 rounded w-1/4" />
        <div className="h-64 bg-slate-200 rounded-xl" />
      </div>
    )
  }

  if (error || !policy) {
    return (
      <div className="py-12">
        <EmptyState
          icon={<DocumentIcon className="h-12 w-12" />}
          title={error || 'Policy not found'}
          description="The policy you're looking for doesn't exist or has been removed."
          action={{
            label: 'Back to policies',
            href: '/policies',
          }}
        />
      </div>
    )
  }

  return (
    <>
      <PageHeader
        title={policy.title}
        description="Policy"
        icon={<DocumentIcon className="h-6 w-6 text-white" />}
        showBack
        actions={
          <Button href={`/policies/${id}/edit`} icon={<PencilIcon className="h-4 w-4" />}>
            Edit
          </Button>
        }
      />

      <div className="max-w-4xl space-y-6">
        {/* Meta Info */}
        <Card padding="md">
          <div className="grid grid-cols-2 sm:grid-cols-5 gap-6">
            <MetaItem label="Category">
              {getCategoryLabel(policy.category)}
            </MetaItem>
            <MetaItem label="Region">
              {getRegionLabel(policy.region)}
            </MetaItem>
            <MetaItem label="Status">
              <StatusBadge status={policy.status} />
            </MetaItem>
            <MetaItem label="Version">
              <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-slate-100 text-slate-700">
                v{policy.version}
              </span>
            </MetaItem>
            <MetaItem label="Effective Date">
              {formatDate(policy.effectiveDate)}
            </MetaItem>
          </div>
        </Card>

        {/* Summary */}
        {policy.summary && (
          <Card padding="md">
            <h2 className="text-sm font-semibold text-slate-900 mb-3">Summary</h2>
            <p className="text-sm text-slate-600 leading-relaxed">{policy.summary}</p>
          </Card>
        )}

        {/* Content */}
        {policy.content && (
          <Card padding="md">
            <h2 className="text-sm font-semibold text-slate-900 mb-4">Policy Content</h2>
            <div className="prose prose-sm max-w-none prose-headings:text-cyan-700 prose-h1:text-xl prose-h1:font-bold prose-h2:text-lg prose-h2:font-semibold prose-h2:border-b prose-h2:border-cyan-200 prose-h2:pb-2 prose-h2:mt-6 prose-table:text-sm prose-th:bg-cyan-50 prose-th:text-cyan-900 prose-th:p-2 prose-th:border prose-th:border-cyan-200 prose-td:p-2 prose-td:border prose-td:border-slate-200 prose-strong:text-cyan-800 prose-a:text-cyan-600 hover:prose-a:text-cyan-800">
              <ReactMarkdown remarkPlugins={[remarkGfm]}>
                {policy.content}
              </ReactMarkdown>
            </div>
          </Card>
        )}

        {/* No content message */}
        {!policy.content && !policy.summary && (
          <Card padding="lg">
            <EmptyState
              icon={<DocumentIcon className="h-10 w-10" />}
              title="No content has been added"
              description="This policy doesn't have any content yet."
              action={{
                label: 'Add content',
                href: `/policies/${id}/edit`,
              }}
            />
          </Card>
        )}
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/policies/page.tsx">
'use client'

import { useCallback, useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { PoliciesApi, type Policy } from '@/lib/api-client'
import {
  DocumentIcon,
  PlusIcon,
} from '@/components/ui/Icons'
import { ListPageHeader } from '@/components/ui/PageHeader'
import { Button } from '@/components/ui/Button'
import { StatusBadge } from '@/components/ui/Badge'
import { Card } from '@/components/ui/Card'
import { SearchForm } from '@/components/ui/SearchForm'
import {
  Table,
  TableHeader,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  TableSkeleton,
  ResultsCount,
} from '@/components/ui/Table'
import { TableEmptyState } from '@/components/ui/EmptyState'

const REGION_LABELS: Record<string, string> = {
  ALL: 'All Regions',
  KANSAS_US: 'US (Kansas)',
  PAKISTAN: 'Pakistan',
}

export default function PoliciesPage() {
  const router = useRouter()
  const [items, setItems] = useState<Policy[]>([])
  const [q, setQ] = useState('')
  const [loading, setLoading] = useState(true)

  const load = useCallback(async () => {
    try {
      setLoading(true)
      const data = await PoliciesApi.list({ q })
      setItems(data.items || [])
    } catch (e) {
      console.error('Failed to load policies', e)
      setItems([])
    } finally {
      setLoading(false)
    }
  }, [q])

  useEffect(() => {
    load()
  }, [load])

  return (
    <>
      <ListPageHeader
        title="Policies"
        description="Manage company policies and guidelines"
        icon={<DocumentIcon className="h-6 w-6 text-white" />}
        action={
          <Button href="/policies/add" icon={<PlusIcon className="h-4 w-4" />}>
            Add Policy
          </Button>
        }
      />

      <div className="space-y-6">
        {/* Search */}
        <Card padding="md">
          <SearchForm
            value={q}
            onChange={setQ}
            onSubmit={load}
            placeholder="Search policies by title..."
          />
        </Card>

        {/* Results count */}
        <ResultsCount
          count={items.length}
          singular="policy"
          plural="policies"
          loading={loading}
        />

        {/* Table */}
        <Table>
          <TableHeader>
            <TableHead>Title</TableHead>
            <TableHead>Category</TableHead>
            <TableHead>Region</TableHead>
            <TableHead>Version</TableHead>
            <TableHead>Status</TableHead>
          </TableHeader>
          <TableBody>
            {loading ? (
              <TableSkeleton rows={5} columns={5} />
            ) : items.length === 0 ? (
              <TableEmptyState
                colSpan={5}
                icon={<DocumentIcon className="h-10 w-10" />}
                title="No policies found"
                action={{
                  label: 'Add your first policy',
                  href: '/policies/add',
                }}
              />
            ) : (
              items.map((p) => (
                <TableRow
                  key={p.id}
                  onClick={() => router.push(`/policies/${p.id}`)}
                >
                  <TableCell>
                    <div>
                      <p className="font-medium text-slate-900">{p.title}</p>
                      {p.summary && (
                        <p className="text-xs text-slate-500 mt-0.5 line-clamp-1">{p.summary}</p>
                      )}
                    </div>
                  </TableCell>
                  <TableCell className="text-slate-600">{p.category}</TableCell>
                  <TableCell className="text-slate-600">{REGION_LABELS[p.region] || p.region}</TableCell>
                  <TableCell>
                    <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-slate-100 text-slate-700">
                      v{p.version}
                    </span>
                  </TableCell>
                  <TableCell>
                    <StatusBadge status={p.status} />
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/api/departments/hierarchy/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../lib/prisma'
import { withRateLimit } from '@/lib/api-helpers'

// Departments to exclude from the organogram hierarchy view
const EXCLUDED_DEPARTMENTS = ['executive', 'executive supervision', 'general']

export async function GET(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    // Fetch all departments with their heads and parent relationships
    // Exclude administrative/placeholder departments from the hierarchy
    const departments = await prisma.department.findMany({
      where: {
        NOT: {
          name: {
            in: EXCLUDED_DEPARTMENTS,
            mode: 'insensitive',
          },
        },
      },
      select: {
        id: true,
        name: true,
        code: true,
        kpi: true,
        headId: true,
        parentId: true,
        head: {
          select: {
            id: true,
            employeeId: true,
            firstName: true,
            lastName: true,
            email: true,
            position: true,
            avatar: true,
          },
        },
        parent: {
          select: {
            id: true,
            name: true,
          },
        },
        children: {
          where: {
            NOT: {
              name: {
                in: EXCLUDED_DEPARTMENTS,
                mode: 'insensitive',
              },
            },
          },
          select: {
            id: true,
            name: true,
          },
        },
        _count: {
          select: {
            employees: true,
          },
        },
      },
      orderBy: { name: 'asc' },
    })

    return NextResponse.json({ items: departments })
  } catch (e) {
    console.error('[Departments Hierarchy] Error:', e)
    return NextResponse.json(
      { error: 'Failed to fetch department hierarchy' },
      { status: 500 }
    )
  }
}
</file>

<file path="apps/hrms/app/api/disciplinary-actions/[id]/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../lib/prisma'
import { UpdateDisciplinaryActionSchema } from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'
import { getCurrentEmployeeId } from '@/lib/current-user'
import { canManageEmployee } from '@/lib/permissions'

type RouteContext = { params: Promise<{ id: string }> }

export async function GET(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const item = await prisma.disciplinaryAction.findUnique({
      where: { id },
      include: {
        employee: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            employeeId: true,
            department: true,
            position: true,
            email: true,
          },
        },
      },
    })

    if (!item) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    return NextResponse.json(item)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch disciplinary action')
  }
}

export async function PATCH(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    // Check if current user has permission to manage this employee
    const existing = await prisma.disciplinaryAction.findUnique({
      where: { id },
      select: { employeeId: true },
    })
    if (!existing) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    const currentEmployeeId = await getCurrentEmployeeId()
    if (!currentEmployeeId) {
      return NextResponse.json({ error: 'Unauthorized - not logged in' }, { status: 401 })
    }

    const permissionCheck = await canManageEmployee(currentEmployeeId, existing.employeeId)
    if (!permissionCheck.canManage) {
      return NextResponse.json(
        { error: `Permission denied: ${permissionCheck.reason}` },
        { status: 403 }
      )
    }

    const body = await req.json()

    const validation = validateBody(UpdateDisciplinaryActionSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data
    const updates: Record<string, unknown> = {}

    if (data.violationType !== undefined) updates.violationType = data.violationType
    if (data.violationReason !== undefined) updates.violationReason = data.violationReason
    if (data.severity !== undefined) updates.severity = data.severity
    if (data.incidentDate !== undefined) updates.incidentDate = new Date(data.incidentDate)
    if (data.reportedBy !== undefined) updates.reportedBy = data.reportedBy
    if (data.description !== undefined) updates.description = data.description
    if (data.witnesses !== undefined) updates.witnesses = data.witnesses
    if (data.evidence !== undefined) updates.evidence = data.evidence
    if (data.actionTaken !== undefined) updates.actionTaken = data.actionTaken
    if (data.actionDate !== undefined) updates.actionDate = data.actionDate ? new Date(data.actionDate) : null
    if (data.actionDetails !== undefined) updates.actionDetails = data.actionDetails
    if (data.followUpDate !== undefined) updates.followUpDate = data.followUpDate ? new Date(data.followUpDate) : null
    if (data.followUpNotes !== undefined) updates.followUpNotes = data.followUpNotes
    if (data.status !== undefined) updates.status = data.status
    if (data.resolution !== undefined) updates.resolution = data.resolution

    const item = await prisma.disciplinaryAction.update({
      where: { id },
      data: updates,
      include: {
        employee: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            employeeId: true,
          },
        },
      },
    })

    return NextResponse.json(item)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to update disciplinary action')
  }
}

export async function DELETE(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    // Check if current user has permission to manage this employee
    const existing = await prisma.disciplinaryAction.findUnique({
      where: { id },
      select: { employeeId: true },
    })
    if (!existing) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    const currentEmployeeId = await getCurrentEmployeeId()
    if (!currentEmployeeId) {
      return NextResponse.json({ error: 'Unauthorized - not logged in' }, { status: 401 })
    }

    const permissionCheck = await canManageEmployee(currentEmployeeId, existing.employeeId)
    if (!permissionCheck.canManage) {
      return NextResponse.json(
        { error: `Permission denied: ${permissionCheck.reason}` },
        { status: 403 }
      )
    }

    await prisma.disciplinaryAction.delete({ where: { id } })
    return NextResponse.json({ ok: true })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to delete disciplinary action')
  }
}
</file>

<file path="apps/hrms/app/api/disciplinary-actions/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'
import {
  CreateDisciplinaryActionSchema,
  PaginationSchema,
  MAX_PAGINATION_LIMIT,
  ViolationTypeEnum,
  ViolationSeverityEnum,
  DisciplinaryStatusEnum,
} from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'
import { getCurrentEmployeeId } from '@/lib/current-user'
import { canManageEmployee } from '@/lib/permissions'

export async function GET(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { searchParams } = new URL(req.url)

    const paginationResult = PaginationSchema.safeParse({
      take: searchParams.get('take') || undefined,
      skip: searchParams.get('skip') || undefined,
      q: searchParams.get('q') || undefined,
    })

    const take = paginationResult.success ? paginationResult.data.take : 50
    const skip = paginationResult.success ? paginationResult.data.skip : 0
    const q = paginationResult.success ? paginationResult.data.q?.toLowerCase() : ''

    const where: Record<string, unknown> = {}

    if (q) {
      where.OR = [
        { description: { contains: q, mode: 'insensitive' } },
        { reportedBy: { contains: q, mode: 'insensitive' } },
        { employee: { firstName: { contains: q, mode: 'insensitive' } } },
        { employee: { lastName: { contains: q, mode: 'insensitive' } } },
      ]
    }

    const employeeIdParam = searchParams.get('employeeId')
    if (employeeIdParam) {
      where.employeeId = employeeIdParam
    }

    const violationTypeParam = searchParams.get('violationType')
    if (violationTypeParam) {
      const typeValidation = ViolationTypeEnum.safeParse(violationTypeParam.toUpperCase())
      if (typeValidation.success) {
        where.violationType = typeValidation.data
      }
    }

    const severityParam = searchParams.get('severity')
    if (severityParam) {
      const severityValidation = ViolationSeverityEnum.safeParse(severityParam.toUpperCase())
      if (severityValidation.success) {
        where.severity = severityValidation.data
      }
    }

    const statusParam = searchParams.get('status')
    if (statusParam) {
      const statusValidation = DisciplinaryStatusEnum.safeParse(statusParam.toUpperCase())
      if (statusValidation.success) {
        where.status = statusValidation.data
      }
    }

    const [items, total] = await Promise.all([
      prisma.disciplinaryAction.findMany({
        where,
        take: Math.min(take, MAX_PAGINATION_LIMIT),
        skip,
        orderBy: { incidentDate: 'desc' },
        include: {
          employee: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              employeeId: true,
              department: true,
              position: true,
            },
          },
        },
      }),
      prisma.disciplinaryAction.count({ where }),
    ])

    return NextResponse.json({ items, total })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch disciplinary actions')
  }
}

export async function POST(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const body = await req.json()

    const validation = validateBody(CreateDisciplinaryActionSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data

    // Verify employee exists
    const employee = await prisma.employee.findUnique({
      where: { id: data.employeeId },
    })
    if (!employee) {
      return NextResponse.json({ error: 'Employee not found' }, { status: 404 })
    }

    // Check if current user has permission to manage this employee
    const currentEmployeeId = await getCurrentEmployeeId()
    if (!currentEmployeeId) {
      return NextResponse.json({ error: 'Unauthorized - not logged in' }, { status: 401 })
    }

    const permissionCheck = await canManageEmployee(currentEmployeeId, data.employeeId)
    if (!permissionCheck.canManage) {
      return NextResponse.json(
        { error: `Permission denied: ${permissionCheck.reason}` },
        { status: 403 }
      )
    }

    const item = await prisma.disciplinaryAction.create({
      data: {
        employeeId: data.employeeId,
        violationType: data.violationType,
        violationReason: data.violationReason,
        severity: data.severity,
        incidentDate: new Date(data.incidentDate),
        reportedBy: data.reportedBy,
        description: data.description,
        witnesses: data.witnesses ?? null,
        evidence: data.evidence ?? null,
        actionTaken: data.actionTaken,
        actionDate: data.actionDate ? new Date(data.actionDate) : null,
        actionDetails: data.actionDetails ?? null,
        followUpDate: data.followUpDate ? new Date(data.followUpDate) : null,
        followUpNotes: data.followUpNotes ?? null,
        status: data.status,
        resolution: data.resolution ?? null,
      },
      include: {
        employee: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            employeeId: true,
          },
        },
      },
    })

    return NextResponse.json(item, { status: 201 })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to create disciplinary action')
  }
}
</file>

<file path="apps/hrms/app/api/hierarchy/route.ts">
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { withRateLimit, safeErrorResponse } from '@/lib/api-helpers'
import { getCurrentUser } from '@/lib/current-user'

type HierarchyEmployee = {
  id: string
  employeeId: string
  firstName: string
  lastName: string
  email: string
  department: string
  position: string
  employmentType: string
  avatar: string | null
  reportsToId: string | null
  status: string
}

export async function GET(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { searchParams } = new URL(req.url)
    const type = searchParams.get('type') || 'direct-reports'

    const user = await getCurrentUser()
    const currentEmployeeId = user?.employee?.id

    if (type === 'direct-reports') {
      if (!currentEmployeeId) {
        return NextResponse.json({ items: [], currentEmployeeId: null })
      }

      const directReports = await prisma.employee.findMany({
        where: {
          reportsToId: currentEmployeeId,
          status: 'ACTIVE',
        },
        select: {
          id: true,
          employeeId: true,
          firstName: true,
          lastName: true,
          email: true,
          department: true,
          position: true,
          employmentType: true,
          avatar: true,
          reportsToId: true,
          status: true,
        },
        orderBy: [{ firstName: 'asc' }, { lastName: 'asc' }],
      })

      return NextResponse.json({ items: directReports, currentEmployeeId })
    }

    if (type === 'manager-chain') {
      if (!currentEmployeeId) {
        return NextResponse.json({ items: [], currentEmployeeId: null })
      }

      const chain: HierarchyEmployee[] = []
      let currentId: string | null = currentEmployeeId

      // Walk up the hierarchy to get the manager chain
      while (currentId) {
        const emp: HierarchyEmployee | null = await prisma.employee.findUnique({
          where: { id: currentId },
          select: {
            id: true,
            employeeId: true,
            firstName: true,
            lastName: true,
            email: true,
            department: true,
            position: true,
            employmentType: true,
            avatar: true,
            reportsToId: true,
            status: true,
          },
        })

        if (!emp) break

        // Skip adding the current user to the chain (we start from their manager)
        if (emp.id !== currentEmployeeId) {
          chain.push(emp)
        }

        currentId = emp.reportsToId
      }

      return NextResponse.json({ items: chain, currentEmployeeId })
    }

    if (type === 'full') {
      // Get all active employees for the full org chart
      const employees = await prisma.employee.findMany({
        where: { status: 'ACTIVE' },
        select: {
          id: true,
          employeeId: true,
          firstName: true,
          lastName: true,
          email: true,
          department: true,
          position: true,
          employmentType: true,
          avatar: true,
          reportsToId: true,
          status: true,
        },
        orderBy: [{ firstName: 'asc' }, { lastName: 'asc' }],
      })

      // Also get the current user's manager chain for highlighting
      const managerChainIds: string[] = []
      if (currentEmployeeId) {
        let managerId: string | null = null
        const currentEmp = employees.find((emp: HierarchyEmployee) => emp.id === currentEmployeeId)
        if (currentEmp) {
          managerId = currentEmp.reportsToId
        }

        while (managerId) {
          managerChainIds.push(managerId)
          const manager = employees.find((emp: HierarchyEmployee) => emp.id === managerId)
          managerId = manager?.reportsToId ?? null
        }
      }

      // Get direct report IDs for the current user
      const directReportIds = currentEmployeeId
        ? employees.filter((emp: HierarchyEmployee) => emp.reportsToId === currentEmployeeId).map((emp: HierarchyEmployee) => emp.id)
        : []

      return NextResponse.json({
        items: employees,
        currentEmployeeId,
        managerChainIds,
        directReportIds,
      })
    }

    return NextResponse.json({ error: 'Invalid type parameter' }, { status: 400 })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch hierarchy')
  }
}
</file>

<file path="apps/hrms/app/api/notifications/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'
import { withRateLimit, safeErrorResponse } from '@/lib/api-helpers'
import { getCurrentUser } from '@/lib/current-user'

export async function GET(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { searchParams } = new URL(req.url)
    const unreadOnly = searchParams.get('unreadOnly') === 'true'
    const limit = Math.min(parseInt(searchParams.get('limit') || '50'), 100)

    const user = await getCurrentUser()
    const employeeId = user?.employee?.id

    // Filter: show notifications targeted to this employee OR broadcast (employeeId = null)
    const whereClause = {
      AND: [
        unreadOnly ? { isRead: false } : {},
        {
          OR: [
            { employeeId: employeeId ?? undefined },
            { employeeId: null },
          ],
        },
      ],
    }

    const notifications = await prisma.notification.findMany({
      where: whereClause,
      orderBy: { createdAt: 'desc' },
      take: limit,
    })

    const unreadCount = await prisma.notification.count({
      where: {
        isRead: false,
        OR: [
          { employeeId: employeeId ?? undefined },
          { employeeId: null },
        ],
      },
    })

    return NextResponse.json({ items: notifications, unreadCount })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch notifications')
  }
}

export async function PATCH(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const body = await req.json()
    const { markAllRead, ids } = body

    const user = await getCurrentUser()
    const employeeId = user?.employee?.id

    if (markAllRead) {
      // Only mark as read notifications that belong to this user or are broadcast
      await prisma.notification.updateMany({
        where: {
          isRead: false,
          OR: [
            { employeeId: employeeId ?? undefined },
            { employeeId: null },
          ],
        },
        data: { isRead: true },
      })
      return NextResponse.json({ ok: true })
    }

    if (ids && Array.isArray(ids) && ids.length > 0) {
      // Only update notifications the user has access to
      await prisma.notification.updateMany({
        where: {
          id: { in: ids },
          OR: [
            { employeeId: employeeId ?? undefined },
            { employeeId: null },
          ],
        },
        data: { isRead: true },
      })
      return NextResponse.json({ ok: true })
    }

    return NextResponse.json({ error: 'Invalid request' }, { status: 400 })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to update notifications')
  }
}
</file>

<file path="apps/hrms/app/api/performance-reviews/[id]/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../lib/prisma'
import { UpdatePerformanceReviewSchema } from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'
import { getCurrentEmployeeId } from '@/lib/current-user'
import { canManageEmployee } from '@/lib/permissions'

type RouteContext = { params: Promise<{ id: string }> }

export async function GET(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const item = await prisma.performanceReview.findUnique({
      where: { id },
      include: {
        employee: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            employeeId: true,
            department: true,
            position: true,
            email: true,
          },
        },
      },
    })

    if (!item) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    return NextResponse.json(item)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch performance review')
  }
}

export async function PATCH(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    // Check if current user has permission to manage this employee
    const existing = await prisma.performanceReview.findUnique({
      where: { id },
      select: { employeeId: true },
    })
    if (!existing) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    const currentEmployeeId = await getCurrentEmployeeId()
    if (!currentEmployeeId) {
      return NextResponse.json({ error: 'Unauthorized - not logged in' }, { status: 401 })
    }

    const permissionCheck = await canManageEmployee(currentEmployeeId, existing.employeeId)
    if (!permissionCheck.canManage) {
      return NextResponse.json(
        { error: `Permission denied: ${permissionCheck.reason}` },
        { status: 403 }
      )
    }

    const body = await req.json()

    const validation = validateBody(UpdatePerformanceReviewSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data
    const updates: Record<string, unknown> = {}

    if (data.reviewType !== undefined) updates.reviewType = data.reviewType
    if (data.reviewPeriod !== undefined) updates.reviewPeriod = data.reviewPeriod
    if (data.reviewDate !== undefined) updates.reviewDate = new Date(data.reviewDate)
    if (data.reviewerName !== undefined) updates.reviewerName = data.reviewerName
    if (data.overallRating !== undefined) updates.overallRating = data.overallRating
    if (data.qualityOfWork !== undefined) updates.qualityOfWork = data.qualityOfWork
    if (data.productivity !== undefined) updates.productivity = data.productivity
    if (data.communication !== undefined) updates.communication = data.communication
    if (data.teamwork !== undefined) updates.teamwork = data.teamwork
    if (data.initiative !== undefined) updates.initiative = data.initiative
    if (data.attendance !== undefined) updates.attendance = data.attendance
    if (data.strengths !== undefined) updates.strengths = data.strengths
    if (data.areasToImprove !== undefined) updates.areasToImprove = data.areasToImprove
    if (data.goals !== undefined) updates.goals = data.goals
    if (data.comments !== undefined) updates.comments = data.comments
    if (data.status !== undefined) updates.status = data.status

    const item = await prisma.performanceReview.update({
      where: { id },
      data: updates,
      include: {
        employee: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            employeeId: true,
          },
        },
      },
    })

    return NextResponse.json(item)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to update performance review')
  }
}

export async function DELETE(req: Request, context: RouteContext) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    // Check if current user has permission to manage this employee
    const existing = await prisma.performanceReview.findUnique({
      where: { id },
      select: { employeeId: true },
    })
    if (!existing) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    const currentEmployeeId = await getCurrentEmployeeId()
    if (!currentEmployeeId) {
      return NextResponse.json({ error: 'Unauthorized - not logged in' }, { status: 401 })
    }

    const permissionCheck = await canManageEmployee(currentEmployeeId, existing.employeeId)
    if (!permissionCheck.canManage) {
      return NextResponse.json(
        { error: `Permission denied: ${permissionCheck.reason}` },
        { status: 403 }
      )
    }

    await prisma.performanceReview.delete({ where: { id } })
    return NextResponse.json({ ok: true })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to delete performance review')
  }
}
</file>

<file path="apps/hrms/app/api/performance-reviews/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'
import {
  CreatePerformanceReviewSchema,
  PaginationSchema,
  MAX_PAGINATION_LIMIT,
  ReviewTypeEnum,
  ReviewStatusEnum,
} from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'
import { getCurrentEmployeeId } from '@/lib/current-user'
import { canManageEmployee } from '@/lib/permissions'

export async function GET(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { searchParams } = new URL(req.url)

    const paginationResult = PaginationSchema.safeParse({
      take: searchParams.get('take') || undefined,
      skip: searchParams.get('skip') || undefined,
      q: searchParams.get('q') || undefined,
    })

    const take = paginationResult.success ? paginationResult.data.take : 50
    const skip = paginationResult.success ? paginationResult.data.skip : 0
    const q = paginationResult.success ? paginationResult.data.q?.toLowerCase() : ''

    const where: Record<string, unknown> = {}

    if (q) {
      where.OR = [
        { reviewerName: { contains: q, mode: 'insensitive' } },
        { reviewPeriod: { contains: q, mode: 'insensitive' } },
        { employee: { firstName: { contains: q, mode: 'insensitive' } } },
        { employee: { lastName: { contains: q, mode: 'insensitive' } } },
      ]
    }

    const employeeIdParam = searchParams.get('employeeId')
    if (employeeIdParam) {
      where.employeeId = employeeIdParam
    }

    const reviewTypeParam = searchParams.get('reviewType')
    if (reviewTypeParam) {
      const typeValidation = ReviewTypeEnum.safeParse(reviewTypeParam.toUpperCase())
      if (typeValidation.success) {
        where.reviewType = typeValidation.data
      }
    }

    const statusParam = searchParams.get('status')
    if (statusParam) {
      const statusValidation = ReviewStatusEnum.safeParse(statusParam.toUpperCase())
      if (statusValidation.success) {
        where.status = statusValidation.data
      }
    }

    const [items, total] = await Promise.all([
      prisma.performanceReview.findMany({
        where,
        take: Math.min(take, MAX_PAGINATION_LIMIT),
        skip,
        orderBy: { reviewDate: 'desc' },
        include: {
          employee: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              employeeId: true,
              department: true,
              position: true,
            },
          },
        },
      }),
      prisma.performanceReview.count({ where }),
    ])

    return NextResponse.json({ items, total })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch performance reviews')
  }
}

export async function POST(req: Request) {
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const body = await req.json()

    const validation = validateBody(CreatePerformanceReviewSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data

    // Verify employee exists
    const employee = await prisma.employee.findUnique({
      where: { id: data.employeeId },
    })
    if (!employee) {
      return NextResponse.json({ error: 'Employee not found' }, { status: 404 })
    }

    // Check if current user has permission to manage this employee
    const currentEmployeeId = await getCurrentEmployeeId()
    if (!currentEmployeeId) {
      return NextResponse.json({ error: 'Unauthorized - not logged in' }, { status: 401 })
    }

    const permissionCheck = await canManageEmployee(currentEmployeeId, data.employeeId)
    if (!permissionCheck.canManage) {
      return NextResponse.json(
        { error: `Permission denied: ${permissionCheck.reason}` },
        { status: 403 }
      )
    }

    const item = await prisma.performanceReview.create({
      data: {
        employeeId: data.employeeId,
        reviewType: data.reviewType,
        reviewPeriod: data.reviewPeriod,
        reviewDate: new Date(data.reviewDate),
        reviewerName: data.reviewerName,
        overallRating: data.overallRating,
        qualityOfWork: data.qualityOfWork ?? null,
        productivity: data.productivity ?? null,
        communication: data.communication ?? null,
        teamwork: data.teamwork ?? null,
        initiative: data.initiative ?? null,
        attendance: data.attendance ?? null,
        strengths: data.strengths ?? null,
        areasToImprove: data.areasToImprove ?? null,
        goals: data.goals ?? null,
        comments: data.comments ?? null,
        status: data.status,
      },
      include: {
        employee: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            employeeId: true,
          },
        },
      },
    })

    return NextResponse.json(item, { status: 201 })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to create performance review')
  }
}
</file>

<file path="apps/hrms/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Full height layout */
html, body {
  height: 100%;
}

/* Main scrollable area */
body {
  overflow-x: hidden;
  overflow-y: auto;
}

/* Disable autofill styling on login form */
input:-webkit-autofill,
input:-webkit-autofill:hover,
input:-webkit-autofill:focus,
input:-webkit-autofill:active {
  -webkit-box-shadow: 0 0 0 30px white inset !important;
  -webkit-text-fill-color: inherit !important;
  transition: background-color 5000s ease-in-out 0s;
}

.dark input:-webkit-autofill,
.dark input:-webkit-autofill:hover,
.dark input:-webkit-autofill:focus,
.dark input:-webkit-autofill:active {
  -webkit-box-shadow: 0 0 0 30px rgb(31, 41, 55) inset !important;
  -webkit-text-fill-color: white !important;
}

@layer base {
  :root {
    --background: 210 20% 98%;
    --foreground: 222 47% 11%;
    --card: 0 0% 100%;
    --card-foreground: 222 47% 11%;
    --popover: 0 0% 100%;
    --popover-foreground: 222 47% 11%;
    --primary: 192 93% 37%;
    --primary-foreground: 0 0% 100%;
    --secondary: 210 40% 96%;
    --secondary-foreground: 222 47% 11%;
    --muted: 210 40% 96%;
    --muted-foreground: 215 16% 47%;
    --accent: 177 100% 38%;
    --accent-foreground: 0 0% 100%;
    --destructive: 0 84% 60%;
    --destructive-foreground: 0 0% 98%;
    --border: 214 32% 91%;
    --input: 214 32% 91%;
    --ring: 192 93% 37%;
    --radius: 0.75rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  @apply bg-muted;
}

::-webkit-scrollbar-thumb {
  @apply bg-muted-foreground/30 rounded-md;
}

::-webkit-scrollbar-thumb:hover {
  @apply bg-muted-foreground/50;
}

/* Loading animation */
.loading-spinner {
  @apply inline-block w-4 h-4 border-2 border-current border-t-transparent rounded-full animate-spin;
}

/* Data table styles */
.data-table {
  @apply w-full border-collapse;
}

.data-table th {
  @apply bg-muted font-medium text-left p-2 border-b;
}

.data-table td {
  @apply p-2 border-b;
}

.data-table tr:hover {
  @apply bg-muted/50;
}

/* Form styles */
.form-input {
  @apply w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-primary;
}

.form-label {
  @apply block text-sm font-medium mb-1;
}

.form-error {
  @apply text-sm text-destructive mt-1;
}

/* Card hover effects */
.card-hover {
  @apply transition-all duration-200 hover:shadow-lg hover:-translate-y-1;
}

/* Status badges */
.status-badge {
  @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;
}

.status-badge-success {
  @apply bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200;
}

.status-badge-warning {
  @apply bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200;
}

.status-badge-error {
  @apply bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200;
}

.status-badge-info {
  @apply bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200;
}

/* Print styles */
@media print {
  .no-print {
    display: none !important;
  }

  .print-only {
    display: block !important;
  }

  body {
    @apply bg-white text-black;
  }
}

/* Enhanced UI Styles */
.gradient-bg {
  @apply bg-gradient-to-br from-primary/10 via-accent/5 to-secondary/10;
}

.glass-effect {
  @apply backdrop-blur-sm bg-white/70 border border-white/20 shadow-xl;
}

.primary-gradient {
  @apply bg-gradient-to-r from-primary to-accent text-white;
}

.hover-lift {
  @apply transition-all duration-300 hover:shadow-xl hover:-translate-y-0.5;
}

.sidebar-item {
  @apply transition-all duration-200 hover:bg-primary/10 hover:text-primary hover:pl-8;
}

.dashboard-card {
  @apply bg-white rounded-xl border border-slate-200 shadow-sm transition-all duration-200 hover:shadow-md hover:border-slate-300;
}

/* Soft shadow utilities */
.shadow-soft {
  box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.04), 0 1px 2px -1px rgb(0 0 0 / 0.04);
}

.shadow-soft-lg {
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05), 0 2px 4px -2px rgb(0 0 0 / 0.05);
}

.action-button {
  @apply inline-flex items-center justify-center bg-primary text-white px-4 py-2 rounded-md hover:bg-primary/90 transition-all duration-200 hover:shadow-lg active:scale-95 font-medium text-sm;
}

.secondary-button {
  @apply inline-flex items-center justify-center bg-white text-gray-700 px-4 py-2 rounded-md border border-gray-200 hover:bg-gray-50 transition-all duration-200 hover:shadow-md active:scale-95 font-medium text-sm;
}

.stat-card {
  @apply relative overflow-hidden;
}

.stat-card::before {
  content: '';
  @apply absolute inset-0 bg-gradient-to-br opacity-5;
}

.table-row-hover {
  @apply hover:bg-primary/5 transition-colors duration-150;
}

.badge-primary {
  @apply bg-primary/10 text-primary px-3 py-1 rounded-full text-xs font-medium;
}

.badge-success {
  @apply bg-green-100 text-green-700 px-3 py-1 rounded-full text-xs font-medium;
}

.badge-warning {
  @apply bg-amber-100 text-amber-700 px-3 py-1 rounded-full text-xs font-medium;
}

.badge-info {
  @apply bg-blue-100 text-blue-700 px-3 py-1 rounded-full text-xs font-medium;
}

.badge-secondary {
  @apply bg-gray-100 text-gray-700 px-3 py-1 rounded-full text-xs font-medium;
}

.input-focus {
  @apply focus:ring-2 focus:ring-primary/20 focus:border-primary transition-all duration-200;
}

.nav-active {
  @apply bg-primary/10 text-primary border-l-4 border-primary font-medium;
}

/* Responsive Utilities */
@layer utilities {
  /* Touch-friendly tap targets */
  .touch-target {
    @apply min-h-[44px] min-w-[44px];
  }

  /* Responsive text truncation */
  .truncate-mobile {
    @apply truncate sm:text-clip sm:overflow-visible;
  }

  /* Responsive padding scales */
  .p-responsive {
    @apply p-2 sm:p-3 md:p-4 lg:p-6;
  }

  .px-responsive {
    @apply px-2 sm:px-3 md:px-4 lg:px-6;
  }

  .py-responsive {
    @apply py-2 sm:py-3 md:py-4 lg:py-6;
  }

  /* Responsive font sizes */
  .text-responsive-xs {
    @apply text-xs sm:text-sm;
  }

  .text-responsive-sm {
    @apply text-sm sm:text-base;
  }

  .text-responsive-base {
    @apply text-base sm:text-lg;
  }

  .text-responsive-lg {
    @apply text-lg sm:text-xl md:text-2xl;
  }

  .text-responsive-xl {
    @apply text-xl sm:text-2xl md:text-3xl;
  }

  /* Responsive icon sizes */
  .icon-xs {
    @apply h-3 w-3 sm:h-4 sm:w-4;
  }

  .icon-sm {
    @apply h-4 w-4 sm:h-5 sm:w-5;
  }

  .icon-md {
    @apply h-5 w-5 sm:h-6 sm:w-6;
  }

  .icon-lg {
    @apply h-6 w-6 sm:h-7 sm:w-7 md:h-8 md:w-8;
  }

  /* Hide on mobile, show on larger screens */
  .hide-mobile {
    @apply hidden sm:block;
  }

  .hide-mobile-inline {
    @apply hidden sm:inline;
  }

  .hide-mobile-flex {
    @apply hidden sm:flex;
  }

  /* Show on mobile only */
  .show-mobile {
    @apply block sm:hidden;
  }

  .show-mobile-inline {
    @apply inline sm:hidden;
  }

  .show-mobile-flex {
    @apply flex sm:hidden;
  }

  /* Responsive spacing */
  .gap-responsive {
    @apply gap-2 sm:gap-3 md:gap-4;
  }

  .space-y-responsive > * + * {
    @apply mt-2 sm:mt-3 md:mt-4;
  }

  .space-x-responsive > * + * {
    @apply ml-2 sm:ml-3 md:ml-4;
  }

  /* Responsive grid columns */
  .grid-responsive {
    @apply grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4;
  }

  /* Responsive container widths */
  .container-responsive {
    @apply w-full sm:max-w-sm md:max-w-md lg:max-w-lg xl:max-w-xl;
  }

  /* Responsive border radius */
  .rounded-responsive {
    @apply rounded sm:rounded-md md:rounded-lg;
  }

  /* Responsive shadows */
  .shadow-responsive {
    @apply shadow-sm sm:shadow md:shadow-lg;
  }

  /* Tablet-specific utilities */
  @media (min-width: 768px) and (max-width: 1023px) {
    .tablet\:hidden {
      display: none;
    }

    .tablet\:block {
      display: block;
    }

    .tablet\:flex {
      display: flex;
    }

    .tablet\:grid-cols-2 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }
}
</file>

<file path="apps/hrms/components/ui/NotificationBell.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import { createPortal } from 'react-dom'
import Link from 'next/link'
import { BellIcon, DocumentIcon, XIcon } from './Icons'
import { NotificationsApi, type Notification } from '@/lib/api-client'

function formatTimeAgo(dateStr: string): string {
  const date = new Date(dateStr)
  const now = new Date()
  const diffMs = now.getTime() - date.getTime()
  const diffMins = Math.floor(diffMs / 60000)
  const diffHours = Math.floor(diffMins / 60)
  const diffDays = Math.floor(diffHours / 24)

  if (diffMins < 1) return 'Just now'
  if (diffMins < 60) return `${diffMins}m ago`
  if (diffHours < 24) return `${diffHours}h ago`
  if (diffDays < 7) return `${diffDays}d ago`
  return date.toLocaleDateString()
}

function getNotificationIcon(type: string) {
  switch (type) {
    case 'POLICY_CREATED':
    case 'POLICY_UPDATED':
    case 'POLICY_ARCHIVED':
      return <DocumentIcon className="h-5 w-5 text-cyan-600" />
    default:
      return <BellIcon className="h-5 w-5 text-slate-600" />
  }
}

export function NotificationBell() {
  const [isOpen, setIsOpen] = useState(false)
  const [notifications, setNotifications] = useState<Notification[]>([])
  const [unreadCount, setUnreadCount] = useState(0)
  const [loading, setLoading] = useState(false)
  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0 })
  const buttonRef = useRef<HTMLButtonElement>(null)
  const dropdownRef = useRef<HTMLDivElement>(null)

  const loadNotifications = async () => {
    try {
      setLoading(true)
      const data = await NotificationsApi.list({ limit: 20 })
      setNotifications(data.items)
      setUnreadCount(data.unreadCount)
    } catch (e) {
      console.error('Failed to load notifications', e)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    loadNotifications()
    const interval = setInterval(loadNotifications, 60000)
    return () => clearInterval(interval)
  }, [])

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      const target = event.target as Node
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(target) &&
        buttonRef.current &&
        !buttonRef.current.contains(target)
      ) {
        setIsOpen(false)
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  // Calculate dropdown position when opening
  useEffect(() => {
    if (isOpen && buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect()
      setDropdownPosition({
        top: rect.bottom + 8,
        left: rect.left,
      })
    }
  }, [isOpen])

  const handleMarkAllRead = async () => {
    try {
      await NotificationsApi.markAllAsRead()
      setNotifications((prev) => prev.map((n) => ({ ...n, isRead: true })))
      setUnreadCount(0)
    } catch (e) {
      console.error('Failed to mark all as read', e)
    }
  }

  const handleNotificationClick = async (notification: Notification) => {
    if (!notification.isRead) {
      try {
        await NotificationsApi.markAsRead([notification.id])
        setNotifications((prev) =>
          prev.map((n) => (n.id === notification.id ? { ...n, isRead: true } : n))
        )
        setUnreadCount((prev) => Math.max(0, prev - 1))
      } catch (e) {
        console.error('Failed to mark as read', e)
      }
    }
    setIsOpen(false)
  }

  const dropdown = isOpen && typeof document !== 'undefined' ? createPortal(
    <div
      ref={dropdownRef}
      className="fixed w-80 sm:w-96 bg-white rounded-lg shadow-xl border border-slate-200 z-[9999]"
      style={{ top: dropdownPosition.top, left: dropdownPosition.left }}
    >
      <div className="flex items-center justify-between px-4 py-3 border-b border-slate-200">
        <h3 className="font-semibold text-slate-900">Notifications</h3>
        <div className="flex items-center gap-2">
          {unreadCount > 0 && (
            <button
              onClick={handleMarkAllRead}
              className="text-xs text-cyan-600 hover:text-cyan-700 font-medium"
            >
              Mark all read
            </button>
          )}
          <button
            onClick={() => setIsOpen(false)}
            className="p-1 hover:bg-slate-100 rounded"
          >
            <XIcon className="h-4 w-4 text-slate-400" />
          </button>
        </div>
      </div>

      <div className="max-h-96 overflow-y-auto">
        {loading && notifications.length === 0 ? (
          <div className="p-4 text-center text-slate-500 text-sm">Loading...</div>
        ) : notifications.length === 0 ? (
          <div className="p-8 text-center">
            <BellIcon className="h-8 w-8 text-slate-300 mx-auto mb-2" />
            <p className="text-slate-500 text-sm">No notifications yet</p>
          </div>
        ) : (
          <ul className="divide-y divide-slate-100">
            {notifications.map((notification) => (
              <li key={notification.id}>
                {notification.link ? (
                  <Link
                    href={notification.link}
                    onClick={() => handleNotificationClick(notification)}
                    className={`flex gap-3 px-4 py-3 hover:bg-slate-50 transition-colors ${
                      !notification.isRead ? 'bg-cyan-50/50' : ''
                    }`}
                  >
                    <div className="flex-shrink-0 mt-0.5">
                      {getNotificationIcon(notification.type)}
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className={`text-sm ${!notification.isRead ? 'font-medium text-slate-900' : 'text-slate-700'}`}>
                        {notification.title}
                      </p>
                      <p className="text-sm text-slate-500 mt-0.5 line-clamp-2">
                        {notification.message}
                      </p>
                      <p className="text-xs text-slate-400 mt-1">
                        {formatTimeAgo(notification.createdAt)}
                      </p>
                    </div>
                    {!notification.isRead && (
                      <div className="flex-shrink-0">
                        <span className="h-2 w-2 rounded-full bg-cyan-500 block" />
                      </div>
                    )}
                  </Link>
                ) : (
                  <div
                    className={`flex gap-3 px-4 py-3 ${
                      !notification.isRead ? 'bg-cyan-50/50' : ''
                    }`}
                  >
                    <div className="flex-shrink-0 mt-0.5">
                      {getNotificationIcon(notification.type)}
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className={`text-sm ${!notification.isRead ? 'font-medium text-slate-900' : 'text-slate-700'}`}>
                        {notification.title}
                      </p>
                      <p className="text-sm text-slate-500 mt-0.5 line-clamp-2">
                        {notification.message}
                      </p>
                      <p className="text-xs text-slate-400 mt-1">
                        {formatTimeAgo(notification.createdAt)}
                      </p>
                    </div>
                    {!notification.isRead && (
                      <div className="flex-shrink-0">
                        <span className="h-2 w-2 rounded-full bg-cyan-500 block" />
                      </div>
                    )}
                  </div>
                )}
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>,
    document.body
  ) : null

  return (
    <>
      <button
        ref={buttonRef}
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 text-slate-600 hover:text-slate-900 hover:bg-slate-100 rounded-lg transition-colors"
      >
        <BellIcon className="h-6 w-6" />
        {unreadCount > 0 && (
          <span className="absolute top-1 right-1 flex h-4 w-4 items-center justify-center rounded-full bg-red-500 text-[10px] font-medium text-white">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </button>
      {dropdown}
    </>
  )
}
</file>

<file path="apps/hrms/components/ui/PageHeader.tsx">
'use client'

import { ArrowLeftIcon } from './Icons'
import { useNavigationHistory } from '@/lib/navigation-history'

type PageHeaderProps = {
  title: string
  description?: string
  icon?: React.ReactNode
  actions?: React.ReactNode
  showBack?: boolean
}

export function PageHeader({
  title,
  description,
  icon,
  actions,
  showBack = false,
}: PageHeaderProps) {
  const { goBack, canGoBack } = useNavigationHistory()

  const showBackButton = showBack && canGoBack

  return (
    <header className="mb-8">
      <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
        <div className="flex items-center gap-4">
          {showBackButton && (
            <button
              onClick={goBack}
              className="flex h-10 w-10 items-center justify-center rounded-lg border border-slate-200 bg-white hover:bg-slate-50 transition-colors"
            >
              <ArrowLeftIcon className="h-5 w-5 text-slate-600" />
            </button>
          )}
          {icon && (
            <div className="flex h-12 w-12 items-center justify-center rounded-xl bg-cyan-600 shadow-md">
              {icon}
            </div>
          )}
          <div>
            {description && (
              <p className="text-xs font-semibold uppercase tracking-wider text-cyan-600 mb-0.5">
                {description}
              </p>
            )}
            <h1 className="text-2xl font-semibold text-slate-900">{title}</h1>
          </div>
        </div>
        {actions && <div className="flex items-center gap-3">{actions}</div>}
      </div>
    </header>
  )
}

// Simpler header variant for list pages
type ListPageHeaderProps = {
  title: string
  description?: string
  icon?: React.ReactNode
  action?: React.ReactNode
}

export function ListPageHeader({
  title,
  description,
  icon,
  action,
}: ListPageHeaderProps) {
  return (
    <header className="mb-8">
      <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
        <div className="flex items-center gap-3">
          {icon && (
            <div className="p-2.5 rounded-xl bg-cyan-600 shadow-md">
              {icon}
            </div>
          )}
          <div>
            <h1 className="text-2xl font-semibold text-slate-900">{title}</h1>
            {description && (
              <p className="text-sm text-slate-500 mt-0.5">{description}</p>
            )}
          </div>
        </div>
        {action && <div>{action}</div>}
      </div>
    </header>
  )
}
</file>

<file path="apps/hrms/lib/hrms-prisma-types.ts">
import type { Prisma as PrismaNamespace } from '@ecom-os/prisma-hrms'

// Re-export all Prisma types from the generated package
export {
  PrismaClient,
  Prisma,
  EmploymentType,
  EmployeeStatus,
  ResourceCategory,
  PolicyCategory,
  PolicyStatus,
  Region,
  ReviewType,
  ReviewStatus,
  ViolationType,
  ViolationReason,
  ViolationSeverity,
  DisciplinaryActionType,
  DisciplinaryStatus,
  HREventType,
  NotificationType,
} from '@ecom-os/prisma-hrms'

// Transaction client type for $transaction callbacks
export type TransactionClient = PrismaNamespace.TransactionClient
</file>

<file path="apps/hrms/lib/navigation-history.tsx">
'use client'

import { createContext, useContext, useEffect, useRef, ReactNode } from 'react'
import { usePathname } from 'next/navigation'

type NavigationHistoryContextType = {
  goBack: () => void
  canGoBack: boolean
  previousPath: string | null
}

const NavigationHistoryContext = createContext<NavigationHistoryContextType>({
  goBack: () => {},
  canGoBack: false,
  previousPath: null,
})

export function NavigationHistoryProvider({ children }: { children: ReactNode }) {
  const pathname = usePathname()
  const historyRef = useRef<string[]>([])
  const isInitialMount = useRef(true)

  useEffect(() => {
    // Skip the initial mount
    if (isInitialMount.current) {
      isInitialMount.current = false
      historyRef.current = [pathname]
      return
    }

    // Don't add duplicate consecutive paths
    const lastPath = historyRef.current[historyRef.current.length - 1]
    if (lastPath !== pathname) {
      historyRef.current.push(pathname)
      // Keep history limited to prevent memory issues
      if (historyRef.current.length > 50) {
        historyRef.current = historyRef.current.slice(-50)
      }
    }
  }, [pathname])

  const goBack = () => {
    if (historyRef.current.length > 1) {
      // Remove current path
      historyRef.current.pop()
      // Get previous path
      const previousPath = historyRef.current[historyRef.current.length - 1]
      if (previousPath) {
        // Add basePath if configured
        const basePath = process.env.NEXT_PUBLIC_BASE_PATH || ''
        window.location.href = `${basePath}${previousPath}`
      }
    } else {
      // Fallback to browser history
      window.history.back()
    }
  }

  const canGoBack = historyRef.current.length > 1
  const previousPath = historyRef.current.length > 1
    ? historyRef.current[historyRef.current.length - 2]
    : null

  return (
    <NavigationHistoryContext.Provider value={{ goBack, canGoBack, previousPath }}>
      {children}
    </NavigationHistoryContext.Provider>
  )
}

export function useNavigationHistory() {
  return useContext(NavigationHistoryContext)
}
</file>

<file path="apps/hrms/lib/prisma.ts">
import { PrismaClient } from '@ecom-os/prisma-hrms'

const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient }

const client: PrismaClient =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  })

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = client
}

export const prisma = client
export type { PrismaClient } from '@ecom-os/prisma-hrms'

export default prisma
</file>

<file path="apps/hrms/prisma/seed.ts">
/* eslint-disable no-console */
import { PrismaClient, EmploymentType, EmployeeStatus } from '@ecom-os/prisma-hrms'
import fs from 'node:fs'
import path from 'node:path'

const prisma = new PrismaClient()

type EmployeeInput = {
  employeeId: string
  firstName: string
  lastName: string
  email: string
  phone?: string | null
  department: string
  position: string
  employmentType?: string
  joinDate: string
  status?: string
}

type ResourceInput = {
  name: string
  category: string
  subcategory?: string | null
  description?: string | null
  email?: string | null
  phone?: string | null
  website?: string | null
  rating?: number | null
}

type PolicyInput = {
  title: string
  category: string
  summary?: string | null
  content?: string | null
  fileUrl?: string | null
  version?: string | null
  effectiveDate?: string | null
  status?: string
}

function readJSON<T>(rel: string): T | null {
  const p = path.join(process.cwd(), rel)
  if (!fs.existsSync(p)) return null
  const raw = fs.readFileSync(p, 'utf8')
  try {
    return JSON.parse(raw) as T
  } catch (e) {
    console.warn(`Could not parse ${rel}:`, e)
    return null
  }
}

async function seedEmployees() {
  const list = readJSON<EmployeeInput[]>('prisma/seed/employees.json')
    || readJSON<EmployeeInput[]>('prisma/seed/employees.sample.json')
  if (!list?.length) {
    console.log('No employees to seed')
    return
  }
  let ok = 0
  for (const e of list) {
    try {
      const data = {
        employeeId: String(e.employeeId),
        firstName: String(e.firstName),
        lastName: String(e.lastName),
        email: String(e.email),
        phone: e.phone ?? null,
        department: String((e as any).department || (e as any).departmentName || 'General'),
        position: String(e.position),
        employmentType: String(e.employmentType || 'FULL_TIME').toUpperCase() as EmploymentType,
        joinDate: new Date(e.joinDate),
        status: String(e.status || 'ACTIVE').toUpperCase() as EmployeeStatus,
      }
      // Upsert by unique email (or employeeId fallback)
      await prisma.employee.upsert({
        where: { email: data.email },
        update: data,
        create: {
          ...data,
          dept: { connectOrCreate: { where: { name: data.department }, create: { name: data.department } } }
        },
      })
      ok++
    } catch (err) {
      // Fallback: try upsert by employeeId unique
      try {
        await prisma.employee.upsert({
          where: { employeeId: String(e.employeeId) },
          update: {
            firstName: String(e.firstName),
            lastName: String(e.lastName),
            email: String(e.email),
            phone: e.phone ?? null,
            department: String((e as any).department || (e as any).departmentName || 'General'),
            position: String(e.position),
            employmentType: String(e.employmentType || 'FULL_TIME').toUpperCase() as EmploymentType,
            joinDate: new Date(e.joinDate),
            status: String(e.status || 'ACTIVE').toUpperCase() as EmployeeStatus,
          },
          create: {
            employeeId: String(e.employeeId),
            firstName: String(e.firstName),
            lastName: String(e.lastName),
            email: String(e.email),
            phone: e.phone ?? null,
            department: String((e as any).department || (e as any).departmentName || 'General'),
            position: String(e.position),
            employmentType: String(e.employmentType || 'FULL_TIME').toUpperCase() as EmploymentType,
            joinDate: new Date(e.joinDate),
            status: String(e.status || 'ACTIVE').toUpperCase() as EmployeeStatus,
            dept: { connectOrCreate: { where: { name: String((e as any).department || (e as any).departmentName || 'General') }, create: { name: String((e as any).department || (e as any).departmentName || 'General') } } }
          }
        })
        ok++
      } catch (e2) {
        console.warn('Employee seed skipped:', e, e2)
      }
    }
  }
  console.log(`Seeded employees: ${ok}`)
}

async function seedResources() {
  const list = readJSON<ResourceInput[]>('prisma/seed/resources.json')
    || readJSON<ResourceInput[]>('prisma/seed/resources.sample.json')
  if (!list?.length) {
    console.log('No resources to seed')
    return
  }
  let ok = 0
  for (const r of list) {
    try {
      if (r.website) {
        const existing = await prisma.resource.findFirst({ where: { website: r.website } })
        if (existing) {
          await prisma.resource.update({ where: { id: existing.id }, data: {
            name: r.name,
            category: String(r.category).toUpperCase() as any,
            subcategory: r.subcategory ?? null,
            email: r.email ?? null,
            phone: r.phone ?? null,
            website: r.website ?? null,
            description: r.description ?? null,
            rating: r.rating ?? null,
          } })
          ok++
          continue
        }
      }
      await prisma.resource.create({ data: {
        name: r.name,
        category: String(r.category).toUpperCase() as any,
        subcategory: r.subcategory ?? null,
        email: r.email ?? null,
        phone: r.phone ?? null,
        website: r.website ?? null,
        description: r.description ?? null,
        rating: r.rating ?? null,
      } })
      ok++
    } catch (e) {
      console.warn('Resource seed skipped:', r.name, e)
    }
  }
  console.log(`Seeded resources: ${ok}`)
}

async function seedPolicies() {
  const list = readJSON<PolicyInput[]>('prisma/seed/policies.json')
    || readJSON<PolicyInput[]>('prisma/seed/policies.sample.json')
  if (!list?.length) {
    console.log('No policies to seed')
    return
  }
  let ok = 0
  for (const p of list) {
    try {
      const existing = await prisma.policy.findFirst({ where: { title: p.title } })
      if (existing) {
        await prisma.policy.update({ where: { id: existing.id }, data: {
          title: p.title,
          category: String(p.category).toUpperCase() as any,
          summary: p.summary ?? null,
          content: p.content ?? null,
          fileUrl: p.fileUrl ?? null,
          version: p.version ?? '1.0',
          effectiveDate: p.effectiveDate ? new Date(p.effectiveDate) : null,
          status: String(p.status || 'ACTIVE').toUpperCase() as any,
        } })
        ok++
        continue
      }
      await prisma.policy.create({ data: {
        title: p.title,
        category: String(p.category).toUpperCase() as any,
        summary: p.summary ?? null,
        content: p.content ?? null,
        fileUrl: p.fileUrl ?? null,
        version: p.version ?? '1.0',
        effectiveDate: p.effectiveDate ? new Date(p.effectiveDate) : null,
        status: String(p.status || 'ACTIVE').toUpperCase() as any,
      } })
      ok++
    } catch (e) {
      console.warn('Policy seed skipped:', p.title, e)
    }
  }
  console.log(`Seeded policies: ${ok}`)
}

async function main() {
  await seedEmployees()
  await seedResources()
  await seedPolicies()
}

main()
  .catch((e) => {
    console.error(e)
    process.exit(1)
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
</file>

<file path="apps/hrms/CLAUDE.md">
# HRMS App - Claude Instructions

## Port Configuration

Use the correct port based on your branch/environment:

| Branch/Environment | Port | Command |
|-------------------|------|---------|
| main | 3006 | `PORT=3006 pnpm -F @ecom-os/hrms dev` |
| dev | 3106 | `PORT=3106 pnpm -F @ecom-os/hrms dev` |
| worktree | 3206 | `PORT=3206 pnpm -F @ecom-os/hrms dev` |

If you are in a git worktree, always use port 3206 to avoid conflicts with dev (3106) or main (3006).

## Scope

You are only allowed to work on the `apps/hrms` folder. Do not modify files outside this directory.

## Code Style

- no OR statements as fallbacks - let the code fail
- Use TypeScript strict mode
- Follow existing patterns in the codebase
</file>

<file path="apps/hrms/package.json">
{
  "name": "@ecom-os/hrms",
  "version": "1.1.0",
  "private": true,
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "scripts": {
    "dev": "node ../../scripts/run-dev-with-logs.js hrms -- next dev -p 3006",
    "build": "next build",
    "start": "next start -p 3006",
    "type-check": "DATABASE_URL=${DATABASE_URL:-postgresql://localhost:5432/hrms} prisma generate --schema prisma/schema.prisma && tsc --noEmit --skipLibCheck",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:migrate:dev": "prisma migrate dev",
    "db:migrate:deploy": "prisma migrate deploy",
    "db:reset": "prisma migrate reset --force",
    "db:studio": "prisma studio",
    "db:seed": "prisma generate && prisma db seed"
  },
  "dependencies": {
    "@ecom-os/auth": "workspace:*",
    "@ecom-os/prisma-hrms": "workspace:*",
    "clsx": "^2.1.1",
    "googleapis": "^168.0.0",
    "next": "16.0.8",
    "next-auth": "5.0.0-beta.30",
    "react": "19.2.1",
    "react-dom": "19.2.1",
    "react-markdown": "^10.1.0",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.4.0",
    "zod": "^3.24.4"
  },
  "devDependencies": {
    "@prisma/client": "6.19.0",
    "@tailwindcss/typography": "^0.5.19",
    "@types/node": "^24.3.0",
    "@types/react": "19.1.10",
    "@types/react-dom": "19.1.6",
    "autoprefixer": "^10.4.22",
    "postcss": "^8.5.6",
    "prisma": "6.19.0",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "tsx": "^4.21.0",
    "typescript": "5.9.3"
  }
}
</file>

<file path="apps/hrms/README.md">
# HRMS App

Human Resources Management System built with Next.js 16, Prisma, and PostgreSQL.

## Features

- Employee directory and profiles
- Organization chart (by person or department)
- Performance reviews and disciplinary tracking
- Company policies and resources
- HR calendar with Google Calendar integration
- Google Workspace Admin sync (auto-import employees)
- Notification system

## Requirements

- Node.js 20+
- pnpm 9+
- PostgreSQL 16+

## Local Development

### Database Setup

```bash
# macOS
brew install postgresql@16
brew services start postgresql@16
psql -U postgres -c "CREATE DATABASE hrms;"

# Ubuntu/Debian
sudo apt-get install -y postgresql postgresql-contrib
sudo systemctl enable --now postgresql
sudo -u postgres psql -c "CREATE DATABASE hrms;"
```

### Environment

Copy `.env.dev.ci` to `.env.local` and update values:

```bash
cp .env.dev.ci .env.local
```

Key variables:
- `DATABASE_URL` - PostgreSQL connection string
- `NEXTAUTH_SECRET` - Auth secret (must match portal)
- `PORTAL_AUTH_URL` - Portal auth endpoint
- `PORTAL_AUTH_SECRET` - Shared auth secret

### Prisma

HRMS uses `@ecom-os/prisma-hrms` workspace package for the Prisma client.

```bash
# Generate client
pnpm -F @ecom-os/hrms db:generate

# Run migrations
pnpm -F @ecom-os/hrms db:migrate:dev

# Open Prisma Studio
pnpm -F @ecom-os/hrms db:studio
```

### Run

```bash
pnpm -F @ecom-os/hrms dev
```

Default port: 3006 (main), 3106 (dev branch)

## Seeding Data

Place JSON files in `prisma/seed/`:
- `employees.json`
- `resources.json`
- `policies.json`

See `*.sample.json` files for schema.

```bash
pnpm -F @ecom-os/hrms db:seed
```

## Google Workspace Integration

### Google Admin Sync

Syncs employees from Google Workspace directory. Runs automatically on startup and every 30 minutes.

Required env vars:
- `GOOGLE_CLIENT_ID`
- `GOOGLE_CLIENT_SECRET`
- `GOOGLE_ADMIN_REFRESH_TOKEN` - OAuth token with Admin SDK scope
- `GOOGLE_ADMIN_DOMAIN` - Workspace domain (default: targonglobal.com)

Manual sync: `POST /api/google-admin/sync`

### Google Calendar

For calendar integration:
- `GOOGLE_CALENDAR_ID`
- `GOOGLE_REFRESH_TOKEN` - OAuth token with Calendar scope
- `NEXT_PUBLIC_GOOGLE_CALENDAR_EMBED_URL` - Public calendar embed URL

## Production Deployment

```bash
pnpm -F @ecom-os/hrms db:generate
pnpm -F @ecom-os/hrms db:migrate:deploy
pnpm -F @ecom-os/hrms build
pnpm -F @ecom-os/hrms start
```

Provide `DATABASE_URL` and auth secrets via environment variables.
</file>

<file path="packages/prisma-hrms/package.json">
{
  "name": "@ecom-os/prisma-hrms",
  "version": "0.0.0",
  "private": true,
  "sideEffects": false,
  "main": "generated/index.js",
  "types": "generated/index.d.ts",
  "exports": {
    ".": {
      "types": "./generated/index.d.ts",
      "default": "./generated/index.js"
    }
  }
}
</file>

<file path="apps/hrms/app/(hrms)/policies/add/page.tsx">
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { PoliciesApi } from '@/lib/api-client'
import { DocumentIcon } from '@/components/ui/Icons'
import { PageHeader } from '@/components/ui/PageHeader'
import { Card, CardDivider } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import {
  FormField,
  SelectField,
  TextareaField,
  FormSection,
  FormActions,
} from '@/components/ui/FormField'
import { useNavigationHistory } from '@/lib/navigation-history'

const categoryOptions = [
  { value: 'LEAVE', label: 'Leave' },
  { value: 'PERFORMANCE', label: 'Performance' },
  { value: 'CONDUCT', label: 'Conduct' },
  { value: 'SECURITY', label: 'Security' },
  { value: 'COMPENSATION', label: 'Compensation' },
  { value: 'OTHER', label: 'Other' },
]

const regionOptions = [
  { value: 'ALL', label: 'All Regions' },
  { value: 'KANSAS_US', label: 'US (Kansas)' },
  { value: 'PAKISTAN', label: 'Pakistan' },
]

const statusOptions = [
  { value: 'DRAFT', label: 'Draft' },
  { value: 'ACTIVE', label: 'Active' },
  { value: 'ARCHIVED', label: 'Archived' },
]

export default function AddPolicyPage() {
  const router = useRouter()
  const { goBack } = useNavigationHistory()
  const [submitting, setSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)

  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault()
    setSubmitting(true)
    setError(null)
    const fd = new FormData(e.currentTarget)
    const payload = Object.fromEntries(fd.entries()) as any

    try {
      await PoliciesApi.create({
        title: String(payload.title),
        category: String(payload.category),
        region: String(payload.region),
        status: String(payload.status || 'DRAFT'),
        version: payload.version ? String(payload.version) : undefined,
        effectiveDate: payload.effectiveDate ? String(payload.effectiveDate) : undefined,
        summary: payload.summary ? String(payload.summary) : undefined,
        content: payload.content ? String(payload.content) : undefined,
      })
      router.push('/policies')
    } catch (e: any) {
      setError(e.message || 'Failed to create policy')
    } finally {
      setSubmitting(false)
    }
  }

  return (
    <>
      <PageHeader
        title="Add Policy"
        description="Company Policies"
        icon={<DocumentIcon className="h-6 w-6 text-white" />}
        showBack
      />

      <div className="max-w-3xl">
        <Card padding="lg">
          {error && (
            <Alert variant="error" className="mb-6" onDismiss={() => setError(null)}>
              {error}
            </Alert>
          )}

          <form onSubmit={onSubmit} className="space-y-8">
            {/* Basic Info */}
            <FormSection title="Policy Information" description="Enter the basic details for this policy">
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
                <div className="sm:col-span-2">
                  <FormField
                    label="Policy Title"
                    name="title"
                    required
                    placeholder="e.g., Annual Leave Policy"
                  />
                </div>
                <SelectField
                  label="Category"
                  name="category"
                  required
                  options={categoryOptions}
                  placeholder="Select category..."
                />
                <SelectField
                  label="Region"
                  name="region"
                  required
                  options={regionOptions}
                  placeholder="Select region..."
                />
                <SelectField
                  label="Status"
                  name="status"
                  required
                  options={statusOptions}
                  defaultValue="DRAFT"
                />
                <FormField
                  label="Version"
                  name="version"
                  defaultValue="1.0"
                  placeholder="e.g., 1.0"
                />
                <FormField
                  label="Effective Date"
                  name="effectiveDate"
                  type="date"
                />
              </div>
            </FormSection>

            <CardDivider />

            {/* Summary */}
            <FormSection title="Summary" description="Brief overview of the policy (1-2 sentences)">
              <TextareaField
                label="Summary"
                name="summary"
                rows={3}
                placeholder="A brief summary of what this policy covers..."
                resizable={false}
              />
            </FormSection>

            <CardDivider />

            {/* Content */}
            <FormSection title="Policy Content" description="Full policy text. You can use markdown formatting.">
              <TextareaField
                label="Content"
                name="content"
                rows={16}
                monospace
                placeholder={`# Policy Title

## Purpose
Describe the purpose of this policy...

## Scope
Who this policy applies to...

## Policy Statement
The main policy content...

## Procedures
Step-by-step procedures...

## Compliance
Consequences of non-compliance...`}
              />
            </FormSection>

            {/* Actions */}
            <FormActions>
              <Button variant="secondary" onClick={goBack}>
                Cancel
              </Button>
              <Button type="submit" loading={submitting}>
                {submitting ? 'Saving...' : 'Save Policy'}
              </Button>
            </FormActions>
          </form>
        </Card>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/api/policies/[id]/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../lib/prisma'
import { UpdatePolicySchema, bumpVersion } from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'

type PolicyRouteContext = { params: Promise<{ id: string }> }

export async function GET(req: Request, context: PolicyRouteContext) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const p = await prisma.policy.findUnique({ where: { id } })

    if (!p) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    return NextResponse.json(p)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch policy')
  }
}

export async function PATCH(req: Request, context: PolicyRouteContext) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const body = await req.json()

    // Validate input with whitelist schema
    const validation = validateBody(UpdatePolicySchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data

    // Build update object with explicit field whitelist
    const updates: Record<string, unknown> = {}

    if (data.title !== undefined) updates.title = data.title
    if (data.category !== undefined) updates.category = data.category
    if (data.region !== undefined) updates.region = data.region
    if (data.summary !== undefined) updates.summary = data.summary
    if (data.content !== undefined) updates.content = data.content
    if (data.fileUrl !== undefined) updates.fileUrl = data.fileUrl

    // Handle version: explicit version takes precedence, then bumpVersion
    if (data.version !== undefined) {
      updates.version = data.version
    } else if (data.bumpVersion) {
      const existing = await prisma.policy.findUnique({ where: { id }, select: { version: true } })
      updates.version = bumpVersion(existing?.version || '1.0', data.bumpVersion)
    }

    if (data.effectiveDate !== undefined) {
      if (data.effectiveDate) {
        const newDate = new Date(data.effectiveDate)
        // Check if another policy has this effective date
        const existing = await prisma.policy.findFirst({
          where: {
            effectiveDate: newDate,
            id: { not: id },
          },
        })
        if (existing) {
          return NextResponse.json(
            { error: `Another policy already has effective date ${data.effectiveDate}` },
            { status: 400 }
          )
        }
        updates.effectiveDate = newDate
      } else {
        updates.effectiveDate = null
      }
    }
    if (data.status !== undefined) updates.status = data.status

    const p = await prisma.policy.update({
      where: { id },
      data: updates,
    })

    // Create company-wide notification for policy update
    await prisma.notification.create({
      data: {
        type: 'POLICY_UPDATED',
        title: 'Policy Updated',
        message: `"${p.title}" has been updated to version ${p.version}. Please review the changes.`,
        link: `/policies/${p.id}`,
        relatedId: p.id,
        relatedType: 'POLICY',
      },
    })

    return NextResponse.json(p)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to update policy')
  }
}

export async function DELETE(req: Request, context: PolicyRouteContext) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    await prisma.policy.delete({ where: { id } })
    return NextResponse.json({ ok: true })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to delete policy')
  }
}
</file>

<file path="apps/hrms/app/api/policies/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../lib/prisma'
import {
  CreatePolicySchema,
  PaginationSchema,
  MAX_PAGINATION_LIMIT,
  PolicyCategoryEnum,
  PolicyStatusEnum,
  RegionEnum,
} from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'

export async function GET(req: Request) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { searchParams } = new URL(req.url)

    // Validate pagination params
    const paginationResult = PaginationSchema.safeParse({
      take: searchParams.get('take') || undefined,
      skip: searchParams.get('skip') || undefined,
      q: searchParams.get('q') || undefined,
    })

    const take = paginationResult.success ? paginationResult.data.take : 50
    const skip = paginationResult.success ? paginationResult.data.skip : 0
    const q = paginationResult.success ? paginationResult.data.q?.toLowerCase() : ''

    const where: Record<string, unknown> = {}

    if (q) {
      where.OR = [
        { title: { contains: q, mode: 'insensitive' } },
        { summary: { contains: q, mode: 'insensitive' } },
      ]
    }

    // Validate category enum
    const categoryParam = searchParams.get('category')
    if (categoryParam) {
      const categoryValidation = PolicyCategoryEnum.safeParse(categoryParam.toUpperCase())
      if (categoryValidation.success) {
        where.category = categoryValidation.data
      }
    }

    // Validate status enum
    const statusParam = searchParams.get('status')
    if (statusParam) {
      const statusValidation = PolicyStatusEnum.safeParse(statusParam.toUpperCase())
      if (statusValidation.success) {
        where.status = statusValidation.data
      }
    }

    // Validate region enum
    const regionParam = searchParams.get('region')
    if (regionParam) {
      const regionValidation = RegionEnum.safeParse(regionParam.toUpperCase())
      if (regionValidation.success) {
        where.region = regionValidation.data
      }
    }

    const [items, total] = await Promise.all([
      prisma.policy.findMany({
        where,
        take: Math.min(take, MAX_PAGINATION_LIMIT),
        skip,
        orderBy: { title: 'asc' },
      }),
      prisma.policy.count({ where }),
    ])

    return NextResponse.json({ items, total })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch policies')
  }
}

export async function POST(req: Request) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const body = await req.json()

    // Validate input
    const validation = validateBody(CreatePolicySchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data

    // Check for duplicate effective date
    if (data.effectiveDate) {
      const existingWithDate = await prisma.policy.findFirst({
        where: { effectiveDate: new Date(data.effectiveDate) },
      })
      if (existingWithDate) {
        return NextResponse.json(
          { error: `Another policy already has effective date ${data.effectiveDate}` },
          { status: 400 }
        )
      }
    }

    const item = await prisma.policy.create({
      data: {
        title: data.title,
        category: data.category,
        region: data.region,
        summary: data.summary ?? null,
        content: data.content ?? null,
        fileUrl: data.fileUrl ?? null,
        version: data.version,
        effectiveDate: data.effectiveDate ? new Date(data.effectiveDate) : null,
        status: data.status,
      },
    })

    return NextResponse.json(item, { status: 201 })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to create policy')
  }
}
</file>

<file path="apps/hrms/components/ui/Icons.tsx">
// Centralized icon components for HRMS
// All icons use consistent sizing and stroke width

type IconProps = {
  className?: string
}

export function HomeIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25" />
    </svg>
  )
}

export function UsersIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M15 19.128a9.38 9.38 0 002.625.372 9.337 9.337 0 004.121-.952 4.125 4.125 0 00-7.533-2.493M15 19.128v-.003c0-1.113-.285-2.16-.786-3.07M15 19.128v.106A12.318 12.318 0 018.624 21c-2.331 0-4.512-.645-6.374-1.766l-.001-.109a6.375 6.375 0 0111.964-3.07M12 6.375a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0zm8.25 2.25a2.625 2.625 0 11-5.25 0 2.625 2.625 0 015.25 0z" />
    </svg>
  )
}

export function FolderIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
    </svg>
  )
}

export function DocumentIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
    </svg>
  )
}

export function CalendarIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0v-7.5A2.25 2.25 0 015.25 9h13.5A2.25 2.25 0 0121 11.25v7.5" />
    </svg>
  )
}

export function CalendarDaysIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0v-7.5A2.25 2.25 0 015.25 9h13.5A2.25 2.25 0 0121 11.25v7.5m-9-6h.008v.008H12v-.008zM12 15h.008v.008H12V15zm0 2.25h.008v.008H12v-.008zM9.75 15h.008v.008H9.75V15zm0 2.25h.008v.008H9.75v-.008zM7.5 15h.008v.008H7.5V15zm0 2.25h.008v.008H7.5v-.008zm6.75-4.5h.008v.008h-.008v-.008zm0 2.25h.008v.008h-.008V15zm0 2.25h.008v.008h-.008v-.008zm2.25-4.5h.008v.008H16.5v-.008zm0 2.25h.008v.008H16.5V15z" />
    </svg>
  )
}

export function MenuIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
    </svg>
  )
}

export function XIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
    </svg>
  )
}

export function PlusIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
    </svg>
  )
}

export function MinusIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 12h-15" />
    </svg>
  )
}

export function SearchIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" />
    </svg>
  )
}

export function ArrowLeftIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
    </svg>
  )
}

export function PencilIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" />
    </svg>
  )
}

export function TrashIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
    </svg>
  )
}

export function ChevronRightIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
    </svg>
  )
}

export function BuildingIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 21h16.5M4.5 3h15M5.25 3v18m13.5-18v18M9 6.75h1.5m-1.5 3h1.5m-1.5 3h1.5m3-6H15m-1.5 3H15m-1.5 3H15M9 21v-3.375c0-.621.504-1.125 1.125-1.125h3.75c.621 0 1.125.504 1.125 1.125V21" />
    </svg>
  )
}

export function ClockIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
  )
}

export function CheckCircleIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
  )
}

export function ExclamationCircleIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" />
    </svg>
  )
}

export function EnvelopeIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M21.75 6.75v10.5a2.25 2.25 0 01-2.25 2.25h-15a2.25 2.25 0 01-2.25-2.25V6.75m19.5 0A2.25 2.25 0 0019.5 4.5h-15a2.25 2.25 0 00-2.25 2.25m19.5 0v.243a2.25 2.25 0 01-1.07 1.916l-7.5 4.615a2.25 2.25 0 01-2.36 0L3.32 8.91a2.25 2.25 0 01-1.07-1.916V6.75" />
    </svg>
  )
}

export function PhoneIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 6.75c0 8.284 6.716 15 15 15h2.25a2.25 2.25 0 002.25-2.25v-1.372c0-.516-.351-.966-.852-1.091l-4.423-1.106c-.44-.11-.902.055-1.173.417l-.97 1.293c-.282.376-.769.542-1.21.38a12.035 12.035 0 01-7.143-7.143c-.162-.441.004-.928.38-1.21l1.293-.97c.363-.271.527-.734.417-1.173L6.963 3.102a1.125 1.125 0 00-1.091-.852H4.5A2.25 2.25 0 002.25 4.5v2.25z" />
    </svg>
  )
}

export function MapPinIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M15 10.5a3 3 0 11-6 0 3 3 0 016 0z" />
      <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z" />
    </svg>
  )
}

export function ChartBarIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z" />
    </svg>
  )
}

export function EllipsisVerticalIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M12 6.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 12.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 18.75a.75.75 0 110-1.5.75.75 0 010 1.5z" />
    </svg>
  )
}

export function SpinnerIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24">
      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
    </svg>
  )
}

export function ExternalLinkIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25" />
    </svg>
  )
}

export function ClipboardDocumentCheckIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0118 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3l1.5 1.5 3-3.75" />
    </svg>
  )
}

export function ShieldExclamationIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v3.75m0-10.036A11.959 11.959 0 013.598 6 11.99 11.99 0 003 9.75c0 5.592 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.57-.598-3.75h-.152c-3.196 0-6.1-1.249-8.25-3.286zm0 13.036h.008v.008H12v-.008z" />
    </svg>
  )
}

export function StarIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M11.48 3.499a.562.562 0 011.04 0l2.125 5.111a.563.563 0 00.475.345l5.518.442c.499.04.701.663.321.988l-4.204 3.602a.563.563 0 00-.182.557l1.285 5.385a.562.562 0 01-.84.61l-4.725-2.885a.563.563 0 00-.586 0L6.982 20.54a.562.562 0 01-.84-.61l1.285-5.386a.562.562 0 00-.182-.557l-4.204-3.602a.563.563 0 01.321-.988l5.518-.442a.563.563 0 00.475-.345L11.48 3.5z" />
    </svg>
  )
}

export function StarFilledIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="currentColor" viewBox="0 0 24 24">
      <path fillRule="evenodd" d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.006z" clipRule="evenodd" />
    </svg>
  )
}

export function BellIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M14.857 17.082a23.848 23.848 0 005.454-1.31A8.967 8.967 0 0118 9.75v-.7V9A6 6 0 006 9v.75a8.967 8.967 0 01-2.312 6.022c1.733.64 3.56 1.085 5.455 1.31m5.714 0a24.255 24.255 0 01-5.714 0m5.714 0a3 3 0 11-5.714 0" />
    </svg>
  )
}

export function UserIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z" />
    </svg>
  )
}

export function ClipboardIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184" />
    </svg>
  )
}

export function CheckIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 12.75l6 6 9-13.5" />
    </svg>
  )
}

export function OrgChartIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6A2.25 2.25 0 016 3.75h2.25A2.25 2.25 0 0110.5 6v2.25a2.25 2.25 0 01-2.25 2.25H6a2.25 2.25 0 01-2.25-2.25V6zM3.75 15.75A2.25 2.25 0 016 13.5h2.25a2.25 2.25 0 012.25 2.25V18a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 18v-2.25zM13.5 6a2.25 2.25 0 012.25-2.25H18A2.25 2.25 0 0120.25 6v2.25A2.25 2.25 0 0118 10.5h-2.25a2.25 2.25 0 01-2.25-2.25V6zM13.5 15.75a2.25 2.25 0 012.25-2.25H18a2.25 2.25 0 012.25 2.25V18A2.25 2.25 0 0118 20.25h-2.25A2.25 2.25 0 0113.5 18v-2.25z" />
    </svg>
  )
}

export function ChevronDownIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
    </svg>
  )
}

export function ChevronUpIcon({ className }: IconProps) {
  return (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth={1.5}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
    </svg>
  )
}
</file>

<file path="apps/hrms/prisma/seed-departments.ts">
/**
 * Seed script to set up department hierarchy with heads and KPIs
 * Based on Targon LLC organizational structure
 *
 * Run with: npx tsx prisma/seed-departments.ts
 */

import { PrismaClient } from '@ecom-os/prisma-hrms'

const prisma = new PrismaClient()

async function main() {
  console.log('Starting department seed...')

  // First, get all employees to find heads
  const employees = await prisma.employee.findMany({
    select: { id: true, firstName: true, lastName: true, email: true },
  })

  const findEmployee = (firstName: string) => {
    const emp = employees.find(e =>
      e.firstName.toLowerCase() === firstName.toLowerCase()
    )
    if (!emp) {
      console.warn(`Warning: Employee "${firstName}" not found`)
    }
    return emp
  }

  // Find key people
  const jarrar = findEmployee('Jarrar')
  const mehdi = findEmployee('Mehdi')
  const hamad = findEmployee('Hamad')
  const zeeshan = findEmployee('Zeeshan')
  const umair = findEmployee('Umair')

  // Upsert departments with hierarchy
  // Note: Department names must match what's in Employee.department field

  // Root level - Company
  const company = await prisma.department.upsert({
    where: { name: 'Targon LLC' },
    update: {
      kpi: 'Company performance',
      headId: jarrar?.id || null,
    },
    create: {
      name: 'Targon LLC',
      code: 'TARGON',
      kpi: 'Company performance',
      headId: jarrar?.id || null,
    },
  })
  console.log('Created/Updated: Targon LLC')

  // Executive Supervision (under Mehdi)
  const execSupervision = await prisma.department.upsert({
    where: { name: 'Executive Supervision' },
    update: {
      kpi: 'Management cadence',
      headId: mehdi?.id || null,
      parentId: company.id,
    },
    create: {
      name: 'Executive Supervision',
      code: 'EXEC',
      kpi: 'Management cadence',
      headId: mehdi?.id || null,
      parentId: company.id,
    },
  })
  console.log('Created/Updated: Executive Supervision')

  // HR & Training (under Mehdi)
  const hrTraining = await prisma.department.upsert({
    where: { name: 'HR & Training' },
    update: {
      kpi: 'People readiness',
      headId: mehdi?.id || null,
      parentId: company.id,
    },
    create: {
      name: 'HR & Training',
      code: 'HR',
      kpi: 'People readiness',
      headId: mehdi?.id || null,
      parentId: company.id,
    },
  })
  console.log('Created/Updated: HR & Training')

  // Operations (under Hamad)
  const operations = await prisma.department.upsert({
    where: { name: 'Operations' },
    update: {
      kpi: 'Process reliability',
      headId: hamad?.id || null,
      parentId: company.id,
    },
    create: {
      name: 'Operations',
      code: 'OPS',
      kpi: 'Process reliability',
      headId: hamad?.id || null,
      parentId: company.id,
    },
  })
  console.log('Created/Updated: Operations')

  // Sales & Marketing (under Hamad)
  const salesMarketing = await prisma.department.upsert({
    where: { name: 'Sales & Marketing' },
    update: {
      kpi: 'Order volume',
      headId: hamad?.id || null,
      parentId: company.id,
    },
    create: {
      name: 'Sales & Marketing',
      code: 'SALES',
      kpi: 'Order volume',
      headId: hamad?.id || null,
      parentId: company.id,
    },
  })
  console.log('Created/Updated: Sales & Marketing')

  // Finance (under Zeeshan)
  const finance = await prisma.department.upsert({
    where: { name: 'Finance' },
    update: {
      kpi: 'Cashflow management',
      headId: zeeshan?.id || null,
      parentId: company.id,
    },
    create: {
      name: 'Finance',
      code: 'FIN',
      kpi: 'Cashflow management',
      headId: zeeshan?.id || null,
      parentId: company.id,
    },
  })
  console.log('Created/Updated: Finance')

  // Legal (under Zeeshan)
  const legal = await prisma.department.upsert({
    where: { name: 'Legal' },
    update: {
      kpi: 'Contracts & compliance',
      headId: zeeshan?.id || null,
      parentId: company.id,
    },
    create: {
      name: 'Legal',
      code: 'LEGAL',
      kpi: 'Contracts & compliance',
      headId: zeeshan?.id || null,
      parentId: company.id,
    },
  })
  console.log('Created/Updated: Legal')

  // Also update any existing departments that may not have KPIs
  const existingDepts = await prisma.department.findMany()
  for (const dept of existingDepts) {
    if (!dept.parentId && dept.name !== 'Targon LLC') {
      // Link orphan departments to company
      await prisma.department.update({
        where: { id: dept.id },
        data: { parentId: company.id },
      })
      console.log(`Linked orphan department "${dept.name}" to Targon LLC`)
    }
  }

  console.log('\nDepartment seed completed!')
  console.log('Departments in hierarchy:')

  const allDepts = await prisma.department.findMany({
    include: {
      head: { select: { firstName: true, lastName: true } },
      parent: { select: { name: true } },
    },
    orderBy: { name: 'asc' },
  })

  for (const dept of allDepts) {
    const head = dept.head ? `${dept.head.firstName} ${dept.head.lastName}` : 'No head'
    const parent = dept.parent?.name || 'Root'
    console.log(`  - ${dept.name} (Head: ${head}, Parent: ${parent}, KPI: ${dept.kpi || 'None'})`)
  }
}

main()
  .catch((e) => {
    console.error(e)
    process.exit(1)
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
</file>

<file path="apps/hrms/app/(hrms)/employees/[id]/page.tsx">
'use client'

import { useEffect, useState } from 'react'
import { useParams, useRouter } from 'next/navigation'
import Link from 'next/link'
import {
  EmployeesApi,
  PerformanceReviewsApi,
  DisciplinaryActionsApi,
  LeavesApi,
  type Employee,
  type PerformanceReview,
  type DisciplinaryAction,
  type LeaveBalance,
  type LeaveRequest,
} from '@/lib/api-client'
import {
  UsersIcon,
  PencilIcon,
  EnvelopeIcon,
  PhoneIcon,
  BuildingIcon,
  CalendarIcon,
  ClipboardDocumentCheckIcon,
  ShieldExclamationIcon,
  StarFilledIcon,
  CalendarDaysIcon,
} from '@/components/ui/Icons'
import { PageHeader } from '@/components/ui/PageHeader'
import { Card } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import { StatusBadge } from '@/components/ui/Badge'
import { LeaveBalanceCards } from '@/components/leave/LeaveBalanceCards'
import { LeaveHistoryTable } from '@/components/leave/LeaveHistoryTable'
import { LeaveRequestForm } from '@/components/leave/LeaveRequestForm'
import { employmentTypeLabels } from '@/lib/constants'

type Tab = 'overview' | 'leave' | 'reviews' | 'disciplinary'

const REVIEW_TYPE_LABELS: Record<string, string> = {
  PROBATION: '90-Day Probation',
  QUARTERLY: 'Quarterly',
  SEMI_ANNUAL: 'Semi-Annual',
  ANNUAL: 'Annual',
  PROMOTION: 'Promotion',
  PIP: 'Performance Improvement',
}

const SEVERITY_LABELS: Record<string, string> = {
  MINOR: 'Minor',
  MODERATE: 'Moderate',
  MAJOR: 'Major',
  CRITICAL: 'Critical',
}

const SEVERITY_COLORS: Record<string, string> = {
  MINOR: 'bg-yellow-100 text-yellow-800',
  MODERATE: 'bg-orange-100 text-orange-800',
  MAJOR: 'bg-red-100 text-red-800',
  CRITICAL: 'bg-red-200 text-red-900',
}

function EmployeeAvatar({ firstName, lastName, size = 'lg' }: { firstName: string; lastName: string; size?: 'sm' | 'lg' }) {
  const sizeClasses = size === 'lg' ? 'h-20 w-20 text-2xl' : 'h-10 w-10 text-sm'
  return (
    <div className={`${sizeClasses} rounded-full bg-cyan-100 text-cyan-700 flex items-center justify-center font-semibold`}>
      {firstName?.charAt(0)}{lastName?.charAt(0)}
    </div>
  )
}

function StarRating({ rating }: { rating: number }) {
  return (
    <div className="flex gap-0.5">
      {[1, 2, 3, 4, 5].map((star) => (
        <StarFilledIcon
          key={star}
          className={`h-4 w-4 ${star <= rating ? 'text-amber-400' : 'text-slate-200'}`}
        />
      ))}
    </div>
  )
}

function TabButton({ active, onClick, children, icon: Icon }: { active: boolean; onClick: () => void; children: React.ReactNode; icon: React.ComponentType<{ className?: string }> }) {
  return (
    <button
      onClick={onClick}
      className={`flex items-center gap-2 px-4 py-2.5 text-sm font-medium rounded-lg transition-colors ${
        active
          ? 'bg-cyan-50 text-cyan-700'
          : 'text-slate-600 hover:bg-slate-50 hover:text-slate-900'
      }`}
    >
      <Icon className="h-4 w-4" />
      {children}
    </button>
  )
}

function InfoItem({ icon: Icon, label, value }: { icon: React.ComponentType<{ className?: string }>; label: string; value: string }) {
  return (
    <div className="flex items-start gap-3">
      <Icon className="h-5 w-5 text-slate-400 mt-0.5 flex-shrink-0" />
      <div>
        <p className="text-xs text-slate-500">{label}</p>
        <p className="text-sm text-slate-900 font-medium">{value || '—'}</p>
      </div>
    </div>
  )
}

export default function EmployeeViewPage() {
  const params = useParams()
  const router = useRouter()
  const id = params.id as string

  const [activeTab, setActiveTab] = useState<Tab>('overview')
  const [employee, setEmployee] = useState<Employee | null>(null)
  const [reviews, setReviews] = useState<PerformanceReview[]>([])
  const [disciplinary, setDisciplinary] = useState<DisciplinaryAction[]>([])
  const [leaveBalances, setLeaveBalances] = useState<LeaveBalance[]>([])
  const [leaveRequests, setLeaveRequests] = useState<LeaveRequest[]>([])
  const [loading, setLoading] = useState(true)
  const [reviewsLoading, setReviewsLoading] = useState(false)
  const [disciplinaryLoading, setDisciplinaryLoading] = useState(false)
  const [leaveLoading, setLeaveLoading] = useState(false)
  const [showLeaveForm, setShowLeaveForm] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [canManage, setCanManage] = useState(false)

  useEffect(() => {
    async function loadEmployee() {
      try {
        setLoading(true)
        const data = await EmployeesApi.get(id)
        setEmployee(data)

        // Check if current user can manage this employee
        const permissionCheck = await EmployeesApi.checkCanManage(id)
        setCanManage(permissionCheck.canManage)
      } catch (e: any) {
        setError(e.message || 'Failed to load employee')
      } finally {
        setLoading(false)
      }
    }
    loadEmployee()
  }, [id])

  useEffect(() => {
    async function loadReviews() {
      if (activeTab !== 'reviews') return
      try {
        setReviewsLoading(true)
        const data = await PerformanceReviewsApi.list({ employeeId: id })
        setReviews(data.items || [])
      } catch (e) {
        console.error('Failed to load reviews', e)
      } finally {
        setReviewsLoading(false)
      }
    }
    loadReviews()
  }, [activeTab, id])

  useEffect(() => {
    async function loadDisciplinary() {
      if (activeTab !== 'disciplinary') return
      try {
        setDisciplinaryLoading(true)
        const data = await DisciplinaryActionsApi.list({ employeeId: id })
        setDisciplinary(data.items || [])
      } catch (e) {
        console.error('Failed to load disciplinary actions', e)
      } finally {
        setDisciplinaryLoading(false)
      }
    }
    loadDisciplinary()
  }, [activeTab, id])

  useEffect(() => {
    async function loadLeave() {
      if (activeTab !== 'leave') return
      try {
        setLeaveLoading(true)
        const [balanceData, requestsData] = await Promise.all([
          LeavesApi.getBalance({ employeeId: id }),
          LeavesApi.list({ employeeId: id }),
        ])
        setLeaveBalances(balanceData.balances || [])
        setLeaveRequests(requestsData.items || [])
      } catch (e) {
        console.error('Failed to load leave data', e)
      } finally {
        setLeaveLoading(false)
      }
    }
    loadLeave()
  }, [activeTab, id])

  const handleLeaveRequestSuccess = async () => {
    setShowLeaveForm(false)
    // Reload leave data
    const [balanceData, requestsData] = await Promise.all([
      LeavesApi.getBalance({ employeeId: id }),
      LeavesApi.list({ employeeId: id }),
    ])
    setLeaveBalances(balanceData.balances || [])
    setLeaveRequests(requestsData.items || [])
  }

  const handleCancelLeave = async (requestId: string) => {
    await LeavesApi.update(requestId, { status: 'CANCELLED' })
    // Reload leave data
    const [balanceData, requestsData] = await Promise.all([
      LeavesApi.getBalance({ employeeId: id }),
      LeavesApi.list({ employeeId: id }),
    ])
    setLeaveBalances(balanceData.balances || [])
    setLeaveRequests(requestsData.items || [])
  }

  if (loading) {
    return (
      <>
        <PageHeader
          title="Employee Details"
          description="People"
          icon={<UsersIcon className="h-6 w-6 text-white" />}
          showBack
        />
        <Card padding="lg">
          <div className="animate-pulse space-y-6">
            <div className="flex items-center gap-4">
              <div className="h-20 w-20 rounded-full bg-slate-200" />
              <div className="space-y-2">
                <div className="h-6 bg-slate-200 rounded w-40" />
                <div className="h-4 bg-slate-200 rounded w-24" />
              </div>
            </div>
          </div>
        </Card>
      </>
    )
  }

  if (!employee) {
    return (
      <>
        <PageHeader
          title="Employee Details"
          description="People"
          icon={<UsersIcon className="h-6 w-6 text-white" />}
          showBack
        />
        <Card padding="lg">
          <Alert variant="error">{error || 'Employee not found'}</Alert>
        </Card>
      </>
    )
  }

  const joinDate = employee.joinDate ? new Date(employee.joinDate).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  }) : '—'

  return (
    <>
      <PageHeader
        title={`${employee.firstName} ${employee.lastName}`}
        description="People"
        icon={<UsersIcon className="h-6 w-6 text-white" />}
        showBack
        actions={
          <Button href={`/employees/${id}/edit`} icon={<PencilIcon className="h-4 w-4" />}>
            Edit
          </Button>
        }
      />

      <div className="space-y-6">
        {/* Employee Header Card */}
        <Card padding="lg">
          <div className="flex flex-col sm:flex-row sm:items-center gap-4 sm:gap-6">
            <EmployeeAvatar firstName={employee.firstName} lastName={employee.lastName} size="lg" />
            <div className="flex-1">
              <div className="flex items-center gap-3 mb-1">
                <h2 className="text-xl font-semibold text-slate-900">
                  {employee.firstName} {employee.lastName}
                </h2>
                <StatusBadge status={employee.status.replace('_', ' ')} />
              </div>
              <p className="text-slate-600">{employee.position}</p>
              <p className="text-sm text-slate-500 mt-1">{employee.employeeId}</p>
            </div>
          </div>
        </Card>

        {/* Tabs */}
        <div className="flex gap-2 overflow-x-auto pb-2">
          <TabButton
            active={activeTab === 'overview'}
            onClick={() => setActiveTab('overview')}
            icon={UsersIcon}
          >
            Overview
          </TabButton>
          <TabButton
            active={activeTab === 'leave'}
            onClick={() => setActiveTab('leave')}
            icon={CalendarDaysIcon}
          >
            Leave
          </TabButton>
          <TabButton
            active={activeTab === 'reviews'}
            onClick={() => setActiveTab('reviews')}
            icon={ClipboardDocumentCheckIcon}
          >
            Reviews
          </TabButton>
          <TabButton
            active={activeTab === 'disciplinary'}
            onClick={() => setActiveTab('disciplinary')}
            icon={ShieldExclamationIcon}
          >
            Disciplinary
          </TabButton>
        </div>

        {/* Tab Content */}
        {activeTab === 'overview' && (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card padding="lg">
              <h3 className="text-sm font-semibold text-slate-900 mb-4">Contact Information</h3>
              <div className="space-y-4">
                <InfoItem icon={EnvelopeIcon} label="Email" value={employee.email} />
                <InfoItem icon={PhoneIcon} label="Phone" value={employee.phone || '—'} />
              </div>
            </Card>

            <Card padding="lg">
              <h3 className="text-sm font-semibold text-slate-900 mb-4">Work Information</h3>
              <div className="space-y-4">
                <InfoItem icon={BuildingIcon} label="Department" value={employee.department || '—'} />
                <InfoItem icon={CalendarIcon} label="Join Date" value={joinDate} />
                <div className="flex items-start gap-3">
                  <UsersIcon className="h-5 w-5 text-slate-400 mt-0.5 flex-shrink-0" />
                  <div>
                    <p className="text-xs text-slate-500">Employment Type</p>
                    <p className="text-sm text-slate-900 font-medium">{employmentTypeLabels[employee.employmentType] || employee.employmentType}</p>
                  </div>
                </div>
              </div>
            </Card>
          </div>
        )}

        {activeTab === 'reviews' && (
          <Card padding="lg">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-sm font-semibold text-slate-900">Performance Reviews</h3>
              {canManage && (
                <Button
                  size="sm"
                  href={`/performance/reviews/add?employeeId=${id}`}
                >
                  Add Review
                </Button>
              )}
            </div>

            {reviewsLoading ? (
              <div className="animate-pulse space-y-3">
                {[1, 2, 3].map((i) => (
                  <div key={i} className="h-20 bg-slate-100 rounded-lg" />
                ))}
              </div>
            ) : reviews.length === 0 ? (
              <div className="text-center py-8">
                <ClipboardDocumentCheckIcon className="h-10 w-10 text-slate-300 mx-auto mb-2" />
                <p className="text-slate-500 text-sm">No performance reviews yet</p>
              </div>
            ) : (
              <div className="space-y-3">
                {reviews.map((review) => (
                  <Link
                    key={review.id}
                    href={`/performance/reviews/${review.id}`}
                    className="block p-4 bg-slate-50 rounded-lg hover:bg-slate-100 transition-colors"
                  >
                    <div className="flex items-start justify-between">
                      <div>
                        <div className="flex items-center gap-2 mb-1">
                          <span className="font-medium text-slate-900">
                            {REVIEW_TYPE_LABELS[review.reviewType] || review.reviewType}
                          </span>
                          <StatusBadge status={review.status} />
                        </div>
                        <p className="text-sm text-slate-600">{review.reviewPeriod}</p>
                        <p className="text-xs text-slate-500 mt-1">
                          Reviewed by {review.reviewerName} on {new Date(review.reviewDate).toLocaleDateString()}
                        </p>
                      </div>
                      <div className="text-right">
                        <StarRating rating={review.overallRating} />
                        <p className="text-xs text-slate-500 mt-1">{review.overallRating}/5</p>
                      </div>
                    </div>
                  </Link>
                ))}
              </div>
            )}
          </Card>
        )}

        {activeTab === 'disciplinary' && (
          <Card padding="lg">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-sm font-semibold text-slate-900">Disciplinary Actions</h3>
              {canManage && (
                <Button
                  size="sm"
                  href={`/performance/disciplinary/add?employeeId=${id}`}
                >
                  Report Violation
                </Button>
              )}
            </div>

            {disciplinaryLoading ? (
              <div className="animate-pulse space-y-3">
                {[1, 2, 3].map((i) => (
                  <div key={i} className="h-20 bg-slate-100 rounded-lg" />
                ))}
              </div>
            ) : disciplinary.length === 0 ? (
              <div className="text-center py-8">
                <ShieldExclamationIcon className="h-10 w-10 text-slate-300 mx-auto mb-2" />
                <p className="text-slate-500 text-sm">No disciplinary records</p>
              </div>
            ) : (
              <div className="space-y-3">
                {disciplinary.map((action) => (
                  <Link
                    key={action.id}
                    href={`/performance/disciplinary/${action.id}`}
                    className="block p-4 bg-slate-50 rounded-lg hover:bg-slate-100 transition-colors"
                  >
                    <div className="flex items-start justify-between">
                      <div>
                        <div className="flex items-center gap-2 mb-1">
                          <span className="font-medium text-slate-900">
                            {action.violationType.replace(/_/g, ' ')}
                          </span>
                          <span className={`px-2 py-0.5 rounded text-xs font-medium ${SEVERITY_COLORS[action.severity] || 'bg-slate-100 text-slate-700'}`}>
                            {SEVERITY_LABELS[action.severity] || action.severity}
                          </span>
                        </div>
                        <p className="text-sm text-slate-600">{action.violationReason.replace(/_/g, ' ')}</p>
                        <p className="text-xs text-slate-500 mt-1">
                          Incident: {new Date(action.incidentDate).toLocaleDateString()}
                        </p>
                      </div>
                      <div>
                        <StatusBadge status={action.status.replace(/_/g, ' ')} />
                      </div>
                    </div>
                  </Link>
                ))}
              </div>
            )}
          </Card>
        )}
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/layout.tsx">
'use client'

import Link from 'next/link'
import { ReactNode, useState, useEffect } from 'react'
import { usePathname } from 'next/navigation'
import {
  HomeIcon,
  UsersIcon,
  FolderIcon,
  DocumentIcon,
  CalendarIcon,
  MenuIcon,
  XIcon,
  ClipboardDocumentCheckIcon,
  ShieldExclamationIcon,
  OrgChartIcon,
} from '@/components/ui/Icons'
import { NotificationBell } from '@/components/ui/NotificationBell'
import { NavigationHistoryProvider } from '@/lib/navigation-history'

interface NavItem {
  name: string
  href: string
  icon: React.ComponentType<{ className?: string }>
}

interface NavSection {
  title: string
  items: NavItem[]
}

const navigation: NavSection[] = [
  {
    title: '',
    items: [
      { name: 'Dashboard', href: '/', icon: HomeIcon },
    ]
  },
  {
    title: 'People',
    items: [
      { name: 'Employees', href: '/employees', icon: UsersIcon },
      { name: 'Org Chart', href: '/organogram', icon: OrgChartIcon },
    ]
  },
  {
    title: 'Performance',
    items: [
      { name: 'Reviews', href: '/performance/reviews', icon: ClipboardDocumentCheckIcon },
      { name: 'Disciplinary', href: '/performance/disciplinary', icon: ShieldExclamationIcon },
    ]
  },
  {
    title: 'Company',
    items: [
      { name: 'Resources', href: '/resources', icon: FolderIcon },
      { name: 'Policies', href: '/policies', icon: DocumentIcon },
      { name: 'Calendar', href: '/calendar', icon: CalendarIcon },
    ]
  },
]

function cn(...classes: (string | boolean | undefined)[]) {
  return classes.filter(Boolean).join(' ')
}

function Sidebar({ onClose }: { onClose?: () => void }) {
  const pathname = usePathname()

  const matchesPath = (href: string) => {
    if (href === '/') return pathname === '/' || pathname === ''
    return pathname.startsWith(href)
  }

  return (
    <div className="flex grow flex-col gap-y-5 overflow-y-auto border-r border-slate-200 bg-white px-6 pb-4">
      <div className="flex h-16 shrink-0 items-center justify-between">
        <Link href="/" className="flex items-center gap-3">
          <div className="flex h-10 w-10 items-center justify-center rounded-xl bg-cyan-600 shadow-md">
            <span className="text-sm font-bold text-white">HR</span>
          </div>
          <span className="text-lg font-semibold text-slate-900">HRMS</span>
        </Link>
        <div className="flex items-center gap-2">
          <div className="hidden md:block">
            <NotificationBell />
          </div>
          {onClose && (
            <button onClick={onClose} className="md:hidden p-2 hover:bg-slate-100 rounded-lg">
              <XIcon className="h-5 w-5 text-slate-500" />
            </button>
          )}
        </div>
      </div>

      <nav className="flex flex-1 flex-col">
        <ul role="list" className="flex flex-1 flex-col gap-y-6">
          {navigation.map((section, sectionIdx) => (
            <li key={sectionIdx}>
              {section.title && (
                <div className="px-3 pb-2 text-xs font-semibold text-slate-400 uppercase tracking-wider">
                  {section.title}
                </div>
              )}
              <ul role="list" className="space-y-1">
                {section.items.map((item) => (
                  <li key={item.name}>
                    <Link
                      href={item.href}
                      onClick={onClose}
                      className={cn(
                        matchesPath(item.href)
                          ? 'bg-cyan-50 text-cyan-700'
                          : 'text-slate-600 hover:text-slate-900 hover:bg-slate-50',
                        'group flex gap-x-3 rounded-lg py-2.5 px-3 text-sm font-medium transition-colors'
                      )}
                    >
                      <item.icon
                        className={cn(
                          matchesPath(item.href)
                            ? 'text-cyan-600'
                            : 'text-slate-400 group-hover:text-slate-600',
                          'h-5 w-5 shrink-0 transition-colors'
                        )}
                      />
                      {item.name}
                    </Link>
                  </li>
                ))}
              </ul>
            </li>
          ))}
        </ul>
      </nav>
    </div>
  )
}

function MobileNav({ isOpen, onClose }: { isOpen: boolean; onClose: () => void }) {
  if (!isOpen) return null

  return (
    <div className="relative z-50 md:hidden">
      <div className="fixed inset-0 bg-slate-900/80 backdrop-blur-sm" onClick={onClose} />
      <div className="fixed inset-0 flex">
        <div className="relative mr-16 flex w-full max-w-xs flex-1">
          <div className="absolute left-full top-0 flex w-16 justify-center pt-5">
            <button type="button" className="-m-2.5 p-2.5" onClick={onClose}>
              <XIcon className="h-6 w-6 text-white" />
            </button>
          </div>
          <Sidebar onClose={onClose} />
        </div>
      </div>
    </div>
  )
}

function Header({ onMenuClick }: { onMenuClick: () => void }) {
  const pathname = usePathname()

  const getCurrentPageName = () => {
    for (const section of navigation) {
      for (const item of section.items) {
        if (item.href === '/') {
          if (pathname === '/' || pathname === '') return item.name
        } else if (pathname.startsWith(item.href)) {
          return item.name
        }
      }
    }
    return 'Dashboard'
  }

  return (
    <div className="sticky top-0 z-40 flex items-center gap-x-4 bg-white px-4 py-4 border-b border-slate-200 sm:px-6 md:hidden">
      <button type="button" className="-m-2 p-2 text-slate-600 hover:text-slate-900" onClick={onMenuClick}>
        <MenuIcon className="h-6 w-6" />
      </button>
      <div className="flex-1 text-base font-semibold text-slate-900">
        {getCurrentPageName()}
      </div>
      <NotificationBell />
    </div>
  )
}

export default function HRMSLayout({ children }: { children: ReactNode }) {
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false)
  const version = process.env.NEXT_PUBLIC_VERSION ?? '0.0.0'
  const explicitReleaseUrl = process.env.NEXT_PUBLIC_RELEASE_URL || undefined
  const commitSha = process.env.NEXT_PUBLIC_COMMIT_SHA || undefined
  const commitUrl = commitSha ? `https://github.com/progami/ecom-os/commit/${commitSha}` : undefined
  const inferredReleaseUrl = `https://github.com/progami/ecom-os/releases/tag/v${version}`
  const versionHref = explicitReleaseUrl ?? commitUrl ?? inferredReleaseUrl

  const pathname = usePathname()
  useEffect(() => {
    setMobileMenuOpen(false)
  }, [pathname])

  return (
    <NavigationHistoryProvider>
      {/* Desktop Sidebar */}
      <div className="hidden md:fixed md:inset-y-0 md:z-50 md:flex md:w-64 md:flex-col">
        <Sidebar />
      </div>

      {/* Mobile Nav */}
      <MobileNav isOpen={mobileMenuOpen} onClose={() => setMobileMenuOpen(false)} />

      {/* Main Content */}
      <div className="md:pl-64 min-h-screen flex flex-col bg-slate-50">
        <Header onMenuClick={() => setMobileMenuOpen(true)} />

        <main className="flex-1">
          <div className="px-4 sm:px-6 lg:px-8 py-8 max-w-7xl mx-auto">
            {children}
          </div>
        </main>

        <footer className="border-t border-slate-200 bg-white mt-auto">
          <div className="px-4 sm:px-6 lg:px-8 py-4">
            <p className="text-xs text-slate-400 text-center">
              HRMS{' '}
              <a
                href={versionHref}
                target="_blank"
                rel="noopener noreferrer"
                className="underline hover:text-slate-600 transition-colors"
              >
                v{version}
              </a>
            </p>
          </div>
        </footer>
      </div>
    </NavigationHistoryProvider>
  )
}
</file>

<file path="apps/hrms/components/organogram/DepartmentOrgChart.tsx">
'use client'

import { useState, useMemo, useCallback } from 'react'
import Link from 'next/link'
import { Department } from '@/lib/api-client'
import { Avatar } from '@/components/ui/Avatar'
import { MinusIcon, PlusIcon, UsersIcon } from '@/components/ui/Icons'

type DeptNode = Department & {
  childDepts: DeptNode[]
}

type Props = {
  departments: Department[]
}

function buildDeptTree(departments: Department[]): DeptNode[] {
  const deptMap = new Map<string, DeptNode>()

  // Initialize all departments with empty children
  for (const dept of departments) {
    deptMap.set(dept.id, { ...dept, childDepts: [] })
  }

  const roots: DeptNode[] = []

  // Build tree by adding children to their parents
  for (const dept of departments) {
    const node = deptMap.get(dept.id)!
    if (dept.parentId && deptMap.has(dept.parentId)) {
      deptMap.get(dept.parentId)!.childDepts.push(node)
    } else {
      roots.push(node)
    }
  }

  // Sort children alphabetically
  const sortChildren = (node: DeptNode) => {
    node.childDepts.sort((a, b) => a.name.localeCompare(b.name))
    node.childDepts.forEach(sortChildren)
  }

  roots.sort((a, b) => a.name.localeCompare(b.name))
  roots.forEach(sortChildren)

  return roots
}

// Department card component
function DepartmentCard({
  node,
  hasChildren,
  isExpanded,
  onToggle,
  employeeCount,
  isRoot,
}: {
  node: DeptNode
  hasChildren: boolean
  isExpanded: boolean
  onToggle: () => void
  employeeCount: number
  isRoot?: boolean
}) {
  const hasHead = !!node.head

  return (
    <div
      className={`relative flex flex-col rounded-xl p-4 min-w-[200px] max-w-[240px] transition-all duration-200 ${
        isRoot
          ? 'border-2 border-cyan-500 bg-gradient-to-br from-cyan-50 to-white shadow-md ring-4 ring-cyan-100'
          : hasHead
            ? 'border border-slate-200 bg-white shadow-sm hover:shadow-md'
            : 'border border-dashed border-slate-300 bg-slate-50'
      }`}
      data-department-id={node.id}
    >
      {/* Root badge */}
      {isRoot && (
        <div className="absolute -top-2.5 left-1/2 -translate-x-1/2 px-2.5 py-0.5 bg-cyan-600 text-white text-[10px] font-bold uppercase tracking-wider rounded-full shadow-sm">
          Company
        </div>
      )}

      {/* Department Name */}
      <h3 className={`font-semibold text-center leading-tight mb-2 ${isRoot ? 'text-cyan-900 text-base mt-1' : 'text-slate-800 text-sm'}`}>
        {node.name}
      </h3>

      {/* Department Head */}
      {node.head ? (
        <div className="flex items-center gap-2 p-2 bg-slate-50 rounded-lg">
          <Avatar
            src={node.head.avatar}
            alt={`${node.head.firstName} ${node.head.lastName}`}
            size="sm"
          />
          <div className="flex-1 min-w-0">
            <Link
              href={`/employees/${node.head.id}`}
              className="text-xs font-semibold text-slate-900 hover:text-cyan-600 truncate block"
            >
              {node.head.firstName} {node.head.lastName}
            </Link>
            <p className="text-[10px] text-slate-500 truncate">{node.head.position}</p>
          </div>
        </div>
      ) : (
        <div className="flex items-center justify-center gap-1.5 p-2 text-slate-400 text-xs">
          <UsersIcon className="h-3.5 w-3.5" />
          <span>No head assigned</span>
        </div>
      )}

      {/* Employee count */}
      <div className="flex items-center justify-center gap-1 mt-2 text-[11px] text-slate-500">
        <UsersIcon className="h-3.5 w-3.5" />
        <span>{employeeCount} {employeeCount === 1 ? 'member' : 'members'}</span>
      </div>

      {/* Expand/collapse button */}
      {hasChildren && (
        <button
          onClick={onToggle}
          className="absolute -bottom-3 left-1/2 -translate-x-1/2 w-6 h-6 rounded-full bg-white border border-slate-200 shadow-sm flex items-center justify-center hover:bg-slate-50 hover:border-slate-300 transition-colors z-10"
        >
          {isExpanded ? (
            <MinusIcon className="h-3 w-3 text-slate-500" />
          ) : (
            <PlusIcon className="h-3 w-3 text-slate-500" />
          )}
        </button>
      )}
    </div>
  )
}

// Recursive tree node component
function DeptTreeNode({
  node,
  expandedNodes,
  toggleNode,
  employeeCounts,
  level = 0,
}: {
  node: DeptNode
  expandedNodes: Set<string>
  toggleNode: (id: string) => void
  employeeCounts: Map<string, number>
  level?: number
}) {
  const hasChildren = node.childDepts.length > 0
  const isExpanded = expandedNodes.has(node.id)
  const employeeCount = employeeCounts.get(node.id) || 0
  const isRoot = level === 0

  return (
    <div className="flex flex-col items-center">
      {/* Department Card */}
      <DepartmentCard
        node={node}
        hasChildren={hasChildren}
        isExpanded={isExpanded}
        onToggle={() => toggleNode(node.id)}
        employeeCount={employeeCount}
        isRoot={isRoot}
      />

      {/* Children */}
      {hasChildren && isExpanded && (
        <div className="flex flex-col items-center mt-10">
          {/* Vertical line down from parent */}
          <div className="w-0.5 h-8 bg-gradient-to-b from-cyan-300 to-slate-300 rounded-full" />

          {/* Horizontal connector line */}
          {node.childDepts.length > 1 && (
            <div
              className="h-0.5 bg-slate-300 rounded-full"
              style={{
                width: `calc(${(node.childDepts.length - 1) * 280}px)`,
                marginBottom: '-1px'
              }}
            />
          )}

          {/* Children row */}
          <div className="flex gap-6">
            {node.childDepts.map((child) => (
              <div key={child.id} className="flex flex-col items-center">
                {/* Vertical line to child */}
                <div className="w-0.5 h-8 bg-slate-300 rounded-full mb-2" />
                <DeptTreeNode
                  node={child}
                  expandedNodes={expandedNodes}
                  toggleNode={toggleNode}
                  employeeCounts={employeeCounts}
                  level={level + 1}
                />
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}

export function DepartmentOrgChart({ departments }: Props) {
  const tree = useMemo(() => buildDeptTree(departments), [departments])

  // Get employee counts from API response
  const employeeCounts = useMemo(() => {
    const counts = new Map<string, number>()
    for (const dept of departments) {
      counts.set(dept.id, dept._count?.employees ?? 0)
    }
    return counts
  }, [departments])

  // Initialize expanded nodes - expand first 2 levels
  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(() => {
    const initial = new Set<string>()
    const expandLevel = (nodes: DeptNode[], level: number) => {
      if (level >= 2) return
      for (const node of nodes) {
        initial.add(node.id)
        expandLevel(node.childDepts, level + 1)
      }
    }
    expandLevel(tree, 0)
    return initial
  })

  const toggleNode = useCallback((id: string) => {
    setExpandedNodes(prev => {
      const next = new Set(prev)
      if (next.has(id)) {
        next.delete(id)
      } else {
        next.add(id)
      }
      return next
    })
  }, [])

  const expandAll = useCallback(() => {
    const allIds = new Set<string>()
    const collect = (nodes: DeptNode[]) => {
      for (const node of nodes) {
        allIds.add(node.id)
        collect(node.childDepts)
      }
    }
    collect(tree)
    setExpandedNodes(allIds)
  }, [tree])

  const collapseAll = useCallback(() => {
    setExpandedNodes(new Set())
  }, [])

  if (departments.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-16 text-slate-500">
        <div className="w-16 h-16 rounded-full bg-slate-100 flex items-center justify-center mb-4">
          <UsersIcon className="h-8 w-8 text-slate-400" />
        </div>
        <p className="text-lg font-medium text-slate-700">No departments found</p>
        <p className="text-sm mt-2 text-slate-500">Create departments and assign heads to see the organization structure.</p>
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {/* Controls */}
      <div className="flex items-center justify-end gap-2">
        <button
          onClick={expandAll}
          className="px-3 py-1.5 text-sm text-slate-600 hover:text-slate-900 hover:bg-slate-100 rounded-lg transition-colors flex items-center gap-1"
        >
          <PlusIcon className="h-4 w-4" />
          Expand All
        </button>
        <button
          onClick={collapseAll}
          className="px-3 py-1.5 text-sm text-slate-600 hover:text-slate-900 hover:bg-slate-100 rounded-lg transition-colors flex items-center gap-1"
        >
          <MinusIcon className="h-4 w-4" />
          Collapse All
        </button>
      </div>

      {/* Chart container - no inner scroll, page scrolls */}
      <div className="pb-8 -mx-6 px-6">
        <div className="inline-flex flex-col items-center min-w-full py-6">
          {/* Handle multiple roots */}
          {tree.length === 1 ? (
            <DeptTreeNode
              node={tree[0]}
              expandedNodes={expandedNodes}
              toggleNode={toggleNode}
              employeeCounts={employeeCounts}
            />
          ) : (
            <div className="flex flex-col items-center">
              <div className="flex gap-10 items-start">
                {tree.map((root) => (
                  <DeptTreeNode
                    key={root.id}
                    node={root}
                    expandedNodes={expandedNodes}
                    toggleNode={toggleNode}
                    employeeCounts={employeeCounts}
                  />
                ))}
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="apps/hrms/components/organogram/OrgChart.tsx">
'use client'

import { useState, useMemo, useRef, useEffect, useCallback } from 'react'
import Link from 'next/link'
import { HierarchyEmployee } from '@/lib/api-client'
import { Avatar } from '@/components/ui/Avatar'
import { ChevronDownIcon, ChevronUpIcon, MinusIcon, PlusIcon } from '@/components/ui/Icons'

type OrgNode = HierarchyEmployee & {
  children: OrgNode[]
}

type Props = {
  employees: HierarchyEmployee[]
  currentEmployeeId: string | null
  managerChainIds: string[]
  directReportIds: string[]
}

function buildTree(employees: HierarchyEmployee[]): OrgNode[] {
  const employeeMap = new Map<string, OrgNode>()

  // Initialize all employees with empty children
  for (const emp of employees) {
    employeeMap.set(emp.id, { ...emp, children: [] })
  }

  const roots: OrgNode[] = []

  // Build tree by adding children to their managers
  for (const emp of employees) {
    const node = employeeMap.get(emp.id)!
    if (emp.reportsToId && employeeMap.has(emp.reportsToId)) {
      employeeMap.get(emp.reportsToId)!.children.push(node)
    } else {
      roots.push(node)
    }
  }

  // Sort children alphabetically
  const sortChildren = (node: OrgNode) => {
    node.children.sort((a, b) =>
      `${a.firstName} ${a.lastName}`.localeCompare(`${b.firstName} ${b.lastName}`)
    )
    node.children.forEach(sortChildren)
  }

  roots.sort((a, b) =>
    `${a.firstName} ${a.lastName}`.localeCompare(`${b.firstName} ${b.lastName}`)
  )
  roots.forEach(sortChildren)

  return roots
}

// Employee card component
function EmployeeCard({
  node,
  isCurrentUser,
  hasChildren,
  isExpanded,
  onToggle,
}: {
  node: OrgNode
  isCurrentUser: boolean
  hasChildren: boolean
  isExpanded: boolean
  onToggle: () => void
}) {
  const isContractor = node.employmentType === 'CONTRACT'

  return (
    <div
      className={`relative flex flex-col items-center rounded-xl p-4 min-w-[180px] max-w-[200px] hover:shadow-lg transition-all duration-200 ${
        isCurrentUser
          ? 'border-cyan-500 border-2 bg-gradient-to-br from-cyan-50 to-white shadow-md shadow-cyan-100 ring-4 ring-cyan-100'
          : isContractor
            ? 'border-2 border-dashed border-amber-400 bg-amber-50/30 shadow-sm'
            : 'border border-slate-200 bg-white shadow-sm'
      }`}
      data-employee-id={node.id}
    >
      {/* "YOU" badge for current user */}
      {isCurrentUser && (
        <div className="absolute -top-2.5 left-1/2 -translate-x-1/2 px-2.5 py-0.5 bg-cyan-600 text-white text-[10px] font-bold uppercase tracking-wider rounded-full shadow-sm">
          You
        </div>
      )}

      {/* Contractor badge */}
      {isContractor && !isCurrentUser && (
        <div className="absolute -top-2.5 left-1/2 -translate-x-1/2 px-2.5 py-0.5 bg-amber-500 text-white text-[10px] font-bold uppercase tracking-wider rounded-full shadow-sm">
          Contractor
        </div>
      )}

      <Avatar
        src={node.avatar}
        alt={`${node.firstName} ${node.lastName}`}
        size="lg"
        className={isCurrentUser ? 'ring-2 ring-cyan-400 ring-offset-2' : ''}
      />
      <Link
        href={`/employees/${node.id}`}
        className={`mt-2 font-semibold text-center text-sm leading-tight ${
          isCurrentUser ? 'text-cyan-700 hover:text-cyan-800' : 'text-slate-900 hover:text-cyan-600'
        }`}
      >
        {node.firstName} {node.lastName}
      </Link>
      <p className="text-xs text-slate-600 text-center mt-1 font-medium">{node.position}</p>
      <p className="text-[11px] text-slate-400 text-center">{node.department}</p>

      {hasChildren && (
        <button
          onClick={onToggle}
          className="absolute -bottom-3 left-1/2 -translate-x-1/2 w-6 h-6 rounded-full bg-white border border-slate-200 shadow-sm flex items-center justify-center hover:bg-slate-50 hover:border-slate-300 transition-colors z-10"
        >
          {isExpanded ? (
            <MinusIcon className="h-3 w-3 text-slate-500" />
          ) : (
            <PlusIcon className="h-3 w-3 text-slate-500" />
          )}
        </button>
      )}
    </div>
  )
}

// Recursive tree node component
function TreeNode({
  node,
  currentEmployeeId,
  expandedNodes,
  toggleNode,
}: {
  node: OrgNode
  currentEmployeeId: string | null
  expandedNodes: Set<string>
  toggleNode: (id: string) => void
}) {
  const isCurrentUser = node.id === currentEmployeeId
  const hasChildren = node.children.length > 0
  const isExpanded = expandedNodes.has(node.id)

  return (
    <div className="flex flex-col items-center">
      {/* Employee Card */}
      <EmployeeCard
        node={node}
        isCurrentUser={isCurrentUser}
        hasChildren={hasChildren}
        isExpanded={isExpanded}
        onToggle={() => toggleNode(node.id)}
      />

      {/* Children */}
      {hasChildren && isExpanded && (
        <div className="flex flex-col items-center mt-8">
          {/* Vertical line down from parent */}
          <div className="w-px h-6 bg-slate-300" />

          {/* Horizontal connector line */}
          {node.children.length > 1 && (
            <div
              className="h-px bg-slate-300"
              style={{
                width: `calc(${(node.children.length - 1) * 220}px)`,
                marginBottom: '-1px'
              }}
            />
          )}

          {/* Children row */}
          <div className="flex gap-5">
            {node.children.map((child) => (
              <div key={child.id} className="flex flex-col items-center">
                {/* Vertical line to child */}
                <div className="w-px h-6 bg-slate-300 mb-2" />
                <TreeNode
                  node={child}
                  currentEmployeeId={currentEmployeeId}
                  expandedNodes={expandedNodes}
                  toggleNode={toggleNode}
                />
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}

export function OrgChart({ employees, currentEmployeeId, managerChainIds, directReportIds }: Props) {
  const tree = useMemo(() => buildTree(employees), [employees])
  const containerRef = useRef<HTMLDivElement>(null)
  const chartRef = useRef<HTMLDivElement>(null)

  // Initialize expanded nodes - expand path to current user and first 2 levels
  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(() => {
    const initial = new Set<string>()

    // Always expand manager chain (path to current user)
    managerChainIds.forEach(id => initial.add(id))

    // Expand current user to show their direct reports
    if (currentEmployeeId) {
      initial.add(currentEmployeeId)
    }

    // Expand first 2 levels
    const expandLevel = (nodes: OrgNode[], level: number) => {
      if (level >= 2) return
      for (const node of nodes) {
        initial.add(node.id)
        expandLevel(node.children, level + 1)
      }
    }
    expandLevel(tree, 0)

    return initial
  })

  const toggleNode = useCallback((id: string) => {
    setExpandedNodes(prev => {
      const next = new Set(prev)
      if (next.has(id)) {
        next.delete(id)
      } else {
        next.add(id)
      }
      return next
    })
  }, [])

  const expandAll = useCallback(() => {
    const allIds = new Set<string>()
    const collect = (nodes: OrgNode[]) => {
      for (const node of nodes) {
        allIds.add(node.id)
        collect(node.children)
      }
    }
    collect(tree)
    setExpandedNodes(allIds)
  }, [tree])

  const collapseAll = useCallback(() => {
    setExpandedNodes(new Set())
  }, [])

  // Scroll to current user on mount
  useEffect(() => {
    if (currentEmployeeId && chartRef.current && containerRef.current) {
      const timer = setTimeout(() => {
        const currentUserCard = chartRef.current?.querySelector(`[data-employee-id="${currentEmployeeId}"]`)
        if (currentUserCard && containerRef.current) {
          const containerRect = containerRef.current.getBoundingClientRect()
          const cardRect = currentUserCard.getBoundingClientRect()

          // Calculate scroll position to center the card
          const scrollLeft = cardRect.left - containerRect.left + containerRef.current.scrollLeft - (containerRect.width / 2) + (cardRect.width / 2)

          containerRef.current.scrollTo({
            left: Math.max(0, scrollLeft),
            behavior: 'smooth'
          })
        }
      }, 100)
      return () => clearTimeout(timer)
    }
  }, [currentEmployeeId])

  if (employees.length === 0) {
    return (
      <div className="text-center py-12 text-slate-500">
        No employees found
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {/* Controls */}
      <div className="flex items-center justify-end gap-2">
        <button
          onClick={expandAll}
          className="px-3 py-1.5 text-sm text-slate-600 hover:text-slate-900 hover:bg-slate-100 rounded-lg transition-colors flex items-center gap-1"
        >
          <PlusIcon className="h-4 w-4" />
          Expand All
        </button>
        <button
          onClick={collapseAll}
          className="px-3 py-1.5 text-sm text-slate-600 hover:text-slate-900 hover:bg-slate-100 rounded-lg transition-colors flex items-center gap-1"
        >
          <MinusIcon className="h-4 w-4" />
          Collapse All
        </button>
      </div>

      {/* Chart container - no inner scroll, page scrolls */}
      <div
        ref={containerRef}
        className="pb-8 -mx-6 px-6"
      >
        <div
          ref={chartRef}
          className="inline-flex flex-col items-center min-w-full py-6"
        >
          {/* Handle multiple roots (people without managers) */}
          {tree.length === 1 ? (
            <TreeNode
              node={tree[0]}
              currentEmployeeId={currentEmployeeId}
              expandedNodes={expandedNodes}
              toggleNode={toggleNode}
            />
          ) : (
            <div className="flex flex-col items-center">
              {/* Multiple roots - show them in a row */}
              <div className="flex gap-8 items-start">
                {tree.map((root) => (
                  <TreeNode
                    key={root.id}
                    node={root}
                    currentEmployeeId={currentEmployeeId}
                    expandedNodes={expandedNodes}
                    toggleNode={toggleNode}
                  />
                ))}
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/performance/disciplinary/add/page.tsx">
'use client'

import { useState, useEffect, Suspense } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { DisciplinaryActionsApi, EmployeesApi, type Employee } from '@/lib/api-client'
import { ShieldExclamationIcon } from '@/components/ui/Icons'
import { PageHeader } from '@/components/ui/PageHeader'
import { Card, CardDivider } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import {
  FormField,
  SelectField,
  TextareaField,
  FormSection,
  FormActions,
} from '@/components/ui/FormField'
import { useNavigationHistory } from '@/lib/navigation-history'

const violationTypeOptions = [
  { value: 'ATTENDANCE', label: 'Attendance' },
  { value: 'CONDUCT', label: 'Conduct' },
  { value: 'PERFORMANCE', label: 'Performance' },
  { value: 'POLICY_VIOLATION', label: 'Policy Violation' },
  { value: 'SAFETY', label: 'Safety' },
  { value: 'HARASSMENT', label: 'Harassment' },
  { value: 'INSUBORDINATION', label: 'Insubordination' },
  { value: 'THEFT_FRAUD', label: 'Theft/Fraud' },
  { value: 'SUBSTANCE_ABUSE', label: 'Substance Abuse' },
  { value: 'OTHER', label: 'Other' },
]

const violationReasonOptions: Record<string, { value: string; label: string }[]> = {
  ATTENDANCE: [
    { value: 'EXCESSIVE_ABSENCES', label: 'Excessive Absences' },
    { value: 'TARDINESS', label: 'Tardiness' },
    { value: 'UNAUTHORIZED_LEAVE', label: 'Unauthorized Leave' },
    { value: 'NO_CALL_NO_SHOW', label: 'No Call/No Show' },
  ],
  CONDUCT: [
    { value: 'UNPROFESSIONAL_BEHAVIOR', label: 'Unprofessional Behavior' },
    { value: 'DISRUPTIVE_CONDUCT', label: 'Disruptive Conduct' },
    { value: 'INAPPROPRIATE_LANGUAGE', label: 'Inappropriate Language' },
    { value: 'DRESS_CODE_VIOLATION', label: 'Dress Code Violation' },
  ],
  PERFORMANCE: [
    { value: 'POOR_QUALITY_WORK', label: 'Poor Quality Work' },
    { value: 'MISSED_DEADLINES', label: 'Missed Deadlines' },
    { value: 'FAILURE_TO_FOLLOW_INSTRUCTIONS', label: 'Failure to Follow Instructions' },
    { value: 'NEGLIGENCE', label: 'Negligence' },
  ],
  POLICY_VIOLATION: [
    { value: 'CONFIDENTIALITY_BREACH', label: 'Confidentiality Breach' },
    { value: 'DATA_SECURITY_VIOLATION', label: 'Data Security Violation' },
    { value: 'EXPENSE_POLICY_VIOLATION', label: 'Expense Policy Violation' },
    { value: 'IT_POLICY_VIOLATION', label: 'IT Policy Violation' },
  ],
  SAFETY: [
    { value: 'SAFETY_PROTOCOL_VIOLATION', label: 'Safety Protocol Violation' },
    { value: 'EQUIPMENT_MISUSE', label: 'Equipment Misuse' },
  ],
  HARASSMENT: [
    { value: 'HARASSMENT_DISCRIMINATION', label: 'Harassment/Discrimination' },
    { value: 'WORKPLACE_VIOLENCE', label: 'Workplace Violence' },
  ],
  THEFT_FRAUD: [
    { value: 'THEFT', label: 'Theft' },
    { value: 'FRAUD', label: 'Fraud' },
    { value: 'FALSIFICATION', label: 'Falsification of Records' },
  ],
  SUBSTANCE_ABUSE: [
    { value: 'SUBSTANCE_USE_AT_WORK', label: 'Substance Use at Work' },
  ],
  INSUBORDINATION: [
    { value: 'FAILURE_TO_FOLLOW_INSTRUCTIONS', label: 'Failure to Follow Instructions' },
    { value: 'DISRUPTIVE_CONDUCT', label: 'Disruptive Conduct' },
  ],
  OTHER: [
    { value: 'OTHER', label: 'Other' },
  ],
}

const severityOptions = [
  { value: 'MINOR', label: 'Minor - Verbal Warning' },
  { value: 'MODERATE', label: 'Moderate - Written Warning' },
  { value: 'MAJOR', label: 'Major - Final Warning/Suspension' },
  { value: 'CRITICAL', label: 'Critical - Termination Consideration' },
]

const actionTypeOptions = [
  { value: 'VERBAL_WARNING', label: 'Verbal Warning' },
  { value: 'WRITTEN_WARNING', label: 'Written Warning' },
  { value: 'FINAL_WARNING', label: 'Final Warning' },
  { value: 'SUSPENSION', label: 'Suspension' },
  { value: 'DEMOTION', label: 'Demotion' },
  { value: 'TERMINATION', label: 'Termination' },
  { value: 'PIP', label: 'Performance Improvement Plan' },
  { value: 'TRAINING_REQUIRED', label: 'Training Required' },
  { value: 'NO_ACTION', label: 'No Action (Investigation Only)' },
]

const statusOptions = [
  { value: 'OPEN', label: 'Open' },
  { value: 'UNDER_INVESTIGATION', label: 'Under Investigation' },
  { value: 'ACTION_TAKEN', label: 'Action Taken' },
  { value: 'APPEALED', label: 'Appealed' },
  { value: 'CLOSED', label: 'Closed' },
  { value: 'DISMISSED', label: 'Dismissed' },
]

function AddDisciplinaryForm() {
  const router = useRouter()
  const { goBack } = useNavigationHistory()
  const searchParams = useSearchParams()
  const preselectedEmployeeId = searchParams.get('employeeId')

  const [submitting, setSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [employees, setEmployees] = useState<Employee[]>([])
  const [loadingEmployees, setLoadingEmployees] = useState(true)
  const [selectedViolationType, setSelectedViolationType] = useState('')

  useEffect(() => {
    async function loadEmployees() {
      try {
        // Only load employees the current user can manage
        const data = await EmployeesApi.listManageable()
        setEmployees(data.items || [])
      } catch (e) {
        console.error('Failed to load manageable employees:', e)
      } finally {
        setLoadingEmployees(false)
      }
    }
    loadEmployees()
  }, [])

  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault()
    setSubmitting(true)
    setError(null)
    const fd = new FormData(e.currentTarget)
    const payload = Object.fromEntries(fd.entries()) as any

    try {
      await DisciplinaryActionsApi.create({
        employeeId: String(payload.employeeId),
        violationType: String(payload.violationType),
        violationReason: String(payload.violationReason),
        severity: String(payload.severity),
        incidentDate: String(payload.incidentDate),
        reportedBy: String(payload.reportedBy),
        description: String(payload.description),
        witnesses: payload.witnesses || null,
        evidence: payload.evidence || null,
        actionTaken: String(payload.actionTaken),
        actionDate: payload.actionDate || null,
        actionDetails: payload.actionDetails || null,
        followUpDate: payload.followUpDate || null,
        followUpNotes: payload.followUpNotes || null,
        status: String(payload.status),
        resolution: payload.resolution || null,
      })
      router.push('/performance/disciplinary')
    } catch (e: any) {
      setError(e.message || 'Failed to create disciplinary record')
    } finally {
      setSubmitting(false)
    }
  }

  const employeeOptions = employees.map((e) => ({
    value: e.id,
    label: `${e.firstName} ${e.lastName} (${e.employeeId})`,
  }))

  const reasonOptions = selectedViolationType
    ? violationReasonOptions[selectedViolationType] || [{ value: 'OTHER', label: 'Other' }]
    : [{ value: '', label: 'Select violation type first' }]

  return (
    <Card padding="lg">
      {error && (
        <Alert variant="error" className="mb-6" onDismiss={() => setError(null)}>
          {error}
        </Alert>
      )}

      <form onSubmit={onSubmit} className="space-y-8">
        <FormSection title="Incident Details">
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
            <div className="sm:col-span-2">
              <SelectField
                label="Employee"
                name="employeeId"
                required
                options={employeeOptions}
                placeholder={loadingEmployees ? 'Loading employees...' : 'Select employee...'}
                defaultValue={preselectedEmployeeId || undefined}
              />
            </div>
            <SelectField
              label="Violation Type"
              name="violationType"
              required
              options={violationTypeOptions}
              placeholder="Select type..."
              onChange={(e) => setSelectedViolationType(e.target.value)}
            />
            <SelectField
              label="Specific Reason"
              name="violationReason"
              required
              options={reasonOptions}
              placeholder="Select reason..."
            />
            <SelectField
              label="Severity"
              name="severity"
              required
              options={severityOptions}
              defaultValue="MODERATE"
            />
            <FormField
              label="Incident Date"
              name="incidentDate"
              type="date"
              required
            />
            <FormField
              label="Reported By"
              name="reportedBy"
              required
              placeholder="Manager or witness name"
            />
            <SelectField
              label="Status"
              name="status"
              required
              options={statusOptions}
              defaultValue="OPEN"
            />
          </div>
        </FormSection>

        <CardDivider />

        <FormSection title="Incident Description">
          <div className="space-y-5">
            <TextareaField
              label="Description"
              name="description"
              required
              rows={4}
              placeholder="Detailed description of the incident..."
            />
            <FormField
              label="Witnesses"
              name="witnesses"
              placeholder="Names of witnesses (if any)"
            />
            <FormField
              label="Evidence"
              name="evidence"
              placeholder="Reference to evidence (file names, locations)"
            />
          </div>
        </FormSection>

        <CardDivider />

        <FormSection title="Action Taken">
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
            <SelectField
              label="Action Type"
              name="actionTaken"
              required
              options={actionTypeOptions}
              defaultValue="VERBAL_WARNING"
            />
            <FormField
              label="Action Date"
              name="actionDate"
              type="date"
            />
            <div className="sm:col-span-2">
              <TextareaField
                label="Action Details"
                name="actionDetails"
                rows={3}
                placeholder="Details of the disciplinary action taken..."
              />
            </div>
          </div>
        </FormSection>

        <CardDivider />

        <FormSection title="Follow-up">
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
            <FormField
              label="Follow-up Date"
              name="followUpDate"
              type="date"
            />
            <div className="sm:col-span-2">
              <TextareaField
                label="Follow-up Notes"
                name="followUpNotes"
                rows={2}
                placeholder="Notes for follow-up review..."
              />
            </div>
            <div className="sm:col-span-2">
              <TextareaField
                label="Resolution"
                name="resolution"
                rows={2}
                placeholder="Final resolution (if closed)..."
              />
            </div>
          </div>
        </FormSection>

        <FormActions>
          <Button variant="secondary" onClick={goBack}>
            Cancel
          </Button>
          <Button type="submit" loading={submitting}>
            {submitting ? 'Saving...' : 'Save Record'}
          </Button>
        </FormActions>
      </form>
    </Card>
  )
}

export default function AddDisciplinaryPage() {
  return (
    <>
      <PageHeader
        title="Report Violation"
        description="Disciplinary"
        icon={<ShieldExclamationIcon className="h-6 w-6 text-white" />}
        showBack
      />

      <div className="max-w-3xl">
        <Suspense fallback={
          <Card padding="lg">
            <div className="animate-pulse space-y-6">
              <div className="h-4 bg-slate-200 rounded w-1/4" />
              <div className="h-10 bg-slate-200 rounded" />
              <div className="h-4 bg-slate-200 rounded w-1/4" />
              <div className="h-10 bg-slate-200 rounded" />
            </div>
          </Card>
        }>
          <AddDisciplinaryForm />
        </Suspense>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/performance/reviews/add/page.tsx">
'use client'

import { useState, useEffect, Suspense } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { PerformanceReviewsApi, EmployeesApi, type Employee } from '@/lib/api-client'
import { ClipboardDocumentCheckIcon, StarIcon, StarFilledIcon } from '@/components/ui/Icons'
import { PageHeader } from '@/components/ui/PageHeader'
import { Card, CardDivider } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import {
  FormField,
  SelectField,
  TextareaField,
  FormSection,
  FormActions,
} from '@/components/ui/FormField'
import { useNavigationHistory } from '@/lib/navigation-history'

const reviewTypeOptions = [
  { value: 'PROBATION', label: 'Probation (90-day)' },
  { value: 'QUARTERLY', label: 'Quarterly' },
  { value: 'SEMI_ANNUAL', label: 'Semi-Annual' },
  { value: 'ANNUAL', label: 'Annual' },
  { value: 'PROMOTION', label: 'Promotion' },
  { value: 'PIP', label: 'Performance Improvement Plan' },
]

const statusOptions = [
  { value: 'DRAFT', label: 'Draft' },
  { value: 'PENDING_REVIEW', label: 'Pending Review' },
  { value: 'COMPLETED', label: 'Completed' },
  { value: 'ACKNOWLEDGED', label: 'Acknowledged' },
]

function RatingInput({ name, label, value, onChange }: { name: string; label: string; value: number; onChange: (v: number) => void }) {
  return (
    <div>
      <label className="block text-sm font-medium text-slate-700 mb-1.5">{label}</label>
      <div className="flex items-center gap-1">
        {[1, 2, 3, 4, 5].map((star) => (
          <button
            key={star}
            type="button"
            onClick={() => onChange(star)}
            className="p-1 hover:scale-110 transition-transform"
          >
            {star <= value ? (
              <StarFilledIcon className="h-6 w-6 text-amber-400" />
            ) : (
              <StarIcon className="h-6 w-6 text-slate-300 hover:text-amber-300" />
            )}
          </button>
        ))}
        <span className="ml-2 text-sm text-slate-500">{value}/5</span>
      </div>
      <input type="hidden" name={name} value={value} />
    </div>
  )
}

function AddReviewForm() {
  const router = useRouter()
  const { goBack } = useNavigationHistory()
  const searchParams = useSearchParams()
  const preselectedEmployeeId = searchParams.get('employeeId')

  const [submitting, setSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [employees, setEmployees] = useState<Employee[]>([])
  const [loadingEmployees, setLoadingEmployees] = useState(true)

  // Rating states
  const [overallRating, setOverallRating] = useState(3)
  const [qualityOfWork, setQualityOfWork] = useState(3)
  const [productivity, setProductivity] = useState(3)
  const [communication, setCommunication] = useState(3)
  const [teamwork, setTeamwork] = useState(3)
  const [initiative, setInitiative] = useState(3)
  const [attendance, setAttendance] = useState(3)

  useEffect(() => {
    async function loadEmployees() {
      try {
        // Only load employees the current user can manage
        const data = await EmployeesApi.listManageable()
        setEmployees(data.items || [])
      } catch (e) {
        console.error('Failed to load manageable employees:', e)
      } finally {
        setLoadingEmployees(false)
      }
    }
    loadEmployees()
  }, [])

  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault()
    setSubmitting(true)
    setError(null)
    const fd = new FormData(e.currentTarget)
    const payload = Object.fromEntries(fd.entries()) as any

    try {
      await PerformanceReviewsApi.create({
        employeeId: String(payload.employeeId),
        reviewType: String(payload.reviewType),
        reviewPeriod: String(payload.reviewPeriod),
        reviewDate: String(payload.reviewDate),
        reviewerName: String(payload.reviewerName),
        overallRating: parseInt(payload.overallRating, 10),
        qualityOfWork: parseInt(payload.qualityOfWork, 10),
        productivity: parseInt(payload.productivity, 10),
        communication: parseInt(payload.communication, 10),
        teamwork: parseInt(payload.teamwork, 10),
        initiative: parseInt(payload.initiative, 10),
        attendance: parseInt(payload.attendance, 10),
        strengths: payload.strengths || null,
        areasToImprove: payload.areasToImprove || null,
        goals: payload.goals || null,
        comments: payload.comments || null,
        status: String(payload.status),
      })
      router.push('/performance/reviews')
    } catch (e: any) {
      setError(e.message || 'Failed to create review')
    } finally {
      setSubmitting(false)
    }
  }

  const employeeOptions = employees.map((e) => ({
    value: e.id,
    label: `${e.firstName} ${e.lastName} (${e.employeeId})`,
  }))

  return (
    <Card padding="lg">
      {error && (
        <Alert variant="error" className="mb-6" onDismiss={() => setError(null)}>
          {error}
        </Alert>
      )}

      <form onSubmit={onSubmit} className="space-y-8">
        <FormSection title="Review Details">
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
            <div className="sm:col-span-2">
              <SelectField
                label="Employee"
                name="employeeId"
                required
                options={employeeOptions}
                placeholder={loadingEmployees ? 'Loading employees...' : 'Select employee...'}
                defaultValue={preselectedEmployeeId || undefined}
              />
            </div>
            <SelectField
              label="Review Type"
              name="reviewType"
              required
              options={reviewTypeOptions}
              defaultValue="ANNUAL"
            />
            <FormField
              label="Review Period"
              name="reviewPeriod"
              required
              placeholder="e.g., Q4 2025, Annual 2025"
            />
            <FormField
              label="Review Date"
              name="reviewDate"
              type="date"
              required
            />
            <FormField
              label="Reviewer Name"
              name="reviewerName"
              required
              placeholder="Manager name"
            />
            <SelectField
              label="Status"
              name="status"
              required
              options={statusOptions}
              defaultValue="DRAFT"
            />
          </div>
        </FormSection>

        <CardDivider />

        <FormSection title="Performance Ratings" description="Rate the employee on a scale of 1-5">
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
            <div className="sm:col-span-2">
              <RatingInput name="overallRating" label="Overall Rating" value={overallRating} onChange={setOverallRating} />
            </div>
            <RatingInput name="qualityOfWork" label="Quality of Work" value={qualityOfWork} onChange={setQualityOfWork} />
            <RatingInput name="productivity" label="Productivity" value={productivity} onChange={setProductivity} />
            <RatingInput name="communication" label="Communication" value={communication} onChange={setCommunication} />
            <RatingInput name="teamwork" label="Teamwork" value={teamwork} onChange={setTeamwork} />
            <RatingInput name="initiative" label="Initiative" value={initiative} onChange={setInitiative} />
            <RatingInput name="attendance" label="Attendance" value={attendance} onChange={setAttendance} />
          </div>
        </FormSection>

        <CardDivider />

        <FormSection title="Feedback" description="Detailed comments and goals">
          <div className="space-y-5">
            <TextareaField
              label="Strengths"
              name="strengths"
              rows={3}
              placeholder="Key strengths demonstrated..."
            />
            <TextareaField
              label="Areas to Improve"
              name="areasToImprove"
              rows={3}
              placeholder="Areas that need development..."
            />
            <TextareaField
              label="Goals for Next Period"
              name="goals"
              rows={3}
              placeholder="Objectives and targets..."
            />
            <TextareaField
              label="Additional Comments"
              name="comments"
              rows={3}
              placeholder="Any other observations..."
            />
          </div>
        </FormSection>

        <FormActions>
          <Button variant="secondary" onClick={goBack}>
            Cancel
          </Button>
          <Button type="submit" loading={submitting}>
            {submitting ? 'Saving...' : 'Save Review'}
          </Button>
        </FormActions>
      </form>
    </Card>
  )
}

export default function AddReviewPage() {
  return (
    <>
      <PageHeader
        title="New Performance Review"
        description="Performance"
        icon={<ClipboardDocumentCheckIcon className="h-6 w-6 text-white" />}
        showBack
      />

      <div className="max-w-3xl">
        <Suspense fallback={
          <Card padding="lg">
            <div className="animate-pulse space-y-6">
              <div className="h-4 bg-slate-200 rounded w-1/4" />
              <div className="h-10 bg-slate-200 rounded" />
              <div className="h-4 bg-slate-200 rounded w-1/4" />
              <div className="h-10 bg-slate-200 rounded" />
            </div>
          </Card>
        }>
          <AddReviewForm />
        </Suspense>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/app/(hrms)/policies/[id]/edit/page.tsx">
'use client'

import { useEffect, useState } from 'react'
import { useRouter, useParams } from 'next/navigation'
import { PoliciesApi, type Policy } from '@/lib/api-client'
import { DocumentIcon } from '@/components/ui/Icons'
import { PageHeader } from '@/components/ui/PageHeader'
import { Card, CardDivider } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import {
  FormField,
  SelectField,
  TextareaField,
  FormSection,
  FormActions,
} from '@/components/ui/FormField'
import { useNavigationHistory } from '@/lib/navigation-history'

const categoryOptions = [
  { value: 'LEAVE', label: 'Leave' },
  { value: 'PERFORMANCE', label: 'Performance' },
  { value: 'CONDUCT', label: 'Conduct' },
  { value: 'SECURITY', label: 'Security' },
  { value: 'COMPENSATION', label: 'Compensation' },
  { value: 'OTHER', label: 'Other' },
]

const regionOptions = [
  { value: 'ALL', label: 'All Regions' },
  { value: 'KANSAS_US', label: 'US (Kansas)' },
  { value: 'PAKISTAN', label: 'Pakistan' },
]

const statusOptions = [
  { value: 'DRAFT', label: 'Draft' },
  { value: 'ACTIVE', label: 'Active' },
  { value: 'ARCHIVED', label: 'Archived' },
]

function getNextVersions(current: string): { minor: string; major: string } {
  const match = current.match(/^(\d+)\.(\d+)$/)
  if (!match) return { minor: '1.1', major: '2.0' }
  const major = parseInt(match[1], 10)
  const minor = parseInt(match[2], 10)
  return {
    minor: `${major}.${minor + 1}`,
    major: `${major + 1}.0`,
  }
}

export default function EditPolicyPage() {
  const router = useRouter()
  const { goBack } = useNavigationHistory()
  const params = useParams()
  const id = params.id as string

  const [policy, setPolicy] = useState<Policy | null>(null)
  const [loading, setLoading] = useState(true)
  const [submitting, setSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    async function load() {
      try {
        const data = await PoliciesApi.get(id)
        setPolicy(data)
      } catch (e: any) {
        setError(e.message || 'Failed to load policy')
      } finally {
        setLoading(false)
      }
    }
    load()
  }, [id])

  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault()
    setSubmitting(true)
    setError(null)
    const fd = new FormData(e.currentTarget)
    const payload = Object.fromEntries(fd.entries()) as any

    // Validate version bump is selected
    if (!payload.newVersion) {
      setError('You must select a new version when updating a policy')
      setSubmitting(false)
      return
    }

    try {
      await PoliciesApi.update(id, {
        title: String(payload.title),
        category: String(payload.category),
        region: String(payload.region),
        status: String(payload.status),
        version: String(payload.newVersion),
        effectiveDate: payload.effectiveDate ? String(payload.effectiveDate) : undefined,
        summary: payload.summary ? String(payload.summary) : undefined,
        content: payload.content ? String(payload.content) : undefined,
      })
      router.push(`/policies/${id}`)
    } catch (e: any) {
      setError(e.message || 'Failed to update policy')
    } finally {
      setSubmitting(false)
    }
  }

  if (loading) {
    return (
      <>
        <PageHeader
          title="Edit Policy"
          description="Company Policies"
          icon={<DocumentIcon className="h-6 w-6 text-white" />}
          showBack
        />
        <div className="max-w-3xl">
          <Card padding="lg">
            <div className="animate-pulse space-y-6">
              <div className="h-4 bg-slate-200 rounded w-1/4" />
              <div className="h-10 bg-slate-200 rounded" />
              <div className="h-4 bg-slate-200 rounded w-1/4" />
              <div className="h-10 bg-slate-200 rounded" />
            </div>
          </Card>
        </div>
      </>
    )
  }

  if (!policy) {
    return (
      <>
        <PageHeader
          title="Edit Policy"
          description="Company Policies"
          icon={<DocumentIcon className="h-6 w-6 text-white" />}
          showBack
        />
        <div className="max-w-3xl">
          <Card padding="lg">
            <Alert variant="error">{error || 'Policy not found'}</Alert>
          </Card>
        </div>
      </>
    )
  }

  const effectiveDateFormatted = policy.effectiveDate ? policy.effectiveDate.split('T')[0] : ''

  return (
    <>
      <PageHeader
        title="Edit Policy"
        description="Company Policies"
        icon={<DocumentIcon className="h-6 w-6 text-white" />}
        showBack
      />

      <div className="max-w-3xl">
        <Card padding="lg">
          {error && (
            <Alert variant="error" className="mb-6" onDismiss={() => setError(null)}>
              {error}
            </Alert>
          )}

          <form onSubmit={onSubmit} className="space-y-8">
            {/* Basic Info */}
            <FormSection title="Policy Information">
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
                <div className="sm:col-span-2">
                  <FormField
                    label="Policy Title"
                    name="title"
                    required
                    defaultValue={policy.title}
                  />
                </div>
                <SelectField
                  label="Category"
                  name="category"
                  required
                  options={categoryOptions}
                  defaultValue={policy.category}
                />
                <SelectField
                  label="Region"
                  name="region"
                  required
                  options={regionOptions}
                  defaultValue={policy.region}
                />
                <SelectField
                  label="Status"
                  name="status"
                  required
                  options={statusOptions}
                  defaultValue={policy.status}
                />
                <div>
                  <label className="block text-sm font-medium text-slate-700 mb-1.5">
                    Current Version
                  </label>
                  <div className="px-3 py-2 bg-slate-100 border border-slate-200 rounded-lg text-sm text-slate-600">
                    v{policy.version}
                  </div>
                </div>
                <SelectField
                  label="New Version"
                  name="newVersion"
                  required
                  options={[
                    { value: getNextVersions(policy.version).minor, label: `v${getNextVersions(policy.version).minor} (Minor update)` },
                    { value: getNextVersions(policy.version).major, label: `v${getNextVersions(policy.version).major} (Major update)` },
                  ]}
                  placeholder="Select new version..."
                />
                <FormField
                  label="Effective Date"
                  name="effectiveDate"
                  type="date"
                  defaultValue={effectiveDateFormatted}
                />
              </div>
            </FormSection>

            <CardDivider />

            {/* Summary */}
            <FormSection title="Summary" description="Brief overview of the policy">
              <TextareaField
                label="Summary"
                name="summary"
                rows={3}
                defaultValue={policy.summary || ''}
                placeholder="A brief summary of what this policy covers..."
                resizable={false}
              />
            </FormSection>

            <CardDivider />

            {/* Content */}
            <FormSection title="Policy Content" description="Full policy text">
              <TextareaField
                label="Content"
                name="content"
                rows={16}
                monospace
                defaultValue={policy.content || ''}
                placeholder="Full policy content..."
              />
            </FormSection>

            {/* Actions */}
            <FormActions>
              <Button variant="secondary" onClick={goBack}>
                Cancel
              </Button>
              <Button type="submit" loading={submitting}>
                {submitting ? 'Saving...' : 'Save Changes'}
              </Button>
            </FormActions>
          </form>
        </Card>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/lib/validations.ts">
import { z } from 'zod'

// Shared constants
export const MAX_PAGINATION_LIMIT = 100
export const DEFAULT_PAGINATION_LIMIT = 50

// Employee schemas
export const EmploymentTypeEnum = z.enum(['FULL_TIME', 'PART_TIME', 'CONTRACT', 'INTERN', 'WORKING_PARTNER'])
export const EmployeeStatusEnum = z.enum(['ACTIVE', 'ON_LEAVE', 'TERMINATED', 'RESIGNED'])

export const CreateEmployeeSchema = z.object({
  employeeId: z.string().min(1).max(50).trim().optional(),
  firstName: z.string().min(1).max(100).trim(),
  lastName: z.string().min(1).max(100).trim(),
  email: z.string().email().max(255).trim().toLowerCase(),
  phone: z.string().max(50).trim().optional().nullable(),
  department: z.string().max(100).trim().optional().default('General'),
  departmentName: z.string().max(100).trim().optional(),
  position: z.string().min(1).max(100).trim(),
  employmentType: EmploymentTypeEnum.default('FULL_TIME'),
  joinDate: z.string().refine((val) => !isNaN(Date.parse(val)), {
    message: 'Invalid date format',
  }),
  status: EmployeeStatusEnum.default('ACTIVE'),
  roles: z.array(z.string().max(100)).max(20).optional(),
})

export const UpdateEmployeeSchema = z.object({
  firstName: z.string().min(1).max(100).trim().optional(),
  lastName: z.string().min(1).max(100).trim().optional(),
  email: z.string().email().max(255).trim().toLowerCase().optional(),
  phone: z.string().max(50).trim().optional().nullable(),
  department: z.string().max(100).trim().optional(),
  departmentName: z.string().max(100).trim().optional(),
  position: z.string().min(1).max(100).trim().optional(),
  employmentType: EmploymentTypeEnum.optional(),
  joinDate: z.string().refine((val) => !isNaN(Date.parse(val)), {
    message: 'Invalid date format',
  }).optional(),
  status: EmployeeStatusEnum.optional(),
  roles: z.array(z.string().max(100)).max(20).optional(),
  // Hierarchy
  reportsToId: z.string().max(100).optional().nullable(),
  // Personal info
  dateOfBirth: z.string().refine((val) => !isNaN(Date.parse(val)), {
    message: 'Invalid date format',
  }).optional().nullable(),
  gender: z.string().max(50).trim().optional().nullable(),
  maritalStatus: z.string().max(50).trim().optional().nullable(),
  nationality: z.string().max(100).trim().optional().nullable(),
  address: z.string().max(500).trim().optional().nullable(),
  city: z.string().max(100).trim().optional().nullable(),
  country: z.string().max(100).trim().optional().nullable(),
  postalCode: z.string().max(20).trim().optional().nullable(),
  emergencyContact: z.string().max(100).trim().optional().nullable(),
  emergencyPhone: z.string().max(50).trim().optional().nullable(),
  // Salary
  salary: z.number().min(0).optional().nullable(),
  currency: z.string().max(10).trim().optional(),
})

// Resource schemas
export const ResourceCategoryEnum = z.enum(['ACCOUNTING', 'LEGAL', 'DESIGN', 'MARKETING', 'IT', 'HR', 'OTHER'])

export const CreateResourceSchema = z.object({
  name: z.string().min(1).max(200).trim(),
  category: ResourceCategoryEnum,
  subcategory: z.string().max(100).trim().optional().nullable(),
  email: z.string().email().max(255).trim().optional().nullable(),
  phone: z.string().max(50).trim().optional().nullable(),
  website: z.string().url().max(500).optional().nullable(),
  description: z.string().max(2000).trim().optional().nullable(),
  rating: z.number().min(0).max(5).optional().nullable(),
})

export const UpdateResourceSchema = z.object({
  name: z.string().min(1).max(200).trim().optional(),
  category: ResourceCategoryEnum.optional(),
  subcategory: z.string().max(100).trim().optional().nullable(),
  email: z.string().email().max(255).trim().optional().nullable(),
  phone: z.string().max(50).trim().optional().nullable(),
  website: z.string().url().max(500).optional().nullable(),
  description: z.string().max(2000).trim().optional().nullable(),
  rating: z.number().min(0).max(5).optional().nullable(),
})

// Policy schemas
export const PolicyCategoryEnum = z.enum(['LEAVE', 'PERFORMANCE', 'CONDUCT', 'SECURITY', 'COMPENSATION', 'OTHER'])
export const PolicyStatusEnum = z.enum(['DRAFT', 'ACTIVE', 'ARCHIVED'])
export const RegionEnum = z.enum(['ALL', 'KANSAS_US', 'PAKISTAN'])

// Version format: major.minor (e.g., "1.0", "2.3")
export const VersionSchema = z.string().regex(/^\d+\.\d+$/, {
  message: 'Version must be in format X.Y (e.g., 1.0, 2.3)',
})

export function bumpVersion(current: string, type: 'major' | 'minor' = 'minor'): string {
  const match = current.match(/^(\d+)\.(\d+)$/)
  if (!match) return '1.0'
  const major = parseInt(match[1], 10)
  const minor = parseInt(match[2], 10)
  if (type === 'major') return `${major + 1}.0`
  return `${major}.${minor + 1}`
}

export const CreatePolicySchema = z.object({
  title: z.string().min(1).max(200).trim(),
  category: PolicyCategoryEnum,
  region: RegionEnum,
  summary: z.string().max(1000).trim().optional().nullable(),
  content: z.string().max(50000).optional().nullable(),
  fileUrl: z.string().url().max(500).optional().nullable(),
  version: VersionSchema.default('1.0'),
  effectiveDate: z.string().refine((val) => !isNaN(Date.parse(val)), {
    message: 'Invalid date format',
  }).optional().nullable(),
  status: PolicyStatusEnum.default('ACTIVE'),
})

export const UpdatePolicySchema = z.object({
  title: z.string().min(1).max(200).trim().optional(),
  category: PolicyCategoryEnum.optional(),
  region: RegionEnum.optional(),
  summary: z.string().max(1000).trim().optional().nullable(),
  content: z.string().max(50000).optional().nullable(),
  fileUrl: z.string().url().max(500).optional().nullable(),
  version: VersionSchema.optional(),
  bumpVersion: z.enum(['major', 'minor']).optional(),
  effectiveDate: z.string().refine((val) => !isNaN(Date.parse(val)), {
    message: 'Invalid date format',
  }).optional().nullable(),
  status: PolicyStatusEnum.optional(),
})

// Calendar event schema (Google Calendar format)
export const CreateCalendarEventSchema = z.object({
  summary: z.string().min(1).max(200).trim(),
  description: z.string().max(2000).trim().optional(),
  location: z.string().max(500).trim().optional(),
  start: z.object({
    dateTime: z.string(),
    timeZone: z.string().optional(),
  }),
  end: z.object({
    dateTime: z.string(),
    timeZone: z.string().optional(),
  }),
})

// ============ PERFORMANCE REVIEW SCHEMAS ============
export const ReviewTypeEnum = z.enum(['PROBATION', 'QUARTERLY', 'SEMI_ANNUAL', 'ANNUAL', 'PROMOTION', 'PIP'])
export const ReviewStatusEnum = z.enum(['DRAFT', 'PENDING_REVIEW', 'COMPLETED', 'ACKNOWLEDGED'])

const RatingSchema = z.coerce.number().int().min(1).max(5)

export const CreatePerformanceReviewSchema = z.object({
  employeeId: z.string().min(1).max(100),
  reviewType: ReviewTypeEnum,
  reviewPeriod: z.string().min(1).max(50).trim(),
  reviewDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }),
  reviewerName: z.string().min(1).max(100).trim(),
  overallRating: RatingSchema,
  qualityOfWork: RatingSchema.optional().nullable(),
  productivity: RatingSchema.optional().nullable(),
  communication: RatingSchema.optional().nullable(),
  teamwork: RatingSchema.optional().nullable(),
  initiative: RatingSchema.optional().nullable(),
  attendance: RatingSchema.optional().nullable(),
  strengths: z.string().max(2000).trim().optional().nullable(),
  areasToImprove: z.string().max(2000).trim().optional().nullable(),
  goals: z.string().max(2000).trim().optional().nullable(),
  comments: z.string().max(5000).trim().optional().nullable(),
  status: ReviewStatusEnum.default('DRAFT'),
})

export const UpdatePerformanceReviewSchema = z.object({
  reviewType: ReviewTypeEnum.optional(),
  reviewPeriod: z.string().min(1).max(50).trim().optional(),
  reviewDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }).optional(),
  reviewerName: z.string().min(1).max(100).trim().optional(),
  overallRating: RatingSchema.optional(),
  qualityOfWork: RatingSchema.optional().nullable(),
  productivity: RatingSchema.optional().nullable(),
  communication: RatingSchema.optional().nullable(),
  teamwork: RatingSchema.optional().nullable(),
  initiative: RatingSchema.optional().nullable(),
  attendance: RatingSchema.optional().nullable(),
  strengths: z.string().max(2000).trim().optional().nullable(),
  areasToImprove: z.string().max(2000).trim().optional().nullable(),
  goals: z.string().max(2000).trim().optional().nullable(),
  comments: z.string().max(5000).trim().optional().nullable(),
  status: ReviewStatusEnum.optional(),
})

// ============ DISCIPLINARY ACTION SCHEMAS ============
export const ViolationTypeEnum = z.enum([
  'ATTENDANCE', 'CONDUCT', 'PERFORMANCE', 'POLICY_VIOLATION', 'SAFETY',
  'HARASSMENT', 'INSUBORDINATION', 'THEFT_FRAUD', 'SUBSTANCE_ABUSE', 'OTHER'
])

export const ViolationReasonEnum = z.enum([
  'EXCESSIVE_ABSENCES', 'TARDINESS', 'UNAUTHORIZED_LEAVE', 'NO_CALL_NO_SHOW',
  'UNPROFESSIONAL_BEHAVIOR', 'DISRUPTIVE_CONDUCT', 'INAPPROPRIATE_LANGUAGE', 'DRESS_CODE_VIOLATION',
  'POOR_QUALITY_WORK', 'MISSED_DEADLINES', 'FAILURE_TO_FOLLOW_INSTRUCTIONS', 'NEGLIGENCE',
  'CONFIDENTIALITY_BREACH', 'DATA_SECURITY_VIOLATION', 'EXPENSE_POLICY_VIOLATION', 'IT_POLICY_VIOLATION',
  'SAFETY_PROTOCOL_VIOLATION', 'EQUIPMENT_MISUSE',
  'HARASSMENT_DISCRIMINATION', 'WORKPLACE_VIOLENCE', 'THEFT', 'FRAUD', 'FALSIFICATION', 'SUBSTANCE_USE_AT_WORK',
  'OTHER'
])

export const ViolationSeverityEnum = z.enum(['MINOR', 'MODERATE', 'MAJOR', 'CRITICAL'])

export const DisciplinaryActionTypeEnum = z.enum([
  'VERBAL_WARNING', 'WRITTEN_WARNING', 'FINAL_WARNING', 'SUSPENSION',
  'DEMOTION', 'TERMINATION', 'PIP', 'TRAINING_REQUIRED', 'NO_ACTION'
])

export const DisciplinaryStatusEnum = z.enum([
  'OPEN', 'UNDER_INVESTIGATION', 'ACTION_TAKEN', 'APPEALED', 'CLOSED', 'DISMISSED'
])

export const CreateDisciplinaryActionSchema = z.object({
  employeeId: z.string().min(1).max(100),
  violationType: ViolationTypeEnum,
  violationReason: ViolationReasonEnum,
  severity: ViolationSeverityEnum,
  incidentDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }),
  reportedBy: z.string().min(1).max(100).trim(),
  description: z.string().min(1).max(5000).trim(),
  witnesses: z.string().max(1000).trim().optional().nullable(),
  evidence: z.string().max(2000).trim().optional().nullable(),
  actionTaken: DisciplinaryActionTypeEnum,
  actionDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }).optional().nullable(),
  actionDetails: z.string().max(2000).trim().optional().nullable(),
  followUpDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }).optional().nullable(),
  followUpNotes: z.string().max(2000).trim().optional().nullable(),
  status: DisciplinaryStatusEnum.default('OPEN'),
  resolution: z.string().max(2000).trim().optional().nullable(),
})

export const UpdateDisciplinaryActionSchema = z.object({
  violationType: ViolationTypeEnum.optional(),
  violationReason: ViolationReasonEnum.optional(),
  severity: ViolationSeverityEnum.optional(),
  incidentDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }).optional(),
  reportedBy: z.string().min(1).max(100).trim().optional(),
  description: z.string().min(1).max(5000).trim().optional(),
  witnesses: z.string().max(1000).trim().optional().nullable(),
  evidence: z.string().max(2000).trim().optional().nullable(),
  actionTaken: DisciplinaryActionTypeEnum.optional(),
  actionDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }).optional().nullable(),
  actionDetails: z.string().max(2000).trim().optional().nullable(),
  followUpDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }).optional().nullable(),
  followUpNotes: z.string().max(2000).trim().optional().nullable(),
  status: DisciplinaryStatusEnum.optional(),
  resolution: z.string().max(2000).trim().optional().nullable(),
})

// ============ HR CALENDAR EVENT SCHEMAS ============
export const HREventTypeEnum = z.enum([
  'PERFORMANCE_REVIEW', 'PROBATION_END', 'PIP_REVIEW', 'DISCIPLINARY_HEARING',
  'INTERVIEW', 'ONBOARDING', 'TRAINING', 'COMPANY_EVENT', 'HOLIDAY', 'OTHER'
])

export const CreateHRCalendarEventSchema = z.object({
  title: z.string().min(1).max(200).trim(),
  description: z.string().max(2000).trim().optional().nullable(),
  eventType: HREventTypeEnum,
  startDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }),
  endDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }).optional().nullable(),
  allDay: z.boolean().default(true),
  employeeId: z.string().max(100).optional().nullable(),
  relatedRecordId: z.string().max(100).optional().nullable(),
  relatedRecordType: z.string().max(50).optional().nullable(),
})

export const UpdateHRCalendarEventSchema = z.object({
  title: z.string().min(1).max(200).trim().optional(),
  description: z.string().max(2000).trim().optional().nullable(),
  eventType: HREventTypeEnum.optional(),
  startDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }).optional(),
  endDate: z.string().refine((val) => !isNaN(Date.parse(val)), { message: 'Invalid date format' }).optional().nullable(),
  allDay: z.boolean().optional(),
  employeeId: z.string().max(100).optional().nullable(),
  relatedRecordId: z.string().max(100).optional().nullable(),
  relatedRecordType: z.string().max(50).optional().nullable(),
})

// Pagination schema
export const PaginationSchema = z.object({
  take: z.coerce.number().int().min(1).max(MAX_PAGINATION_LIMIT).default(DEFAULT_PAGINATION_LIMIT),
  skip: z.coerce.number().int().min(0).default(0),
  q: z.string().max(200).optional(),
})

// Type exports
export type CreateEmployeeInput = z.infer<typeof CreateEmployeeSchema>
export type UpdateEmployeeInput = z.infer<typeof UpdateEmployeeSchema>
export type CreateResourceInput = z.infer<typeof CreateResourceSchema>
export type UpdateResourceInput = z.infer<typeof UpdateResourceSchema>
export type CreatePolicyInput = z.infer<typeof CreatePolicySchema>
export type UpdatePolicyInput = z.infer<typeof UpdatePolicySchema>
export type CreateCalendarEventInput = z.infer<typeof CreateCalendarEventSchema>
export type PaginationInput = z.infer<typeof PaginationSchema>
</file>

<file path="apps/hrms/app/api/employees/[id]/route.ts">
import { NextResponse } from 'next/server'
import prisma from '../../../../lib/prisma'
import { UpdateEmployeeSchema } from '@/lib/validations'
import { withRateLimit, validateBody, safeErrorResponse } from '@/lib/api-helpers'
import { EmploymentType, EmployeeStatus } from '@/lib/hrms-prisma-types'
import { checkAndNotifyMissingFields } from '@/lib/notification-service'

type EmployeeRouteContext = { params: Promise<{ id: string }> }

export async function GET(req: Request, context: EmployeeRouteContext) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const e = await prisma.employee.findFirst({
      where: { OR: [{ id }, { employeeId: id }] },
      include: { roles: true, dept: true, manager: { select: { id: true, firstName: true, lastName: true, position: true } } },
    })

    if (!e) {
      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    return NextResponse.json(e)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to fetch employee')
  }
}

export async function PATCH(req: Request, context: EmployeeRouteContext) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    const body = await req.json()

    // Validate input with whitelist schema
    const validation = validateBody(UpdateEmployeeSchema, body)
    if (!validation.success) {
      return validation.error
    }

    const data = validation.data
    const departmentName = data.department || data.departmentName
    const roles = data.roles

    // Build update object with explicit field whitelist
    const updates: Record<string, unknown> = {}

    if (data.firstName !== undefined) updates.firstName = data.firstName
    if (data.lastName !== undefined) updates.lastName = data.lastName
    if (data.email !== undefined) updates.email = data.email
    if (data.phone !== undefined) updates.phone = data.phone
    if (data.position !== undefined) {
      updates.position = data.position
      // Auto-set local override flag when position is manually updated
      updates.positionLocalOverride = true
    }
    if (data.employmentType !== undefined) updates.employmentType = data.employmentType as EmploymentType
    if (data.status !== undefined) updates.status = data.status as EmployeeStatus
    if (data.joinDate !== undefined) updates.joinDate = new Date(data.joinDate)

    // Hierarchy - use manager relation instead of reportsToId directly
    if (data.reportsToId !== undefined) {
      if (data.reportsToId) {
        updates.manager = { connect: { id: data.reportsToId } }
      } else {
        updates.manager = { disconnect: true }
      }
    }

    // Personal info
    if (data.dateOfBirth !== undefined) updates.dateOfBirth = data.dateOfBirth ? new Date(data.dateOfBirth) : null
    if (data.gender !== undefined) updates.gender = data.gender
    if (data.maritalStatus !== undefined) updates.maritalStatus = data.maritalStatus
    if (data.nationality !== undefined) updates.nationality = data.nationality
    if (data.address !== undefined) updates.address = data.address
    if (data.city !== undefined) updates.city = data.city
    if (data.country !== undefined) updates.country = data.country
    if (data.postalCode !== undefined) updates.postalCode = data.postalCode
    if (data.emergencyContact !== undefined) updates.emergencyContact = data.emergencyContact
    if (data.emergencyPhone !== undefined) updates.emergencyPhone = data.emergencyPhone

    // Salary
    if (data.salary !== undefined) updates.salary = data.salary
    if (data.currency !== undefined) updates.currency = data.currency

    // Handle department relationship
    if (departmentName) {
      updates.department = departmentName
      // Auto-set local override flag when department is manually updated
      updates.departmentLocalOverride = true
      updates.dept = {
        connectOrCreate: {
          where: { name: departmentName },
          create: { name: departmentName },
        },
      }
    }

    // Handle roles relationship
    if (roles !== undefined) {
      updates.roles = {
        set: [],
        connectOrCreate: roles.map((name) => ({
          where: { name },
          create: { name },
        })),
      }
    }

    const e = await prisma.employee.update({
      where: { id },
      data: updates,
      include: { roles: true, dept: true, manager: { select: { id: true, firstName: true, lastName: true, position: true } } },
    })

    // Re-check profile completion after update
    await checkAndNotifyMissingFields(id)

    return NextResponse.json(e)
  } catch (e) {
    return safeErrorResponse(e, 'Failed to update employee')
  }
}

export async function DELETE(req: Request, context: EmployeeRouteContext) {
  // Rate limiting
  const rateLimitError = withRateLimit(req)
  if (rateLimitError) return rateLimitError

  try {
    const { id } = await context.params

    if (!id || id.length > 100) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 })
    }

    await prisma.employee.delete({ where: { id } })
    return NextResponse.json({ ok: true })
  } catch (e) {
    return safeErrorResponse(e, 'Failed to delete employee')
  }
}
</file>

<file path="apps/hrms/app/(hrms)/employees/[id]/edit/page.tsx">
'use client'

import { useEffect, useState } from 'react'
import { useRouter, useParams } from 'next/navigation'
import { EmployeesApi, DepartmentsApi, ProjectsApi, type Employee, type Department, type Project, type EmployeeProjectMembership } from '@/lib/api-client'
import { UsersIcon, PlusIcon, XIcon } from '@/components/ui/Icons'
import { PageHeader } from '@/components/ui/PageHeader'
import { Card, CardDivider } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import {
  FormField,
  SelectField,
  FormSection,
  FormActions,
} from '@/components/ui/FormField'
import { useNavigationHistory } from '@/lib/navigation-history'
import { employmentTypeOptions, statusOptions } from '@/lib/constants'

export default function EditEmployeePage() {
  const router = useRouter()
  const { goBack } = useNavigationHistory()
  const params = useParams()
  const id = params.id as string

  const [employee, setEmployee] = useState<Employee | null>(null)
  const [allEmployees, setAllEmployees] = useState<Employee[]>([])
  const [departments, setDepartments] = useState<Department[]>([])
  const [projects, setProjects] = useState<Project[]>([])
  const [projectMemberships, setProjectMemberships] = useState<{ projectId: string; role: string }[]>([])
  const [loading, setLoading] = useState(true)
  const [submitting, setSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    async function load() {
      try {
        const [data, employeesRes, deptsRes, projectsRes, membershipsRes] = await Promise.all([
          EmployeesApi.get(id),
          EmployeesApi.list({ take: 200 }),
          DepartmentsApi.list(),
          ProjectsApi.list(),
          EmployeesApi.getProjectMemberships(id),
        ])
        setEmployee(data)
        setAllEmployees(employeesRes.items)
        setDepartments(deptsRes.items)
        setProjects(projectsRes.items)
        setProjectMemberships(
          membershipsRes.items.map((m) => ({
            projectId: m.project.id,
            role: m.role || '',
          }))
        )
      } catch (e: any) {
        setError(e.message || 'Failed to load employee')
      } finally {
        setLoading(false)
      }
    }
    load()
  }, [id])

  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault()
    setSubmitting(true)
    setError(null)
    const fd = new FormData(e.currentTarget)
    const payload = Object.fromEntries(fd.entries()) as any

    try {
      // Update employee info
      await EmployeesApi.update(id, {
        firstName: String(payload.firstName),
        lastName: String(payload.lastName),
        email: String(payload.email),
        phone: payload.phone ? String(payload.phone) : undefined,
        department: String(payload.department || ''),
        position: String(payload.position),
        joinDate: String(payload.joinDate),
        employmentType: String(payload.employmentType || 'FULL_TIME'),
        status: String(payload.status || 'ACTIVE'),
        reportsToId: payload.reportsToId ? String(payload.reportsToId) : null,
      })

      // Update project memberships
      await EmployeesApi.updateProjectMemberships(
        id,
        projectMemberships
          .filter((m) => m.projectId) // Only include valid memberships
          .map((m) => ({
            projectId: m.projectId,
            role: m.role || undefined,
          }))
      )

      router.push(`/employees/${id}`)
    } catch (e: any) {
      setError(e.message || 'Failed to update employee')
    } finally {
      setSubmitting(false)
    }
  }

  function addProjectMembership() {
    setProjectMemberships([...projectMemberships, { projectId: '', role: '' }])
  }

  function removeProjectMembership(index: number) {
    setProjectMemberships(projectMemberships.filter((_, i) => i !== index))
  }

  function updateProjectMembership(index: number, field: 'projectId' | 'role', value: string) {
    const updated = [...projectMemberships]
    updated[index] = { ...updated[index], [field]: value }
    setProjectMemberships(updated)
  }

  // Get projects not already assigned
  const availableProjects = (index: number) => {
    const assignedProjectIds = projectMemberships
      .filter((_, i) => i !== index)
      .map((m) => m.projectId)
    return projects.filter((p) => !assignedProjectIds.includes(p.id))
  }

  if (loading) {
    return (
      <>
        <PageHeader
          title="Edit Employee"
          description="People"
          icon={<UsersIcon className="h-6 w-6 text-white" />}
          showBack
        />
        <div className="max-w-3xl">
          <Card padding="lg">
            <div className="animate-pulse space-y-6">
              <div className="h-4 bg-slate-200 rounded w-1/4" />
              <div className="h-10 bg-slate-200 rounded" />
              <div className="h-4 bg-slate-200 rounded w-1/4" />
              <div className="h-10 bg-slate-200 rounded" />
            </div>
          </Card>
        </div>
      </>
    )
  }

  if (!employee) {
    return (
      <>
        <PageHeader
          title="Edit Employee"
          description="People"
          icon={<UsersIcon className="h-6 w-6 text-white" />}
          showBack
        />
        <div className="max-w-3xl">
          <Card padding="lg">
            <Alert variant="error">{error || 'Employee not found'}</Alert>
          </Card>
        </div>
      </>
    )
  }

  const joinDateFormatted = employee.joinDate ? employee.joinDate.split('T')[0] : ''

  return (
    <>
      <PageHeader
        title="Edit Employee"
        description="People"
        icon={<UsersIcon className="h-6 w-6 text-white" />}
        showBack
      />

      <div className="max-w-3xl">
        <Card padding="lg">
          {error && (
            <Alert variant="error" className="mb-6" onDismiss={() => setError(null)}>
              {error}
            </Alert>
          )}

          <form onSubmit={onSubmit} className="space-y-8">
            {/* Basic Info */}
            <FormSection title="Basic Information" description="Personal details of the employee">
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
                <FormField
                  label="Employee ID"
                  name="employeeId"
                  defaultValue={employee.employeeId}
                  disabled
                  hint="Auto-generated, cannot be changed"
                />
                <FormField
                  label="Email"
                  name="email"
                  type="email"
                  required
                  defaultValue={employee.email}
                />
                <FormField
                  label="First Name"
                  name="firstName"
                  required
                  defaultValue={employee.firstName}
                />
                <FormField
                  label="Last Name"
                  name="lastName"
                  required
                  defaultValue={employee.lastName}
                />
                <FormField
                  label="Phone"
                  name="phone"
                  type="tel"
                  defaultValue={employee.phone || ''}
                  placeholder="+1 (555) 000-0000"
                />
              </div>
            </FormSection>

            <CardDivider />

            {/* Work Info */}
            <FormSection title="Work Information" description="Job-related details">
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-5">
                <SelectField
                  label="Department"
                  name="department"
                  required
                  options={departments.map((dept) => ({
                    value: dept.name,
                    label: dept.name,
                  }))}
                  defaultValue={employee.department || ''}
                />
                <FormField
                  label="Position"
                  name="position"
                  required
                  defaultValue={employee.position}
                />
                <FormField
                  label="Join Date"
                  name="joinDate"
                  type="date"
                  required
                  defaultValue={joinDateFormatted}
                />
                <SelectField
                  label="Employment Type"
                  name="employmentType"
                  required
                  options={employmentTypeOptions}
                  defaultValue={employee.employmentType}
                />
                <SelectField
                  label="Status"
                  name="status"
                  required
                  options={statusOptions}
                  defaultValue={employee.status}
                />
                <SelectField
                  label="Reports To"
                  name="reportsToId"
                  options={[
                    { value: '', label: 'No Manager (Top Level)' },
                    ...allEmployees
                      .filter((emp) => emp.id !== id)
                      .map((emp) => ({
                        value: emp.id,
                        label: `${emp.firstName} ${emp.lastName} (${emp.position})`,
                      })),
                  ]}
                  defaultValue={employee.reportsToId || ''}
                />
              </div>
            </FormSection>

            <CardDivider />

            {/* Project Assignments */}
            <FormSection title="Project Assignments" description="Assign this employee to projects">
              <div className="space-y-4">
                {projectMemberships.map((membership, index) => (
                  <div key={index} className="flex items-start gap-3 p-4 bg-slate-50 rounded-lg">
                    <div className="flex-1 grid grid-cols-1 sm:grid-cols-2 gap-4">
                      <div>
                        <label className="block text-sm font-medium text-slate-700 mb-1">
                          Project
                        </label>
                        <select
                          value={membership.projectId}
                          onChange={(e) => updateProjectMembership(index, 'projectId', e.target.value)}
                          className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent"
                        >
                          <option value="">Select project...</option>
                          {availableProjects(index).map((p) => (
                            <option key={p.id} value={p.id}>
                              {p.name} {p.code ? `(${p.code})` : ''}
                            </option>
                          ))}
                          {/* Include current selection even if filtered out */}
                          {membership.projectId && !availableProjects(index).find((p) => p.id === membership.projectId) && (
                            <option value={membership.projectId}>
                              {projects.find((p) => p.id === membership.projectId)?.name || membership.projectId}
                            </option>
                          )}
                        </select>
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-slate-700 mb-1">
                          Role in Project
                        </label>
                        <input
                          type="text"
                          value={membership.role}
                          onChange={(e) => updateProjectMembership(index, 'role', e.target.value)}
                          placeholder="e.g., Developer, Designer, Lead"
                          className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent"
                        />
                      </div>
                    </div>
                    <button
                      type="button"
                      onClick={() => removeProjectMembership(index)}
                      className="mt-6 p-2 text-slate-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition-colors"
                      title="Remove project"
                    >
                      <XIcon className="h-5 w-5" />
                    </button>
                  </div>
                ))}

                {projects.length > 0 && projectMemberships.length < projects.length && (
                  <button
                    type="button"
                    onClick={addProjectMembership}
                    className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-cyan-600 hover:text-cyan-700 hover:bg-cyan-50 rounded-lg transition-colors"
                  >
                    <PlusIcon className="h-4 w-4" />
                    Add Project Assignment
                  </button>
                )}

                {projects.length === 0 && (
                  <p className="text-sm text-slate-500">No projects available. Create projects first.</p>
                )}

                {projectMemberships.length === 0 && projects.length > 0 && (
                  <p className="text-sm text-slate-500">
                    No projects assigned.{' '}
                    <button
                      type="button"
                      onClick={addProjectMembership}
                      className="text-cyan-600 hover:text-cyan-700 font-medium"
                    >
                      Add one
                    </button>
                  </p>
                )}
              </div>
            </FormSection>

            {/* Actions */}
            <FormActions>
              <Button variant="secondary" onClick={goBack}>
                Cancel
              </Button>
              <Button type="submit" loading={submitting}>
                {submitting ? 'Saving...' : 'Save Changes'}
              </Button>
            </FormActions>
          </form>
        </Card>
      </div>
    </>
  )
}
</file>

<file path="apps/hrms/lib/api-client.ts">
// Centralized, typed API client for HRMS
// Avoid direct fetch calls in UI components

export type Employee = {
  id: string
  employeeId: string
  firstName: string
  lastName: string
  email: string
  phone?: string
  department?: string
  dept?: { id: string; name: string } | null
  position: string
  employmentType: string
  joinDate: string
  status: string
  roles?: { id: string; name: string }[]
  reportsToId?: string | null
  manager?: { id: string; firstName: string; lastName: string; position: string } | null
}

export type EmployeeProjectMembership = {
  id: string
  role?: string | null
  joinedAt: string
  project: {
    id: string
    name: string
    code?: string | null
    status: string
  }
}

export type Resource = {
  id: string
  name: string
  category: string
  subcategory?: string | null
  description?: string | null
  email?: string | null
  phone?: string | null
  website?: string | null
  rating?: number | null
}

export type Policy = {
  id: string
  title: string
  category: string
  region: string
  summary?: string | null
  content?: string | null
  fileUrl?: string | null
  version: string
  effectiveDate?: string | null
  status: string
  createdAt?: string
  updatedAt?: string
}

export class ApiError extends Error {
  status: number
  body: any
  constructor(message: string, status: number, body: any) {
    super(message)
    this.status = status
    this.body = body
  }
}

function getApiBase(): string {
  // Allow override via env for future deployments; default to /hrms
  if (typeof process !== 'undefined' && process.env.NEXT_PUBLIC_API_BASE) {
    return process.env.NEXT_PUBLIC_API_BASE
  }
  // Default to /hrms basePath matching next.config.js
  return '/hrms'
}

async function request<T>(path: string, init?: RequestInit): Promise<T> {
  const base = getApiBase()
  const url = `${base}${path}`
  const res = await fetch(url, {
    ...init,
    headers: {
      'Accept': 'application/json',
      ...(init?.headers || {}),
    },
    cache: 'no-store',
  } as RequestInit)

  const ct = res.headers.get('content-type') || ''
  const isJson = ct.includes('application/json')
  let body: any = null
  try {
    body = isJson ? await res.json() : await res.text()
  } catch {
    body = null
  }
  if (!res.ok) {
    const msg = (body && (body.error || body.message)) || `${res.status} ${res.statusText}`
    throw new ApiError(msg, res.status, body)
  }
  return body as T
}

// Employees
export const EmployeesApi = {
  list(params: {
    q?: string
    take?: number
    skip?: number
    department?: string
    status?: string
    employmentType?: string
  } = {}) {
    const qp = new URLSearchParams()
    if (params.q) qp.set('q', params.q)
    if (params.take != null) qp.set('take', String(params.take))
    if (params.skip != null) qp.set('skip', String(params.skip))
    if (params.department) qp.set('department', params.department)
    if (params.status) qp.set('status', params.status)
    if (params.employmentType) qp.set('employmentType', params.employmentType)
    const qs = qp.toString()
    return request<{ items: Employee[]; total: number }>(`/api/employees${qs ? `?${qs}` : ''}`)
  },
  create(payload: Partial<Employee> & {
    firstName: string
    lastName: string
    email: string
    department?: string
    position: string
    employmentType: string
    joinDate: string
    status?: string
  }) {
    return request<Employee>(`/api/employees`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  get(id: string) {
    return request<Employee>(`/api/employees/${encodeURIComponent(id)}`)
  },
  update(id: string, payload: Partial<Employee>) {
    return request<Employee>(`/api/employees/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  delete(id: string) {
    return request<{ ok: boolean }>(`/api/employees/${encodeURIComponent(id)}`, {
      method: 'DELETE',
    })
  },
  listManageable() {
    return request<{ items: Employee[]; total: number }>(`/api/employees/manageable`)
  },
  checkCanManage(employeeId: string) {
    return request<{ canManage: boolean; reason?: string }>(`/api/employees/manageable`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ employeeId }),
    })
  },
  getProjectMemberships(employeeId: string) {
    return request<{ items: EmployeeProjectMembership[] }>(`/api/employees/${encodeURIComponent(employeeId)}/projects`)
  },
  updateProjectMemberships(employeeId: string, memberships: { projectId: string; role?: string }[]) {
    return request<{ items: EmployeeProjectMembership[] }>(`/api/employees/${encodeURIComponent(employeeId)}/projects`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ memberships }),
    })
  },
}

// Resources
export const ResourcesApi = {
  list(params: { q?: string; take?: number; skip?: number; category?: string; subcategories?: string[] } = {}) {
    const qp = new URLSearchParams()
    if (params.q) qp.set('q', params.q)
    if (params.take != null) qp.set('take', String(params.take))
    if (params.skip != null) qp.set('skip', String(params.skip))
    if (params.category) qp.set('category', params.category)
    if (params.subcategories?.length) qp.set('subcategories', params.subcategories.join(','))
    const qs = qp.toString()
    return request<{ items: Resource[]; total: number }>(`/api/resources${qs ? `?${qs}` : ''}`)
  },
  create(payload: Partial<Resource> & { name: string; category: string }) {
    return request<Resource>(`/api/resources`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
}

// Policies
export const PoliciesApi = {
  list(params: { q?: string; take?: number; skip?: number; category?: string; region?: string; status?: string } = {}) {
    const qp = new URLSearchParams()
    if (params.q) qp.set('q', params.q)
    if (params.take != null) qp.set('take', String(params.take))
    if (params.skip != null) qp.set('skip', String(params.skip))
    if (params.category) qp.set('category', params.category)
    if (params.region) qp.set('region', params.region)
    if (params.status) qp.set('status', params.status)
    const qs = qp.toString()
    return request<{ items: Policy[]; total: number }>(`/api/policies${qs ? `?${qs}` : ''}`)
  },
  get(id: string) {
    return request<Policy>(`/api/policies/${encodeURIComponent(id)}`)
  },
  create(payload: Partial<Policy> & { title: string; category: string; region: string; status?: string }) {
    return request<Policy>(`/api/policies`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  update(id: string, payload: Partial<Policy> & { bumpVersion?: 'major' | 'minor' }) {
    return request<Policy>(`/api/policies/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  delete(id: string) {
    return request<{ ok: boolean }>(`/api/policies/${encodeURIComponent(id)}`, {
      method: 'DELETE',
    })
  },
}

// Dashboard
export type DashboardUser = {
  id: string
  firstName: string
  lastName: string
  department: string
  position: string
  avatar: string | null
}

export type DashboardDirectReport = {
  id: string
  employeeId: string
  firstName: string
  lastName: string
  email: string
  department: string
  position: string
  avatar: string | null
}

export type DashboardPendingReview = {
  id: string
  reviewType: string
  reviewPeriod: string
  reviewDate: string
  status: string
  employee: {
    id: string
    firstName: string
    lastName: string
    employeeId: string
  }
}

export type DashboardStat = {
  label: string
  value: number
}

export type DashboardCurrentEmployee = {
  id: string
  employeeId: string
  firstName: string
  lastName: string
  email: string
  phone?: string | null
  department?: string | null
  position: string
  avatar?: string | null
  status: string
  employmentType: string
  joinDate?: string | null
  reportsToId?: string | null
  reportsTo?: {
    id: string
    firstName: string
    lastName: string
  } | null
}

export type DashboardPendingLeaveRequest = {
  id: string
  leaveType: string
  startDate: string
  endDate: string
  totalDays: number
  reason?: string | null
  status: string
  createdAt: string
  employee: {
    id: string
    firstName: string
    lastName: string
    employeeId: string
    avatar?: string | null
  }
}

export type DashboardUpcomingLeave = {
  id: string
  leaveType: string
  startDate: string
  endDate: string
  totalDays: number
  employee: {
    id: string
    firstName: string
    lastName: string
    avatar?: string | null
  }
}

export type LeaveBalance = {
  leaveType: string
  year?: number
  allocated: number
  used: number
  pending: number
  available: number
}

export type DashboardData = {
  user: DashboardUser | null
  isManager: boolean
  currentEmployee: DashboardCurrentEmployee | null
  directReports: DashboardDirectReport[]
  notifications: Notification[]
  unreadNotificationCount: number
  pendingReviews: DashboardPendingReview[]
  pendingLeaveRequests: DashboardPendingLeaveRequest[]
  myLeaveBalance: LeaveBalance[]
  upcomingLeaves: DashboardUpcomingLeave[]
  stats: DashboardStat[]
}

export const DashboardApi = {
  get() {
    return request<DashboardData>(`/api/dashboard`)
  },
}

// Calendar
export type CalendarEvent = {
  id?: string
  summary?: string
  description?: string
  location?: string
  start?: { dateTime?: string; timeZone?: string }
  end?: { dateTime?: string; timeZone?: string }
  htmlLink?: string
}

export const CalendarApi = {
  list() {
    return request<{ items: CalendarEvent[] }>(`/api/calendar/events`)
  },
  create(input: { summary: string; description?: string; location?: string; start: { dateTime: string; timeZone?: string }; end: { dateTime: string; timeZone?: string } }) {
    return request<CalendarEvent>(`/api/calendar/events`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(input),
    })
  }
}

// Performance Reviews
export type PerformanceReview = {
  id: string
  employeeId: string
  employee?: {
    id: string
    firstName: string
    lastName: string
    employeeId: string
    department?: string
    position?: string
    email?: string
  }
  reviewType: string
  reviewPeriod: string
  reviewDate: string
  reviewerName: string
  overallRating: number
  qualityOfWork?: number | null
  productivity?: number | null
  communication?: number | null
  teamwork?: number | null
  initiative?: number | null
  attendance?: number | null
  strengths?: string | null
  areasToImprove?: string | null
  goals?: string | null
  comments?: string | null
  status: string
  createdAt?: string
  updatedAt?: string
}

export const PerformanceReviewsApi = {
  list(params: {
    q?: string
    take?: number
    skip?: number
    employeeId?: string
    reviewType?: string
    status?: string
  } = {}) {
    const qp = new URLSearchParams()
    if (params.q) qp.set('q', params.q)
    if (params.take != null) qp.set('take', String(params.take))
    if (params.skip != null) qp.set('skip', String(params.skip))
    if (params.employeeId) qp.set('employeeId', params.employeeId)
    if (params.reviewType) qp.set('reviewType', params.reviewType)
    if (params.status) qp.set('status', params.status)
    const qs = qp.toString()
    return request<{ items: PerformanceReview[]; total: number }>(`/api/performance-reviews${qs ? `?${qs}` : ''}`)
  },
  get(id: string) {
    return request<PerformanceReview>(`/api/performance-reviews/${encodeURIComponent(id)}`)
  },
  create(payload: Omit<PerformanceReview, 'id' | 'employee' | 'createdAt' | 'updatedAt'>) {
    return request<PerformanceReview>(`/api/performance-reviews`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  update(id: string, payload: Partial<Omit<PerformanceReview, 'id' | 'employeeId' | 'employee' | 'createdAt' | 'updatedAt'>>) {
    return request<PerformanceReview>(`/api/performance-reviews/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  delete(id: string) {
    return request<{ ok: boolean }>(`/api/performance-reviews/${encodeURIComponent(id)}`, {
      method: 'DELETE',
    })
  },
}

// Disciplinary Actions
export type DisciplinaryAction = {
  id: string
  employeeId: string
  employee?: {
    id: string
    firstName: string
    lastName: string
    employeeId: string
    department?: string
    position?: string
    email?: string
  }
  violationType: string
  violationReason: string
  severity: string
  incidentDate: string
  reportedDate: string
  reportedBy: string
  description: string
  witnesses?: string | null
  evidence?: string | null
  actionTaken: string
  actionDate?: string | null
  actionDetails?: string | null
  followUpDate?: string | null
  followUpNotes?: string | null
  status: string
  resolution?: string | null
  createdAt?: string
  updatedAt?: string
}

export const DisciplinaryActionsApi = {
  list(params: {
    q?: string
    take?: number
    skip?: number
    employeeId?: string
    violationType?: string
    severity?: string
    status?: string
  } = {}) {
    const qp = new URLSearchParams()
    if (params.q) qp.set('q', params.q)
    if (params.take != null) qp.set('take', String(params.take))
    if (params.skip != null) qp.set('skip', String(params.skip))
    if (params.employeeId) qp.set('employeeId', params.employeeId)
    if (params.violationType) qp.set('violationType', params.violationType)
    if (params.severity) qp.set('severity', params.severity)
    if (params.status) qp.set('status', params.status)
    const qs = qp.toString()
    return request<{ items: DisciplinaryAction[]; total: number }>(`/api/disciplinary-actions${qs ? `?${qs}` : ''}`)
  },
  get(id: string) {
    return request<DisciplinaryAction>(`/api/disciplinary-actions/${encodeURIComponent(id)}`)
  },
  create(payload: Omit<DisciplinaryAction, 'id' | 'employee' | 'reportedDate' | 'createdAt' | 'updatedAt'>) {
    return request<DisciplinaryAction>(`/api/disciplinary-actions`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  update(id: string, payload: Partial<Omit<DisciplinaryAction, 'id' | 'employeeId' | 'employee' | 'reportedDate' | 'createdAt' | 'updatedAt'>>) {
    return request<DisciplinaryAction>(`/api/disciplinary-actions/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  delete(id: string) {
    return request<{ ok: boolean }>(`/api/disciplinary-actions/${encodeURIComponent(id)}`, {
      method: 'DELETE',
    })
  },
}

// HR Calendar Events
export type HRCalendarEvent = {
  id: string
  title: string
  description?: string | null
  eventType: string
  startDate: string
  endDate?: string | null
  allDay: boolean
  employeeId?: string | null
  relatedRecordId?: string | null
  relatedRecordType?: string | null
  googleEventId?: string | null
  createdAt?: string
  updatedAt?: string
}

export const HRCalendarApi = {
  list(params: {
    q?: string
    take?: number
    skip?: number
    eventType?: string
    employeeId?: string
    startDate?: string
    endDate?: string
  } = {}) {
    const qp = new URLSearchParams()
    if (params.q) qp.set('q', params.q)
    if (params.take != null) qp.set('take', String(params.take))
    if (params.skip != null) qp.set('skip', String(params.skip))
    if (params.eventType) qp.set('eventType', params.eventType)
    if (params.employeeId) qp.set('employeeId', params.employeeId)
    if (params.startDate) qp.set('startDate', params.startDate)
    if (params.endDate) qp.set('endDate', params.endDate)
    const qs = qp.toString()
    return request<{ items: HRCalendarEvent[]; total: number }>(`/api/hr-calendar${qs ? `?${qs}` : ''}`)
  },
  get(id: string) {
    return request<HRCalendarEvent>(`/api/hr-calendar/${encodeURIComponent(id)}`)
  },
  create(payload: Omit<HRCalendarEvent, 'id' | 'googleEventId' | 'createdAt' | 'updatedAt'>) {
    return request<HRCalendarEvent>(`/api/hr-calendar`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  update(id: string, payload: Partial<Omit<HRCalendarEvent, 'id' | 'googleEventId' | 'createdAt' | 'updatedAt'>>) {
    return request<HRCalendarEvent>(`/api/hr-calendar/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  delete(id: string) {
    return request<{ ok: boolean }>(`/api/hr-calendar/${encodeURIComponent(id)}`, {
      method: 'DELETE',
    })
  },
}

// Google Admin Users
export type GoogleAdminUser = {
  googleId: string
  email: string
  firstName: string
  lastName: string
  fullName: string
  department: string | null
  position: string | null
  phone: string | null
  orgUnit: string
  isAdmin: boolean
  createdAt: string
  lastLogin: string
  photoUrl: string | null
}

export const GoogleAdminApi = {
  listUsers() {
    return request<{ items: GoogleAdminUser[]; total: number }>(`/api/google-admin/users`)
  },
}

// Notifications
export type Notification = {
  id: string
  type: string
  title: string
  message: string
  link?: string | null
  relatedId?: string | null
  relatedType?: string | null
  employeeId?: string | null
  isRead: boolean
  createdAt: string
}

export const NotificationsApi = {
  list(params: { unreadOnly?: boolean; limit?: number } = {}) {
    const qp = new URLSearchParams()
    if (params.unreadOnly) qp.set('unreadOnly', 'true')
    if (params.limit != null) qp.set('limit', String(params.limit))
    const qs = qp.toString()
    return request<{ items: Notification[]; unreadCount: number }>(`/api/notifications${qs ? `?${qs}` : ''}`)
  },
  markAsRead(ids: string[]) {
    return request<{ ok: boolean }>(`/api/notifications`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ids }),
    })
  },
  markAllAsRead() {
    return request<{ ok: boolean }>(`/api/notifications`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ markAllRead: true }),
    })
  },
}

// Hierarchy
export type HierarchyEmployee = {
  id: string
  employeeId: string
  firstName: string
  lastName: string
  email: string
  department: string
  position: string
  employmentType: string
  avatar: string | null
  reportsToId: string | null
  status: string
}

export const HierarchyApi = {
  getDirectReports() {
    return request<{ items: HierarchyEmployee[]; currentEmployeeId: string | null }>(`/api/hierarchy?type=direct-reports`)
  },
  getManagerChain() {
    return request<{ items: HierarchyEmployee[]; currentEmployeeId: string | null }>(`/api/hierarchy?type=manager-chain`)
  },
  getFull() {
    return request<{
      items: HierarchyEmployee[]
      currentEmployeeId: string | null
      managerChainIds: string[]
      directReportIds: string[]
    }>(`/api/hierarchy?type=full`)
  },
}

// Leave Requests
export type LeaveRequest = {
  id: string
  employeeId: string
  employee?: {
    id: string
    firstName: string
    lastName: string
    employeeId: string
    avatar: string | null
  }
  leaveType: string
  startDate: string
  endDate: string
  totalDays: number
  reason?: string | null
  status: string
  reviewedById?: string | null
  reviewedBy?: {
    id: string
    firstName: string
    lastName: string
  } | null
  reviewedAt?: string | null
  reviewNotes?: string | null
  createdAt: string
  updatedAt: string
}

export const LeavesApi = {
  list(params: {
    employeeId?: string
    status?: string
    startDate?: string
    endDate?: string
    take?: number
    skip?: number
  } = {}) {
    const qp = new URLSearchParams()
    if (params.employeeId) qp.set('employeeId', params.employeeId)
    if (params.status) qp.set('status', params.status)
    if (params.startDate) qp.set('startDate', params.startDate)
    if (params.endDate) qp.set('endDate', params.endDate)
    if (params.take != null) qp.set('take', String(params.take))
    if (params.skip != null) qp.set('skip', String(params.skip))
    const qs = qp.toString()
    return request<{ items: LeaveRequest[]; total: number }>(`/api/leaves${qs ? `?${qs}` : ''}`)
  },
  get(id: string) {
    return request<LeaveRequest>(`/api/leaves/${encodeURIComponent(id)}`)
  },
  create(payload: {
    employeeId: string
    leaveType: string
    startDate: string
    endDate: string
    totalDays: number
    reason?: string
  }) {
    return request<LeaveRequest>(`/api/leaves`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  update(id: string, payload: Partial<{
    status: string
    reviewNotes?: string
  }>) {
    return request<LeaveRequest>(`/api/leaves/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  delete(id: string) {
    return request<{ ok: boolean }>(`/api/leaves/${encodeURIComponent(id)}`, {
      method: 'DELETE',
    })
  },
  getBalance(params: { employeeId: string; year?: number } = { employeeId: '' }) {
    const qp = new URLSearchParams()
    if (params.employeeId) qp.set('employeeId', params.employeeId)
    if (params.year != null) qp.set('year', String(params.year))
    const qs = qp.toString()
    return request<{ balances: LeaveBalance[] }>(`/api/leaves/balance${qs ? `?${qs}` : ''}`)
  },
}

// Departments
export type DepartmentHead = {
  id: string
  employeeId: string
  firstName: string
  lastName: string
  email: string
  position: string
  avatar?: string | null
}

export type Department = {
  id: string
  name: string
  code?: string | null
  kpi?: string | null
  headId?: string | null
  head?: DepartmentHead | null
  parentId?: string | null
  parent?: { id: string; name: string } | null
  children?: { id: string; name: string }[]
  _count?: {
    employees: number
    children?: number
  }
}

export const DepartmentsApi = {
  list() {
    return request<{ items: Department[] }>('/api/departments')
  },
  get(id: string) {
    return request<Department>(`/api/departments/${encodeURIComponent(id)}`)
  },
  getHierarchy() {
    return request<{ items: Department[] }>('/api/departments/hierarchy')
  },
  create(payload: { name: string; code?: string; kpi?: string; headId?: string; parentId?: string }) {
    return request<Department>('/api/departments', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  update(id: string, payload: Partial<{ name: string; code: string; kpi: string; headId: string; parentId: string }>) {
    return request<Department>(`/api/departments/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  delete(id: string) {
    return request<{ success: boolean }>(`/api/departments/${encodeURIComponent(id)}`, {
      method: 'DELETE',
    })
  },
}

// Projects
export type ProjectLead = {
  id: string
  employeeId: string
  firstName: string
  lastName: string
  email: string
  position: string
  avatar?: string | null
}

export type ProjectMember = {
  id: string
  role?: string | null
  employee: {
    id: string
    employeeId: string
    firstName: string
    lastName: string
    email: string
    position: string
    department: string
    avatar?: string | null
  }
}

export type Project = {
  id: string
  name: string
  code?: string | null
  description?: string | null
  status: string
  leadId?: string | null
  lead?: ProjectLead | null
  members?: ProjectMember[]
  startDate?: string | null
  endDate?: string | null
  _count?: {
    members: number
  }
}

export const ProjectsApi = {
  list() {
    return request<{ items: Project[] }>('/api/projects')
  },
  get(id: string) {
    return request<Project>(`/api/projects/${encodeURIComponent(id)}`)
  },
  getHierarchy() {
    return request<{ items: Project[] }>('/api/projects/hierarchy')
  },
  create(payload: { name: string; code?: string; description?: string; status?: string; leadId?: string; startDate?: string; endDate?: string }) {
    return request<Project>('/api/projects', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  update(id: string, payload: Partial<{ name: string; code: string; description: string; status: string; leadId: string; startDate: string; endDate: string }>) {
    return request<Project>(`/api/projects/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
  },
  delete(id: string) {
    return request<{ success: boolean }>(`/api/projects/${encodeURIComponent(id)}`, {
      method: 'DELETE',
    })
  },
}
</file>

<file path="apps/hrms/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
  output   = "../../../packages/prisma-hrms/generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Employee {
  id               String         @id @default(cuid())
  employeeId       String         @unique
  googleId         String?        @unique  // Google Workspace user ID for sync
  firstName        String
  lastName         String
  email            String         @unique
  phone            String?
  avatar           String?

  dateOfBirth      DateTime?
  gender           String?
  maritalStatus    String?
  nationality      String?
  address          String?
  city             String?
  country          String?
  postalCode       String?

  department       String
  departmentId     String?
  dept             Department?    @relation(fields: [departmentId], references: [id])
  position         String
  employmentType   EmploymentType  @default(FULL_TIME)
  joinDate         DateTime
  status           EmployeeStatus  @default(ACTIVE)

  // Reporting hierarchy (self-referential)
  reportsToId      String?
  manager          Employee?      @relation("EmployeeHierarchy", fields: [reportsToId], references: [id])
  directReports    Employee[]     @relation("EmployeeHierarchy")

  // Local override flags for Google sync
  departmentLocalOverride  Boolean @default(false)
  positionLocalOverride    Boolean @default(false)

  salary           Float?
  currency         String          @default("USD")

  emergencyContact String?
  emergencyPhone   String?

  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  files            EmployeeFile[]
  roles            Role[]
  performanceReviews PerformanceReview[]
  disciplinaryActions DisciplinaryAction[]
  notifications    Notification[]
  departmentsLed   Department[]    @relation("DepartmentHead")
  projectsLed      Project[]       @relation("ProjectLead")
  projectMemberships ProjectMember[]

  @@index([email])
  @@index([employeeId])
  @@index([department])
  @@index([departmentId])
  @@index([status])
  @@index([reportsToId])
}

model EmployeeFile {
  id          String   @id @default(cuid())
  employee    Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  employeeId  String
  title       String
  fileUrl     String
  uploadedAt  DateTime @default(now())

  @@index([employeeId])
}

model Department {
  id          String     @id @default(cuid())
  name        String     @unique
  code        String?    @unique
  kpi         String?    // Key performance indicator for this department

  // Department head (who leads this department)
  headId      String?
  head        Employee?  @relation("DepartmentHead", fields: [headId], references: [id])

  // Nested department hierarchy
  parentId    String?
  parent      Department?  @relation("DepartmentHierarchy", fields: [parentId], references: [id])
  children    Department[] @relation("DepartmentHierarchy")

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  employees   Employee[]

  @@index([headId])
  @@index([parentId])
}

model Project {
  id          String        @id @default(cuid())
  name        String        @unique
  code        String?       @unique
  description String?
  status      ProjectStatus @default(ACTIVE)

  // Project lead
  leadId      String?
  lead        Employee?     @relation("ProjectLead", fields: [leadId], references: [id])

  // Team members
  members     ProjectMember[]

  startDate   DateTime?
  endDate     DateTime?

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([leadId])
  @@index([status])
}

model ProjectMember {
  id         String   @id @default(cuid())
  projectId  String
  project    Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  role       String?  // Role within the project (e.g., "Developer", "Designer")
  joinedAt   DateTime @default(now())

  @@unique([projectId, employeeId])
  @@index([projectId])
  @@index([employeeId])
}

enum ProjectStatus {
  PLANNING
  ACTIVE
  ON_HOLD
  COMPLETED
  CANCELLED
}

model Role {
  id          String     @id @default(cuid())
  name        String     @unique
  description String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  employees   Employee[]
}

model Resource {
  id           String            @id @default(cuid())
  name         String
  category     ResourceCategory
  subcategory  String?
  description  String?
  contactName  String?
  email        String?
  phone        String?
  website      String?
  address      String?
  city         String?
  country      String?
  tags         String[]
  rating       Float?
  notes        String?

  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@index([category])
  @@index([category, subcategory])
  @@index([name])
}

model Policy {
  id            String        @id @default(cuid())
  title         String
  category      PolicyCategory
  region        Region
  summary       String?
  content       String?
  fileUrl       String?
  version       String        @default("1.0")
  effectiveDate DateTime?
  status        PolicyStatus  @default(ACTIVE)

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@unique([category, region])
  @@unique([effectiveDate])
  @@index([category])
  @@index([region])
  @@index([status])
}

model Notification {
  id            String           @id @default(cuid())
  type          NotificationType
  title         String
  message       String
  link          String?          // Optional link to related resource (e.g., /policies/xyz)

  // Target specific employee (null = broadcast to all)
  employeeId    String?
  employee      Employee?        @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  // For tracking which record triggered the notification
  relatedId     String?
  relatedType   String?          // "POLICY", "REVIEW", etc.

  isRead        Boolean          @default(false)
  createdAt     DateTime         @default(now())

  @@index([type])
  @@index([isRead])
  @@index([createdAt])
  @@index([employeeId])
}

enum NotificationType {
  POLICY_CREATED
  POLICY_UPDATED
  POLICY_ARCHIVED
  ANNOUNCEMENT
  SYSTEM
  PROFILE_INCOMPLETE
}

enum EmploymentType {
  FULL_TIME
  PART_TIME
  CONTRACT
  INTERN
  WORKING_PARTNER
}

enum EmployeeStatus {
  ACTIVE
  ON_LEAVE
  TERMINATED
  RESIGNED
}

enum ResourceCategory {
  ACCOUNTING
  LEGAL
  DESIGN
  MARKETING
  IT
  HR
  OTHER
}

enum PolicyCategory {
  LEAVE
  PERFORMANCE
  CONDUCT
  SECURITY
  COMPENSATION
  OTHER
}

enum PolicyStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

enum Region {
  ALL
  KANSAS_US
  PAKISTAN
}

// ============ PERFORMANCE MANAGEMENT ============

model PerformanceReview {
  id              String              @id @default(cuid())
  employee        Employee            @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  employeeId      String
  reviewType      ReviewType
  reviewPeriod    String              // e.g., "Q1 2025", "Annual 2024"
  reviewDate      DateTime
  reviewerName    String

  // Ratings (1-5 scale)
  overallRating   Int                 // 1-5
  qualityOfWork   Int?                // 1-5
  productivity    Int?                // 1-5
  communication   Int?                // 1-5
  teamwork        Int?                // 1-5
  initiative      Int?                // 1-5
  attendance      Int?                // 1-5

  strengths       String?
  areasToImprove  String?
  goals           String?
  comments        String?

  status          ReviewStatus        @default(DRAFT)

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@index([employeeId])
  @@index([reviewType])
  @@index([reviewDate])
  @@index([status])
}

model DisciplinaryAction {
  id              String              @id @default(cuid())
  employee        Employee            @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  employeeId      String

  violationType   ViolationType
  violationReason ViolationReason
  severity        ViolationSeverity

  incidentDate    DateTime
  reportedDate    DateTime            @default(now())
  reportedBy      String

  description     String
  witnesses       String?
  evidence        String?             // file URLs or references

  actionTaken     DisciplinaryActionType
  actionDate      DateTime?
  actionDetails   String?

  followUpDate    DateTime?
  followUpNotes   String?

  status          DisciplinaryStatus  @default(OPEN)
  resolution      String?

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@index([employeeId])
  @@index([violationType])
  @@index([severity])
  @@index([status])
  @@index([incidentDate])
}

model HRCalendarEvent {
  id              String              @id @default(cuid())
  title           String
  description     String?
  eventType       HREventType

  startDate       DateTime
  endDate         DateTime?
  allDay          Boolean             @default(true)

  // Optional link to related records
  employeeId      String?
  relatedRecordId String?             // ID of review, disciplinary action, etc.
  relatedRecordType String?           // "PERFORMANCE_REVIEW", "DISCIPLINARY", etc.

  googleEventId   String?             // For Google Calendar sync

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@index([eventType])
  @@index([startDate])
  @@index([employeeId])
}

enum ReviewType {
  PROBATION       // 90-day review
  QUARTERLY
  SEMI_ANNUAL
  ANNUAL
  PROMOTION
  PIP             // Performance Improvement Plan
}

enum ReviewStatus {
  DRAFT
  PENDING_REVIEW
  COMPLETED
  ACKNOWLEDGED
}

enum ViolationType {
  ATTENDANCE
  CONDUCT
  PERFORMANCE
  POLICY_VIOLATION
  SAFETY
  HARASSMENT
  INSUBORDINATION
  THEFT_FRAUD
  SUBSTANCE_ABUSE
  OTHER
}

enum ViolationReason {
  // Attendance
  EXCESSIVE_ABSENCES
  TARDINESS
  UNAUTHORIZED_LEAVE
  NO_CALL_NO_SHOW

  // Conduct
  UNPROFESSIONAL_BEHAVIOR
  DISRUPTIVE_CONDUCT
  INAPPROPRIATE_LANGUAGE
  DRESS_CODE_VIOLATION

  // Performance
  POOR_QUALITY_WORK
  MISSED_DEADLINES
  FAILURE_TO_FOLLOW_INSTRUCTIONS
  NEGLIGENCE

  // Policy
  CONFIDENTIALITY_BREACH
  DATA_SECURITY_VIOLATION
  EXPENSE_POLICY_VIOLATION
  IT_POLICY_VIOLATION

  // Safety
  SAFETY_PROTOCOL_VIOLATION
  EQUIPMENT_MISUSE

  // Serious
  HARASSMENT_DISCRIMINATION
  WORKPLACE_VIOLENCE
  THEFT
  FRAUD
  FALSIFICATION
  SUBSTANCE_USE_AT_WORK

  OTHER
}

enum ViolationSeverity {
  MINOR           // Verbal warning
  MODERATE        // Written warning
  MAJOR           // Final warning / Suspension
  CRITICAL        // Termination consideration
}

enum DisciplinaryActionType {
  VERBAL_WARNING
  WRITTEN_WARNING
  FINAL_WARNING
  SUSPENSION
  DEMOTION
  TERMINATION
  PIP             // Performance Improvement Plan
  TRAINING_REQUIRED
  NO_ACTION       // Investigation found no violation
}

enum DisciplinaryStatus {
  OPEN
  UNDER_INVESTIGATION
  ACTION_TAKEN
  APPEALED
  CLOSED
  DISMISSED
}

enum HREventType {
  PERFORMANCE_REVIEW
  PROBATION_END
  PIP_REVIEW
  DISCIPLINARY_HEARING
  INTERVIEW
  ONBOARDING
  TRAINING
  COMPANY_EVENT
  HOLIDAY
  OTHER
}
</file>

</files>

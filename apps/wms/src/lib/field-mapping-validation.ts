/**
 * Field Mapping Validation
 * Ensures consistency between import/export configurations and database schema
 */

import { importConfigs } from './import-config'
import { INVENTORY_TRANSACTION_COLUMNS, INVENTORY_BALANCE_COLUMNS } from './column-ordering'
import { Prisma } from '@prisma/client'

export interface FieldMappingValidationResult {
  isValid: boolean
  errors: string[]
  warnings: string[]
}

/**
 * Validates that all export column names are included in the import configuration
 * This ensures that exported data can be re-imported successfully
 */
export function validateImportExportConsistency(entityName: string): FieldMappingValidationResult {
  const result: FieldMappingValidationResult = {
    isValid: true,
    errors: [],
    warnings: []
  }

  const importConfig = importConfigs[entityName]
  if (!importConfig) {
    result.isValid = false
    result.errors.push(`No import configuration found for entity: ${entityName}`)
    return result
  }

  // Get export columns based on entity
  let exportColumns: typeof INVENTORY_TRANSACTION_COLUMNS = []
  
  switch (entityName) {
    case 'inventoryTransactions':
      exportColumns = INVENTORY_TRANSACTION_COLUMNS
      break
    case 'inventoryBalances':
      exportColumns = INVENTORY_BALANCE_COLUMNS
      break
    default:
      result.warnings.push(`No export column configuration found for entity: ${entityName}`)
      return result
  }

  // Check each export column
  exportColumns
    .filter(col => col.showInExport && !col.isRelation)
    .forEach(exportCol => {
      const importField = importConfig.fieldMappings.find(
        field => field.dbField === exportCol.fieldName
      )

      if (!importField) {
        // Check if it's a system-generated field
        const systemFields = ['id', 'transactionId', 'createdAt', 'createdById', 'attachments']
        if (systemFields.includes(exportCol.fieldName)) {
          result.warnings.push(
            `System-generated field '${exportCol.fieldName}' is exported but not imported (this is expected)`
          )
        } else {
          result.isValid = false
          result.errors.push(
            `Export field '${exportCol.fieldName}' with column name '${exportCol.exportName}' is not mapped in import configuration`
          )
        }
      } else {
        // Check if export column name is in the import excel columns
        if (!importField.excelColumns.includes(exportCol.exportName)) {
          result.warnings.push(
            `Export column name '${exportCol.exportName}' for field '${exportCol.fieldName}' is not the first option in import columns: [${importField.excelColumns.join(', ')}]`
          )
        }
      }
    })

  return result
}

/**
 * Validates that all required database fields are mapped in import configuration
 */
export function validateDatabaseFieldMapping(entityName: string): FieldMappingValidationResult {
  const result: FieldMappingValidationResult = {
    isValid: true,
    errors: [],
    warnings: []
  }

  const importConfig = importConfigs[entityName]
  if (!importConfig) {
    result.isValid = false
    result.errors.push(`No import configuration found for entity: ${entityName}`)
    return result
  }

  // Map entity names to Prisma model names
  const entityToModel: Record<string, string> = {
    'inventoryTransactions': 'InventoryTransaction',
    'inventoryBalances': 'InventoryBalance',
    'skus': 'Sku',
    'warehouses': 'Warehouse',
    'warehouseSkuConfigs': 'WarehouseSkuConfig',
    'costRates': 'CostRate'
  }

  const modelName = entityToModel[entityName]
  if (!modelName) {
    result.warnings.push(`No model mapping found for entity: ${entityName}`)
    return result
  }

  // Get model fields from Prisma DMMF
  const model = Prisma.dmmf.datamodel.models.find(m => m.name === modelName)
  if (!model) {
    result.isValid = false
    result.errors.push(`Model ${modelName} not found in Prisma schema`)
    return result
  }

  // Check each database field
  model.fields.forEach(field => {
    // Skip relation fields and system fields
    if (field.kind === 'object' || field.isList) return
    
    const systemFields = ['id', 'createdAt', 'updatedAt']
    if (systemFields.includes(field.name)) return

    // Special handling for computed/auto-generated fields
    const autoGeneratedFields = ['transactionId', 'createdById', 'warehouseId', 'skuId']
    if (autoGeneratedFields.includes(field.name)) {
      result.warnings.push(
        `Field '${field.name}' is auto-generated/resolved during import (not directly imported)`
      )
      return
    }

    const importField = importConfig.fieldMappings.find(
      mapping => mapping.dbField === field.name
    )

    if (!importField) {
      if (field.isRequired && !field.hasDefaultValue) {
        result.isValid = false
        result.errors.push(
          `Required database field '${field.name}' is not mapped in import configuration`
        )
      } else {
        result.warnings.push(
          `Optional database field '${field.name}' is not mapped in import configuration`
        )
      }
    }
  })

  return result
}

/**
 * Validates field types match between import configuration and database schema
 */
export function validateFieldTypes(entityName: string): FieldMappingValidationResult {
  const result: FieldMappingValidationResult = {
    isValid: true,
    errors: [],
    warnings: []
  }

  const importConfig = importConfigs[entityName]
  if (!importConfig) {
    result.isValid = false
    result.errors.push(`No import configuration found for entity: ${entityName}`)
    return result
  }

  const entityToModel: Record<string, string> = {
    'inventoryTransactions': 'InventoryTransaction',
    'inventoryBalances': 'InventoryBalance',
    'skus': 'Sku',
    'warehouses': 'Warehouse',
    'warehouseSkuConfigs': 'WarehouseSkuConfig',
    'costRates': 'CostRate'
  }

  const modelName = entityToModel[entityName]
  if (!modelName) return result

  const model = Prisma.dmmf.datamodel.models.find(m => m.name === modelName)
  if (!model) return result

  importConfig.fieldMappings.forEach(mapping => {
    const dbField = model.fields.find(f => f.name === mapping.dbField)
    if (!dbField || dbField.kind === 'object') return

    // Map import types to Prisma types
    const typeMapping: Record<string, string[]> = {
      'string': ['String'],
      'number': ['Int', 'Float', 'Decimal'],
      'date': ['DateTime'],
      'boolean': ['Boolean'],
      'decimal': ['Decimal', 'Float']
    }

    const expectedTypes = typeMapping[mapping.type]
    if (!expectedTypes || !expectedTypes.includes(dbField.type)) {
      result.warnings.push(
        `Type mismatch for field '${mapping.dbField}': Import type '${mapping.type}' vs DB type '${dbField.type}'`
      )
    }
  })

  return result
}

/**
 * Runs all validation checks for a given entity
 */
export function validateFieldMappings(entityName: string): FieldMappingValidationResult {
  const results = [
    validateImportExportConsistency(entityName),
    validateDatabaseFieldMapping(entityName),
    validateFieldTypes(entityName)
  ]

  const combinedResult: FieldMappingValidationResult = {
    isValid: results.every(r => r.isValid),
    errors: results.flatMap(r => r.errors),
    warnings: results.flatMap(r => r.warnings)
  }

  return combinedResult
}

/**
 * Generates a field mapping report for documentation
 */
export function generateFieldMappingReport(entityName: string): string {
  const importConfig = importConfigs[entityName]
  if (!importConfig) {
    return `No import configuration found for entity: ${entityName}`
  }

  let report = `# Field Mapping Report for ${importConfig.displayName}\n\n`
  report += `## Import Configuration\n\n`
  report += `| DB Field | Excel Columns | Type | Required | Default Value |\n`
  report += `|----------|---------------|------|----------|---------------|\n`

  importConfig.fieldMappings.forEach(field => {
    const excelCols = field.excelColumns.join(', ')
    const required = field.required ? 'Yes' : 'No'
    const defaultVal = field.defaultValue !== undefined ? String(field.defaultValue) : '-'
    report += `| ${field.dbField} | ${excelCols} | ${field.type} | ${required} | ${defaultVal} |\n`
  })

  // Add validation results
  const validation = validateFieldMappings(entityName)
  
  report += `\n## Validation Results\n\n`
  report += `**Status:** ${validation.isValid ? '✅ Valid' : '❌ Invalid'}\n\n`
  
  if (validation.errors.length > 0) {
    report += `### Errors\n`
    validation.errors.forEach(error => {
      report += `- ❌ ${error}\n`
    })
    report += '\n'
  }

  if (validation.warnings.length > 0) {
    report += `### Warnings\n`
    validation.warnings.forEach(warning => {
      report += `- ⚠️ ${warning}\n`
    })
  }

  return report
}